"use strict";
(self["webpackChunksensemaking_tools_prototype"] = self["webpackChunksensemaking_tools_prototype"] || []).push([["src_layout_header_index_tsx"],{

/***/ "./_glue/index.js":
/*!************************!*\
  !*** ./_glue/index.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AmbientVideo: () => (/* reexport safe */ _lib_ambientvideo__WEBPACK_IMPORTED_MODULE_0__.AmbientVideo),
/* harmony export */   Banner: () => (/* reexport safe */ _lib_banner__WEBPACK_IMPORTED_MODULE_1__.Banner),
/* harmony export */   Carousel: () => (/* reexport safe */ _lib_carousel___WEBPACK_IMPORTED_MODULE_2__.Carousel),
/* harmony export */   Copy: () => (/* reexport safe */ _lib_copy__WEBPACK_IMPORTED_MODULE_3__.Copy),
/* harmony export */   Debounce: () => (/* reexport safe */ _lib_debounce___WEBPACK_IMPORTED_MODULE_4__.Debounce),
/* harmony export */   ExpansionPanels: () => (/* reexport safe */ _lib_expansionpanels___WEBPACK_IMPORTED_MODULE_5__.ExpansionPanels),
/* harmony export */   Filter: () => (/* reexport safe */ _lib_filter___WEBPACK_IMPORTED_MODULE_6__.Filter),
/* harmony export */   FilterStateManager: () => (/* reexport safe */ _lib_filter___WEBPACK_IMPORTED_MODULE_6__.FilterStateManager),
/* harmony export */   Footer: () => (/* reexport safe */ _lib_footer__WEBPACK_IMPORTED_MODULE_7__.Footer),
/* harmony export */   Header: () => (/* reexport safe */ _lib_header__WEBPACK_IMPORTED_MODULE_8__.Header),
/* harmony export */   Jumplinks: () => (/* reexport safe */ _lib_jumplinks___WEBPACK_IMPORTED_MODULE_9__.Jumplinks),
/* harmony export */   Modal: () => (/* reexport safe */ _lib_modal__WEBPACK_IMPORTED_MODULE_10__.Modal),
/* harmony export */   ResponsiveMonitor: () => (/* reexport safe */ _lib_responsivemonitor___WEBPACK_IMPORTED_MODULE_11__.ResponsiveMonitor),
/* harmony export */   ScrollManager: () => (/* reexport safe */ _lib_smoothscroll_scrollmanager__WEBPACK_IMPORTED_MODULE_13__.ScrollManager),
/* harmony export */   SmoothScroll: () => (/* reexport safe */ _lib_smoothscroll___WEBPACK_IMPORTED_MODULE_12__.SmoothScroll),
/* harmony export */   Social: () => (/* reexport safe */ _lib_social__WEBPACK_IMPORTED_MODULE_14__.Social),
/* harmony export */   TabPanels: () => (/* reexport safe */ _lib_tabpanels__WEBPACK_IMPORTED_MODULE_15__.TabPanels),
/* harmony export */   Tabs: () => (/* reexport safe */ _lib_tabs__WEBPACK_IMPORTED_MODULE_16__.Tabs),
/* harmony export */   Tooltip: () => (/* reexport safe */ _lib_tooltip__WEBPACK_IMPORTED_MODULE_17__.Tooltip),
/* harmony export */   YoutubeVideo: () => (/* reexport safe */ _lib_ytvideo__WEBPACK_IMPORTED_MODULE_18__.YoutubeVideo)
/* harmony export */ });
/* harmony import */ var _lib_ambientvideo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/ambientvideo */ "./_glue/lib/ambientvideo/index.js");
/* harmony import */ var _lib_banner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/banner */ "./_glue/lib/banner/index.js");
/* harmony import */ var _lib_carousel___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/carousel/ */ "./_glue/lib/carousel/index.js");
/* harmony import */ var _lib_copy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/copy */ "./_glue/lib/copy/index.js");
/* harmony import */ var _lib_debounce___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/debounce/ */ "./_glue/lib/debounce/index.js");
/* harmony import */ var _lib_expansionpanels___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/expansionpanels/ */ "./_glue/lib/expansionpanels/index.js");
/* harmony import */ var _lib_filter___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/filter/ */ "./_glue/lib/filter/index.js");
/* harmony import */ var _lib_footer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/footer */ "./_glue/lib/footer/index.js");
/* harmony import */ var _lib_header__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/header */ "./_glue/lib/header/index.js");
/* harmony import */ var _lib_jumplinks___WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/jumplinks/ */ "./_glue/lib/jumplinks/index.js");
/* harmony import */ var _lib_modal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/modal */ "./_glue/lib/modal/index.js");
/* harmony import */ var _lib_responsivemonitor___WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/responsivemonitor/ */ "./_glue/lib/responsivemonitor/index.js");
/* harmony import */ var _lib_smoothscroll___WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/smoothscroll/ */ "./_glue/lib/smoothscroll/index.js");
/* harmony import */ var _lib_smoothscroll_scrollmanager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/smoothscroll/scrollmanager */ "./_glue/lib/smoothscroll/scrollmanager.js");
/* harmony import */ var _lib_social__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/social */ "./_glue/lib/social/index.js");
/* harmony import */ var _lib_tabpanels__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/tabpanels */ "./_glue/lib/tabpanels/index.js");
/* harmony import */ var _lib_tabs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/tabs */ "./_glue/lib/tabs/index.js");
/* harmony import */ var _lib_tooltip__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/tooltip */ "./_glue/lib/tooltip/index.js");
/* harmony import */ var _lib_ytvideo__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/ytvideo */ "./_glue/lib/ytvideo/index.js");
/**
 * @fileoverview Glue lib component source re-export.
 * **ONLY USED FOR THE NODE MODULE**
 */























/***/ }),

/***/ "./_glue/lib/ambientvideo/constants.js":
/*!*********************************************!*\
  !*** ./_glue/lib/ambientvideo/constants.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   ErrorMessage: () => (/* binding */ ErrorMessage)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-ambient-video';
CssClasses['BUTTON'] = 'glue-ambient-video__button';
CssClasses['BUTTON_PAUSE'] = 'glue-ambient-video__button--paused';
CssClasses['BUTTON_ICON'] = 'glue-ambient-video__icon';
CssClasses['BUTTON_ICON_PLAY'] = 'glue-ambient-video__icon-play';
CssClasses['BUTTON_ICON_PAUSE'] = 'glue-ambient-video__icon-pause';
CssClasses['VIDEO_CONTAINER'] = 'glue-ambient-video__container';
CssClasses['LIGHT'] = 'glue-ambient-video--light';
CssClasses['TOOLTIP'] = 'glue-ambient-video__tooltip';
CssClasses['TOOLTIP_PLAY'] = 'glue-ambient-video__tooltip-play';
CssClasses['TOOLTIP_PAUSE'] = 'glue-ambient-video__tooltip-pause';
})(CssClasses || (CssClasses = {}));
var ErrorMessage;
(function(ErrorMessage) {
ErrorMessage['BUTTON_ELEMENT_MISSING'] = 'Ambient Button element is missing.';
ErrorMessage['BUTTON_ICON_ELEMENT_MISSING'] =
    'Ambient Button Icon element is missing';
ErrorMessage['MEDIA_ELEMENT_MISSING'] = 'Ambient Media element is missing.';
ErrorMessage['PLAY_VIDEO_ERROR'] = 'Play video interrupted.';
ErrorMessage['TOOLTIP_PLAY_MISSING'] =
    'Ambient Tooltip play element is missing';
ErrorMessage['TOOLTIP_PAUSE_MISSING'] =
    'Ambient Tooltip pause element is missing';
})(ErrorMessage || (ErrorMessage = {}));



/***/ }),

/***/ "./_glue/lib/ambientvideo/index.js":
/*!*****************************************!*\
  !*** ./_glue/lib/ambientvideo/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AmbientVideo: () => (/* binding */ AmbientVideo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./_glue/lib/ambientvideo/constants.js");









/**
 * Glue Ambient Video component
 */
class AmbientVideo extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root) {
    super(root);
    /**
     * Checks the state of video and play/pause accordingly.
     * Adds/Removes the class to toggle the text of tooltip and svg icon
     */
    this.togglePlayerState = (event) => {
      if (event instanceof KeyboardEvent && event.key !== _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER &&
          event.key !== _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE) {
        return;
      }
      if (!this.videoContainer.paused) {
        this.pauseVideo();
      } else {
        this.playVideo();
      }
    };
    const mediaElement =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.VIDEO_CONTAINER}`);
    if (!mediaElement) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.MEDIA_ELEMENT_MISSING);
    } else {
      this.videoContainer = mediaElement;
    }
    let element = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.BUTTON_ELEMENT_MISSING);
    } else {
      this.button = element;
    }
    element = this.button.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON_ICON}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.BUTTON_ICON_ELEMENT_MISSING);
    } else {
      this.icon = element;
    }
    element = this.button.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.TOOLTIP_PLAY}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.TOOLTIP_PLAY_MISSING);
    } else {
      this.tooltipPlay = element;
    }
    element = this.button.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.TOOLTIP_PAUSE}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.TOOLTIP_PAUSE_MISSING);
    } else {
      this.tooltipPause = element;
    }
    this.playVideo();
    this.initialize();
  }
  initialize() {
    this.button.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.BUTTON);
    this.button.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE;
    this.icon.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
    this.setTooltipId();
    this.button.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.togglePlayerState);
    this.button.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.togglePlayerState);
  }
  /**
   * Set default ID value for tooltips if they are not provided.
   */
  setTooltipId() {
    if (!this.tooltipPlay || !this.tooltipPause) return;
    if (!this.tooltipPlay.id) {
      this.tooltipPlay.id = _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.TOOLTIP_PLAY;
    }
    if (!this.tooltipPause.id) {
      this.tooltipPause.id = _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.TOOLTIP_PAUSE;
    }
  }
  /**
   * Plays video
   */
  playVideo() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(this, void 0, void 0, function*() {
      try {
        yield this.videoContainer.play();
        this.button.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON_PAUSE);
        this.button.setAttribute(
            _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY, this.tooltipPause.id);
      } catch (error) {
        this.button.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON_PAUSE);
        console.error(error);
      }
    });
  }
  /**
   * Pause video
   */
  pauseVideo() {
    this.videoContainer.pause();
    this.button.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON_PAUSE);
    this.button.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY, this.tooltipPlay.id);
  }
  /**
   * Resets component and removes event listeners.
   */
  destroy() {
    this.button.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
    this.button.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL);
    this.button.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    this.icon.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
    this.button.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.togglePlayerState);
    this.button.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.togglePlayerState);
  }
}



/***/ }),

/***/ "./_glue/lib/banner/constants.js":
/*!***************************************!*\
  !*** ./_glue/lib/banner/constants.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Numbers: () => (/* binding */ Numbers),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Banner component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['BANNER'] = 'glue-banner';
CssClasses['BANNER_CONTENT'] = 'glue-banner__content';
CssClasses['BANNER_CLOSE_BUTTON'] = 'glue-banner__close-btn';
CssClasses['BANNER_HIDDEN'] = 'glue-banner--hidden';
})(CssClasses || (CssClasses = {}));
var Numbers;
(function(Numbers) {
Numbers[Numbers['BANNER_CLOSE_DELAY'] = 300] = 'BANNER_CLOSE_DELAY';
})(Numbers || (Numbers = {}));
var Strings;
(function(Strings) {
Strings['DEFAULT_CLOSE_BUTTON_ARIA_LABEL'] = 'Hide the banner';
Strings['DEFAULT_EMPHASIS'] = 'low';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/banner/index.js":
/*!***********************************!*\
  !*** ./_glue/lib/banner/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Banner: () => (/* binding */ Banner)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./_glue/lib/banner/constants.js");





/**
 * A class that displays an important message or helps user perform action
 * through links or button.
 */
class Banner extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root) {
    var _a;
    super(root);
    this.handleClick = () => {
      this.close();
    };
    this.closeButton =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.BANNER_CLOSE_BUTTON}`);
    (_a = this.closeButton) === null || _a === void 0 ?
        void 0 :
        _a.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleClick);
  }
  /**
   * Hides the banner component when close button is clicked or is a
   * public method that can directly be called.
   */
  close() {
    this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.BANNER_HIDDEN);
    setTimeout(() => {
      this.root.style.display = 'none';
    }, _constants__WEBPACK_IMPORTED_MODULE_2__.Numbers.BANNER_CLOSE_DELAY);
  }
  /**
   * Removes event listeners.
   */
  destroy() {
    var _a;
    (_a = this.closeButton) === null || _a === void 0 ?
        void 0 :
        _a.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleClick);
  }
}



/***/ }),

/***/ "./_glue/lib/base/index.js":
/*!*********************************!*\
  !*** ./_glue/lib/base/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ Component)
/* harmony export */ });
/**
 * @fileoverview Parent class for Vanilla components
 */
class Component {
  constructor(root) {
    this.root = root;
  }
  /**
   * Subclasses may implement this method to release any resources / deregister
   * any listeners they have attached. An example of this might be
   * deregistering a resize event from the window object.
   */
  destroy() {}
  /**
   * Fires a cross-browser-compatible custom event from the component root of
   * the given type, with the given data.
   */
  emit(evtType, evtData, shouldBubble = false) {
    const evt = new CustomEvent(evtType, {
      detail: evtData,
      bubbles: shouldBubble,
    });
    this.root.dispatchEvent(evt);
  }
}



/***/ }),

/***/ "./_glue/lib/base/utils.js":
/*!*********************************!*\
  !*** ./_glue/lib/base/utils.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getOverlayAutoPosition: () => (/* binding */ getOverlayAutoPosition)
/* harmony export */ });
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/**
 * @fileoverview Shared utility functions for Glue components.
 */

/**
 * Extract numbers from CSS properties, like 20px -> 20.
 * @param val CSS property value.
 */
function toNum(val) {
  return Number(val.slice(0, -2));
}
/**
 * Calculates left/top coordinates for an Overlay element based on the
 * position of the Trigger element and the placement option (default: bottom).
 *
 * By default is uses auto placement which will try to position the Overlay
 * relative to the middle of the trigger element.
 * If there is not enough space it will try to position the Overlay on the
 * opposite side of the trigger element.
 * If there is not enough space on the opposite side it will try to position
 * the Overlay on the edge of the window.
 *
 * If placement is set to left/right/top/bottom it will try to position the
 * Overlay on the specified side of the trigger element. If there is not enough
 * space it will use the auto positioning logic.
 *
 *
 * @param root Root element that contains the Content and Trigger elements.
 * @param overlay Element that contains Overlay content.
 * @param trigger Element that triggers the Overlay.
 * @param placement? Placement of the Overlay, default is bottom. Possible
 *     values are: left, right, top, bottom.
 * @return Array containing overlay absolute positions [left, top].
 */
function getOverlayAutoPosition(
    root, overlay, trigger, placement = 'bottom') {
  const overlayStyle = getComputedStyle(overlay);
  // Ignore auto-positioning if overlay is fixed (such as in Social/mobile).
  if (overlayStyle.position === 'fixed') {
    return null;
  }
  const triggerStyle = getComputedStyle(trigger);
  const triggerCoords = trigger.getBoundingClientRect();
  const overlayCoords = overlay.getBoundingClientRect();
  const firstSrollableParent = getScrollableParent(root);
  const scrollbarParentCoords = firstSrollableParent.getBoundingClientRect();
  const isBody = firstSrollableParent === document.body;
  const scrollableParentHeight =
      isBody ? window.innerHeight : scrollbarParentCoords.bottom;
  // Mirror placement in RTL direction.
  const isRtl = triggerStyle.direction === _constants_attribute__WEBPACK_IMPORTED_MODULE_0__.Direction.RTL ||
      document.documentElement.dir === _constants_attribute__WEBPACK_IMPORTED_MODULE_0__.Direction.RTL;
  if (isRtl) {
    if (placement === 'left') {
      placement = 'right';
    } else if (placement === 'right') {
      placement = 'left';
    }
  }
  let noSpaceAtRight = false;
  let noSpaceAtLeft = false;
  let noSpaceAtTop = false;
  let noSpaceAtBottom = false;
  const horizOffset = placement === 'top' || placement === 'bottom' ?
      Math.abs(triggerCoords.width - overlayCoords.width) / 2 :
      overlayCoords.width;
  // Check left edge of the container.
  noSpaceAtLeft = triggerCoords.left - horizOffset < scrollbarParentCoords.left;
  // Check right edge of the container.
  noSpaceAtRight =
      triggerCoords.right + horizOffset > scrollbarParentCoords.right;
  // Check bottom edge of the container.
  noSpaceAtBottom =
      triggerCoords.top + triggerCoords.height + overlayCoords.height >=
      scrollableParentHeight;
  // Check top edge of the container.
  noSpaceAtTop =
      triggerCoords.top - overlayCoords.height < scrollbarParentCoords.top;
  // If there is not enough space on both left and right side of the trigger,
  // align the center of the overlay with the center of the trigger.
  if (noSpaceAtLeft && noSpaceAtRight) {
    const left = (triggerCoords.width - overlayCoords.width) / 2;
    return noSpaceAtTop ?
        [left, triggerCoords.height + toNum(overlayStyle.marginTop)] :
        [left, -overlayCoords.height - toNum(overlayStyle.marginTop)];
  }
  if (placement === 'left' || placement === 'right') {
    return getOverlayAutoPositionHorizontal(
        placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,
        noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight);
  } else {
    return getOverlayAutoPositionVertical(
        placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,
        noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight);
  }
}
/**
 * Calculates overlay position for horizontal placements.
 */
function getOverlayAutoPositionHorizontal(
    placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,
    noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight) {
  let left = 0;
  let top = 0;
  if (!noSpaceAtTop && !noSpaceAtBottom) {
    // If there is enough space, aligns the center of the overlay with the
    // center of the trigger, including margins.
    const triggerVerticalSpace = triggerCoords.height +
        toNum(triggerStyle.marginTop) + toNum(triggerStyle.marginBottom);
    const overlayVerticalSpace = overlayCoords.height +
        toNum(overlayStyle.marginTop) + toNum(overlayStyle.marginBottom);
    top = (triggerVerticalSpace - overlayVerticalSpace) / 2;
  } else {
    // Align the top of the overlay with the top of the trigger.
    // If there is not enough space, align the bottom of the overlay with the
    // bottom of the trigger.
    top = noSpaceAtTop ? 0 : triggerCoords.height - overlayCoords.height;
    top += toNum(triggerStyle.marginTop) - toNum(overlayStyle.marginTop);
  }
  // Horizontal position after the trigger, including trigger content.
  const rightDistanceFromTrigger =
      triggerCoords.width + toNum(triggerStyle.marginRight);
  // Horizontal position before the trigger, including overlay content.
  const leftDistanceFromTrigger =
      overlayCoords.width + toNum(overlayStyle.marginRight);
  // LEFT: before the trigger.
  // RIGHT: after the trigger.
  // Switch to the opposite side if there is not enough space.
  if (placement === 'left') {
    left = noSpaceAtLeft ? rightDistanceFromTrigger : -leftDistanceFromTrigger;
  } else {
    left = noSpaceAtRight ? -leftDistanceFromTrigger : rightDistanceFromTrigger;
  }
  return [left, top];
}
/**
 * Calculates overlay position for vertical placements.
 */
function getOverlayAutoPositionVertical(
    placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,
    noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight) {
  let left = 0;
  let top = 0;
  if (!noSpaceAtLeft && !noSpaceAtRight) {
    // If there is enough space, aligns the center of the overlay with the
    // center of the trigger.
    left = (triggerCoords.width - overlayCoords.width) / 2;
  } else {
    // Align the left of the overlay with the right of the trigger.
    // If there is not enough space, align the right of the overlay with the
    // left of the trigger.
    let triggerHorizSpace = toNum(triggerStyle.marginLeft);
    let overlayHorizSpace = toNum(overlayStyle.marginLeft);
    if (noSpaceAtRight) {
      triggerHorizSpace += triggerCoords.width;
      overlayHorizSpace += overlayCoords.width;
    }
    left = triggerHorizSpace - overlayHorizSpace;
  }
  // Vertical position above the trigger, including trigger content.
  const downDistanceFromTrigger =
      triggerCoords.height + toNum(overlayStyle.marginTop);
  // Vertical position below the trigger, including overlay content.
  const upDistanceFromTrigger =
      overlayCoords.height + toNum(overlayStyle.marginTop);
  // TOP: above the trigger.
  // BOTTOM: below the trigger.
  // Switch to the opposite side if there is not enough space.
  if (placement === 'top') {
    top = noSpaceAtTop ? downDistanceFromTrigger : -upDistanceFromTrigger;
  } else {
    top = noSpaceAtBottom ? -upDistanceFromTrigger : downDistanceFromTrigger;
  }
  return [left, top];
}
/**
 * Determines scrollable parent element for calculating overlay position.
 * @param elem DOM node for which to find the scrollable parent
 * @return elem DOM node which is the first scrollable parent
 */
function getScrollableParent(elem) {
  // check if overflow property is set.
  const isOverflowSet = (overflowValue) =>
      /auto|hidden|scroll|overlay/.test(overflowValue);
  const computedStyle = getComputedStyle(elem);
  if (elem === document.documentElement) return document.body;
  if (isOverflowSet(computedStyle.overflow) ||
      isOverflowSet(computedStyle.overflowY) ||
      isOverflowSet(computedStyle.overflowX)) {
    return elem;
  } else {
    return getScrollableParent(elem.parentElement);
  }
}


/***/ }),

/***/ "./_glue/lib/carousel/constants.js":
/*!*****************************************!*\
  !*** ./_glue/lib/carousel/constants.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CarouselType: () => (/* binding */ CarouselType),
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Icons: () => (/* binding */ Icons),
/* harmony export */   Numbers: () => (/* binding */ Numbers),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Carousel component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['ACTIVE'] = 'glue-is-active';
CssClasses['BUTTON'] = 'glue-carousel__button';
CssClasses['BUTTON_NEXT'] = 'glue-carousel__button--next';
CssClasses['BUTTON_PREV'] = 'glue-carousel__button--prev';
CssClasses['CARDS'] = 'glue-carousel--cards';
CssClasses['CAROUSEL'] = 'glue-carousel';
CssClasses['DISABLE_GRAB'] = 'glue-carousel__list--disable-grab';
CssClasses['HAS_NAVIGATION'] = 'glue-carousel--has-navigation';
CssClasses['INACTIVE'] = 'glue-is-inactive';
CssClasses['ITEM'] = 'glue-carousel__item';
CssClasses['LIST'] = 'glue-carousel__list';
CssClasses['MODALS'] = 'glue-carousel__modals';
CssClasses['NAVIGATION'] = 'glue-carousel__navigation';
CssClasses['NAVIGATION_DOT'] = 'glue-carousel__dot';
CssClasses['PEEK_OUT'] = 'glue-carousel--peek-out';
CssClasses['VIEWPORT'] = 'glue-carousel__viewport';
})(CssClasses || (CssClasses = {}));
var Icons;
(function(Icons) {
Icons['CHEVRON_RIGHT'] = 'chevron-right';
Icons['CHEVRON_LEFT'] = 'chevron-left';
})(Icons || (Icons = {}));
var Numbers;
(function(Numbers) {
/**
 * A threshold value that corresponds to the Carousel viewport width.
 * It is factor, a value between 0 to 1.
 * E.g. drag threshold is 0.2 * containerWidth.
 */
Numbers[Numbers['DRAG_THRESHOLD'] = 0.2] = 'DRAG_THRESHOLD';
/**
 * The minimum distance that the user needs to move before the carousel
 * recognizes the gesture as a drag (rather than a click, etc).
 */
Numbers[Numbers['DRAGSTART_THRESHOLD_PX'] = 10] = 'DRAGSTART_THRESHOLD_PX';
/**
 * Distance in pixels for the card carousel to peek out on small viewport
 */
Numbers[Numbers['PEEK_DISTANCE'] = 24] = 'PEEK_DISTANCE';
/**
 * When determining the number of slides per page, if the resulting value is
 * within this range from an integer, round up, otherwise round down.
 * E.g. 1.9999962591720426 => 2
 */
Numbers[Numbers['ROUNDING_THRESHOLD'] = 0.05] = 'ROUNDING_THRESHOLD';
})(Numbers || (Numbers = {}));
var Strings;
(function(Strings) {
Strings['DATA_CAROUSEL_ANIMATION_ATTR'] = 'data-glue-carousel-animation';
Strings['DATA_CAROUSEL_NAVIGATION_LABEL_ATTR'] =
    'data-glue-carousel-navigation-label';
Strings['DATA_DOT'] = 'dot';
Strings['DATA_NAVIGATION_LABEL'] = 'glueCarouselNavigationLabel';
Strings['NAVIGATION_ARIA_LABEL_DEFAULT'] = 'Choose slide to display';
Strings['NAVIGATION_LABEL_DEFAULT'] =
    'Selected tab $glue_carousel_page_number$ of $glue_carousel_page_total$';
Strings['NAVIGATION_LABEL_NUMBER_VAR_NAME'] = '$glue_carousel_page_number$';
Strings['NAVIGATION_LABEL_TOTAL_VAR_NAME'] = '$glue_carousel_page_total$';
Strings['NAVIGATION_NEXT_LABEL_DEFAULT'] = 'Go to the next slide';
Strings['NAVIGATION_PREV_LABEL_DEFAULT'] = 'Go to the previous slide';
Strings['RTL'] = 'rtl';
Strings['SLIDE_CHANGE'] = 'gluecarouselslidechange';
Strings['TRANSITION_NONE'] = 'none';
})(Strings || (Strings = {}));
var CarouselType;
(function(CarouselType) {
CarouselType['CARDS'] = 'cards';
CarouselType['IMAGE'] = 'image';
CarouselType['CUSTOM'] = 'custom';
})(CarouselType || (CarouselType = {}));



/***/ }),

/***/ "./_glue/lib/carousel/index.js":
/*!*************************************!*\
  !*** ./_glue/lib/carousel/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Carousel: () => (/* binding */ Carousel)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _focus___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../focus/ */ "./_glue/lib/focus/index.js");
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../observer */ "./_glue/lib/observer/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./_glue/lib/carousel/constants.js");









/** The Glue Carousel component. */
class Carousel extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, options) {
    super(root);
    /** Every navigation dot. */
    this.dots = [];
    /** Total number of pages. */
    this.totalPages = 1;
    /** The number of visible slides within the viewport. */
    this.slidesPerPage = 1;
    /**
     * A flag to turn on/off animation when the component loads.
     * It has been used to jump from the dummy slide to the first/last actual
     * slide.
     */
    this.animateOnInitialLoad = false;
    /** The container width. */
    this.containerWidth = 0;
    /** The slide width. */
    this.slideWidth = 0;
    /** True if this is an RTL page. */
    this.isRtl = document.documentElement.dir === _constants__WEBPACK_IMPORTED_MODULE_6__.Strings.RTL;
    /**
     * Flag to determine whether we're using a tab panel navigation model.
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Tab_Role
     */
    this.isTabModel = true;
    /**
     * Flag to determine whether the carousel should show the navigation dots.
     */
    this.isShowingNavigation = true;
    /** A collection of scroll value for each page */
    this.pagesX = [];
    /** Initial touch position */
    this.initialTouchPos = null;
    /** Flag to determine if the carousel is currently being dragged. */
    this.isDragging = false;
    /** Last touch poistion */
    this.lastTouchPos = null;
    /** True when it is ready to call request animatino frame */
    this.rafPending = false;
    /** Current horizontal position */
    this.currentXPosition = 0;
    /**
     * Set this value to false when dragging option is false and it is on
     * desktop
     */
    this.enableDragging = null;
    /** Re-renders the carousel when the current slide value changes. */
    this.handleCurrentSlideChange = () => {
      this.emit(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.SLIDE_CHANGE, this.getCurrentSlide());
      this.render();
    };
    /** Re-calculates and renders the carousel when the window resizes. */
    this.handleResize = () => {
      this.animateOnInitialLoad = false;
      this.calculate();
      this.render();
      this.updateTouchEvents();
    };
    /** Sets the current slide value to the appropriate slide on UI clicks. */
    this.handleClick = (event) => {
      const target = event.target;
      if (target instanceof HTMLElement ||
          // iOS VoiceOver triggers the event from the svg (b/192919688)
          target instanceof window['SVGElement']) {
        if (target.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.BUTTON_NEXT}`) === this.nextBtn) {
          this.next();
        } else if (
            target.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.BUTTON_PREV}`) === this.prevBtn) {
          this.previous();
        } else if (
            target instanceof HTMLButtonElement && this.dots.includes(target)) {
          const page = Number(target.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.DATA_DOT]);
          this.setCurrentPage(page);
        } else if (this.isCards && this.isDragging) {
          // Do not trigger a card click if the carousel has been dragged.
          event.preventDefault();
        }
      }
    };
    /**
     * Sets the current slide value to the appropriate slide on left/right
     * keyboard press.
     */
    this.handleKeydown = (event) => {
      const isLeft = event.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.LEFT;
      const isRight = event.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.RIGHT;
      if (isLeft || isRight) {
        const isNext = this.isRtl ? isLeft : isRight;
        if (event.target instanceof HTMLButtonElement &&
            this.dots.includes(event.target)) {
          isNext ? this.next() : this.previous();
        } else if (
            event.target instanceof HTMLElement &&
            this.slides.includes(event.target)) {
          const increment = isNext ? 1 : -1;
          this.setCurrentSlide(this.getCurrentSlide() + increment);
        }
      }
    };
    /** Jumps to the real slides (from a dummy) when the transition ends. */
    this.handleTransitionEnd = (event) => {
      if (event.target !== this.slidesContainer) {
        return;
      }
      // Jump to the first or last page if it is cyclical.
      if (this.options.cyclical) {
        const currentSlide = this.getCurrentSlide();
        if (currentSlide > this.totalPages) {
          // Set the flag to false to prevent animation when it jumps from the
          // dummy slide to the real slide.
          this.animateOnInitialLoad = false;
          this.setCurrentSlide(1);
        } else if (currentSlide < 1) {
          this.animateOnInitialLoad = false;
          this.setCurrentSlide(this.totalPages);
        }
      }
    };
    this.handleGestureStart = (event) => {
      event.preventDefault();
      if ((this.isTouchEvent(event) && event.touches.length > 1) ||
          (event instanceof PointerEvent && event.button !== 0)) {
        return;
      }
      // Add the move and end listeners
      if (window.PointerEvent && event instanceof PointerEvent &&
          event.target instanceof Element) {
        event.target.setPointerCapture(event.pointerId);
      } else {
        // Add Mouse Listeners
        document.addEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEMOVE, this.handleGestureMove, true);
        document.addEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEUP, this.handleGestureEnd, true);
      }
      this.initialTouchPos = this.getGesturePointFromEvent(event);
      this.slidesContainer.style.transition = 'initial';
    };
    this.handleGestureMove = (event) => {
      event.preventDefault();
      if (!this.initialTouchPos) {
        return;
      }
      // Prevent small taps/etc triggering a dragging interaction
      const currentTouchPos = this.getGesturePointFromEvent(event);
      if (!this.isDragging) {
        const distanceDragged =
            Math.abs(this.getXDistance(this.initialTouchPos, currentTouchPos));
        if (distanceDragged < _constants__WEBPACK_IMPORTED_MODULE_6__.Numbers.DRAGSTART_THRESHOLD_PX) {
          return;
        }
      }
      this.isDragging = true;
      this.lastTouchPos = currentTouchPos;
      if (this.rafPending) {
        return;
      }
      this.rafPending = true;
      window.requestAnimationFrame(() => {
        this.onAnimFrame();
      });
    };
    this.handleGestureEnd = (event) => {
      var _a;
      event.preventDefault();
      if (this.isTouchEvent(event) &&
          ((_a = event.touches) === null || _a === void 0 ? void 0 :
                                                            _a.length) > 0) {
        return;
      }
      this.rafPending = false;
      // Remove Event Listeners
      if (window.PointerEvent && event instanceof PointerEvent &&
          event.target instanceof Element) {
        event.target.releasePointerCapture(event.pointerId);
      } else {
        // Remove Mouse Listeners
        document.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEMOVE, this.handleGestureMove, true);
        document.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEUP, this.handleGestureEnd, true);
      }
      this.updateSwipeRestPosition();
      this.initialTouchPos = null;
      this.lastTouchPos = null;
      // Resetting after to allow for click handler to be called first
      // (to determine actions based on if carousel has been dragged)
      setTimeout(() => {
        this.isDragging = false;
      }, 0);
    };
    this.isCards = this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.CARDS);
    this.viewport = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.VIEWPORT}`);
    this.slidesContainer = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.LIST}`);
    this.slides = Array.from(
        this.slidesContainer.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.ITEM}`));
    this.slidesRef = Array.from(this.slides);
    this.navigation = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.NAVIGATION}`);
    this.prevBtn = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.BUTTON_PREV}`);
    this.nextBtn = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.BUTTON_NEXT}`);
    this.options = Object.assign(
        Object.assign(Object.assign({}, Carousel.defaults), options),
        this.getDataAttrs());
    this.observer = new _observer__WEBPACK_IMPORTED_MODULE_5__.Observer({currentSlide: this.options.currentSlide});
    this.setup();
    this.registerEvents();
  }
  /** Returns the default carousel options. */
  static get defaults() {
    return {
      currentSlide: 1,
      peekOut: true,
      navigation: true,
      animation: true,
      cyclical: false,
      cardsPerPage: 3,
      dragging: true,
    };
  }
  /** Sets up the component to prepare for the initial rendering. */
  setup() {
    // Add peek out feature class
    if (this.options.peekOut) {
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PEEK_OUT);
    }
    // Copy dummyslides if it is cyclical
    if (this.options.cyclical) {
      this.copyDummySlides();
    }
    // Add a11y attributes (note dynamic values are set in render functions)
    this.slidesContainer.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LIVE, 'polite');
    this.nextBtn.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.root.id);
    this.prevBtn.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.root.id);
    // Calculate and render
    this.calculate();
    this.currentXPosition = -1 * this.pagesX[this.getCurrentPage()];
    this.render();
  }
  /** Registers event listeners. */
  registerEvents() {
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.slidesContainer.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnd);
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.RESIZE, this.handleResize);
    this.updateTouchEvents();
    this.observer.listen('currentSlide', this.handleCurrentSlideChange);
  }
  /** Unregisters event listeners on removal of component. */
  destroy() {
    for (const slide of this.slides) {
      slide.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
      slide.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
      slide.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
    }
    this.slidesContainer.style.removeProperty('transform');
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.slidesContainer.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnd);
    this.destroyNavigation();
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.RESIZE, this.handleResize);
    if (this.enableDragging) {
      this.deregisterTouchEvents();
    }
    this.observer.unlisten('currentSlide', this.handleCurrentSlideChange);
  }
  /** Resets the component to the initial values. */
  reset() {
    this.setCurrentSlide(this.options.currentSlide);
  }
  /** Calculates carousel properties and scroll values. */
  calculate() {
    this.isCards ? this.calculateCardsProperties() : this.calculateProperties();
    this.calcScrollValue();
  }
  /** Calculates and sets properies for non-card carousels. */
  calculateProperties() {
    this.containerWidth =
        toNumber(getComputedStyle(this.slidesContainer).width);
    this.slideWidth = toNumber(getComputedStyle(this.slides[0]).width);
    const slidesPerPage = this.containerWidth / this.slideWidth;
    this.slidesPerPage = 1 - (slidesPerPage % 1) < _constants__WEBPACK_IMPORTED_MODULE_6__.Numbers.ROUNDING_THRESHOLD ?
        Math.ceil(slidesPerPage) :
        Math.floor(slidesPerPage);
    this.totalPages = Math.ceil(this.slidesRef.length / this.slidesPerPage);
    this.isShowingNavigation = this.options.navigation;
    // Only use tabs if there's a 1:1 relationship between slide and dot
    this.isTabModel = this.isShowingNavigation && this.slidesPerPage === 1;
  }
  /**
   * Calculates items per page and total pages attributes (for card carousels)
   * and updates the CSS grid styles accordingly.
   */
  calculateCardsProperties() {
    // Determine number of cards to show on the page
    const breakpoint = this.getCurrentBreakpoint();
    let cardsPerPage;
    switch (breakpoint) {
      case 'sm':
        // Always show one card at a time on mobile
        cardsPerPage = 1;
        break;
      case 'md':
        // Tablet shows one less card per page than desktop (minimum one)
        cardsPerPage = Math.max(1, this.options.cardsPerPage - 1);
        break;
      default:
        // Desktop uses the number of cards set in options
        cardsPerPage = this.options.cardsPerPage;
    }
    // Calculate card & container widths
    const viewportStyles = getComputedStyle(this.viewport);
    let viewportWidth = toNumber(viewportStyles.width) -
        toNumber(viewportStyles.paddingLeft) -
        toNumber(viewportStyles.paddingRight);
    if (this.options.peekOut && breakpoint === 'sm') {
      // Adjust how much of next slide peeks out on small viewport
      viewportWidth = viewportWidth - _constants__WEBPACK_IMPORTED_MODULE_6__.Numbers.PEEK_DISTANCE;
    }
    const gutter =
        toNumber(getComputedStyle(this.slidesContainer)['columnGap']);
    const totalPages = this.slides.length / cardsPerPage;
    const containerWidth =
        Math.floor(viewportWidth * totalPages + (totalPages - 1) * gutter);
    // Update element styles
    this.slidesContainer.style.width = `${containerWidth}px`;
    this.slidesContainer.style['gridTemplateColumns'] =
        `repeat(${this.slides.length}, 1fr)`;
    // Set properties
    this.containerWidth = viewportWidth + gutter;
    this.slidesPerPage = cardsPerPage;
    this.slideWidth = this.containerWidth / cardsPerPage;
    this.totalPages = Math.ceil(totalPages);
    // Never show navigation dots on mobile
    this.isShowingNavigation = this.options.navigation && breakpoint !== 'sm';
    // Never use tab model as items are anchors
    this.isTabModel = false;
  }
  /** Renders all the UI components in Carousel. */
  render() {
    this.renderSlides();
    this.renderButtons();
    this.renderNavigation();
  }
  /** Returns the currently active slide (1-indexed). */
  getCurrentSlide() {
    return this.observer.data['currentSlide'];
  }
  /** Returns the currently visible page (1-indexed). */
  getCurrentPage() {
    return Math.ceil(this.getCurrentSlide() / this.slidesPerPage);
  }
  /** Sets the currently active slide in the state (1-indexed). */
  setCurrentSlide(slide) {
    // Allow setting value to dummies (+/-1) if an animated cyclical carousel
    const buffer = this.options.cyclical && this.options.animation ? 1 : 0;
    const min = 1 - buffer;
    const max = this.slidesRef.length + buffer;
    // Wrap value if cyclical, behaving like a carousel does visually
    // eg. Slide 4 of a 3 slide cylical carousel is 1
    this.observer.data['currentSlide'] =
        this.options.cyclical ? wrap(slide, min, max) : clamp(slide, min, max);
  }
  /** Sets the current slide value to the first slide of the requested page. */
  setCurrentPage(page) {
    const slide = (page - 1) * this.slidesPerPage + 1;
    this.setCurrentSlide(slide);
  }
  /** Sets the current slide value to the previous page. */
  previous() {
    const previousPage = this.getCurrentPage() - 1;
    this.setCurrentPage(previousPage);
  }
  /** Sets the current slide value to the next page. */
  next() {
    const nextPage = this.getCurrentPage() + 1;
    this.setCurrentPage(nextPage);
  }
  /** Renders the appropriate slide attributes. */
  renderSlides() {
    this.transit();
    const currentIndex =
        wrap(this.getCurrentSlide(), 1, this.slidesRef.length) - 1;
    const currentPage = this.getCurrentPage();
    const currentPageIndex = currentPage - 1;
    const isFocused = document.activeElement instanceof HTMLElement &&
        this.slides.includes(document.activeElement);
    for (const [index, slide] of this.slidesRef.entries()) {
      const isCurrent = index === currentIndex;
      const isVisible = isCurrent ||
          // [or] slide is part of the current page
          Math.floor(index / this.slidesPerPage) === currentPageIndex ||
          // [or] it's visible on the last page due to edge alignment
          (currentPage === this.totalPages &&
           index >= this.slidesRef.length - this.slidesPerPage);
      if (isVisible ||
          (this.isCards && document.documentElement.clientWidth < 600)) {
        slide.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
      } else {
        slide.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
      }
      this.isTabModel ? slide.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TABPANEL) :
                        slide.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
      if (this.isCards) {
        slide.tabIndex = isCurrent ? _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE : _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      }
      // If any slide is in focus, move focus to current
      if (isCurrent && isFocused) {
        // Preventing scroll to ensure browser doesn't try and bring the
        // focussed element into view during transition.
        slide.focus({preventScroll: true});
        // To prevent Safari from scrolling.
        // https://caniuse.com/mdn-api_htmlelement_focus_preventscroll_option
        setTimeout(() => {
          this.viewport.scrollLeft = 0;
        }, 0);
      }
    }
    this.removeFocusOnHiddenElements();
  }
  /** Remove keyboard focus on focusable elements in the hidden slides. */
  removeFocusOnHiddenElements() {
    const index = wrap(this.getCurrentSlide(), 1, this.slidesRef.length) - 1;
    const currentIndex = this.options.cyclical ? index + 1 : index;
    for (const [index, slide] of this.slides.entries()) {
      const focusableElements = _focus___WEBPACK_IMPORTED_MODULE_4__.getFocusableElements(slide);
      for (const focusableElement of focusableElements) {
        if (index === currentIndex) {
          focusableElement.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
        } else {
          focusableElement.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
        }
      }
    }
  }
  /**
   *  Turn on/off dragging based on settings and screen size.
   *  In small viewport, dragging is always enabled.
   *  In other viewport sizes, it depends on the component configurations.
   */
  updateTouchEvents() {
    const breakpoint = this.getCurrentBreakpoint();
    if (!this.options.dragging && breakpoint !== 'sm') {
      if (this.enableDragging) this.deregisterTouchEvents();
      this.slidesContainer.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.DISABLE_GRAB);
      this.enableDragging = false;
    } else {
      if (!this.enableDragging) this.registerTouchEvents();
      this.slidesContainer.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.DISABLE_GRAB);
      this.enableDragging = true;
    }
  }
  /** Updates the transform for the viewport. */
  transit() {
    // Turn off animation in the initial loading and when it jumps from the
    // dummy slide to the real slide.
    if (!(this.animateOnInitialLoad && this.options.animation)) {
      this.slidesContainer.style.transition = 'initial';
    }
    // Retrieve the new translateX values
    const newTranslateX = this.pagesX[this.getCurrentPage()];
    this.slidesContainer.style.transform =
        `translate3d(${newTranslateX}px, 0, 0)`;
    this.currentXPosition = newTranslateX;
    // Turn on animation if it is temporarily turned off.
    if (this.options.animation && !this.animateOnInitialLoad) {
      this.turnOnAnimation();
    }
  }
  /** Turns on animation for slides (needs a slight buffer to avoid skips). */
  turnOnAnimation() {
    this.animateOnInitialLoad = true;
    // Use setTimeout to prevent the animation on the initial loading.
    // There is probably a gap before CSS takes the transform value setup in JS.
    setTimeout(() => {
      this.slidesContainer.style.transition = '';
    }, 10);
  }
  /** Renders the appropriate attributes in the dot navigation. */
  renderNavigation() {
    // If no navigation is required, hide
    if (!this.isShowingNavigation) {
      this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.HAS_NAVIGATION);
      return;
    }
    // Show navigation and set a11y attributes
    this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.HAS_NAVIGATION);
    this.isTabModel ?
        this.navigation.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TABLIST) :
        this.navigation.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    // Build dots if number of pages has changed (or first render)
    if (this.dots.length !== this.totalPages) {
      this.buildNavigation();
    }
    const currentIndex = wrap(this.getCurrentPage(), 1, this.totalPages) - 1;
    const isFocused = document.activeElement instanceof HTMLButtonElement &&
        this.dots.includes(document.activeElement);
    for (const [index, dot] of this.dots.entries()) {
      const isCurrent = index === currentIndex;
      dot.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.ACTIVE, isCurrent);
      dot.tabIndex = isCurrent ? _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE : _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      if (this.isTabModel) {
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_SELECTED, `${isCurrent}`);
      } else {
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CURRENT, `${isCurrent}`);
      }
      // If any dot is in focus, move focus to current
      if (isCurrent && isFocused) {
        dot.focus();
      }
    }
  }
  /** Shows or hides the next/previous buttons. */
  renderButtons() {
    if (this.options.cyclical) {
      return;
    }
    const activeElement = document.activeElement;
    const currentPage = this.getCurrentPage();
    const isFirstPage = currentPage === 1;
    const isLastPage = currentPage === this.totalPages;
    // Show/hide buttons
    this.prevBtn.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.INACTIVE, isFirstPage);
    this.nextBtn.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.INACTIVE, isLastPage);
    // If a button was in focus and now hidden, move to other
    if (isLastPage && activeElement === this.nextBtn) {
      this.prevBtn.focus();
    } else if (isFirstPage && activeElement === this.prevBtn) {
      this.nextBtn.focus();
    }
  }
  /** Builds the dot navigation. */
  buildNavigation() {
    var _a;
    this.destroyNavigation();
    // Create a dot per page
    for (let i = 0; i < this.totalPages; i++) {
      const dot = document.createElement('button');
      dot.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.NAVIGATION_DOT);
      dot.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.DATA_DOT] = `${i + 1}`;
      if (this.isTabModel) {
        const id = (_a = this.slidesRef[i * this.slidesPerPage]) === null ||
                _a === void 0 ?
            void 0 :
            _a.id;
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, id);
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY, id);
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TAB);
      } else {
        const template =
            this.navigation.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.DATA_NAVIGATION_LABEL] ||
            _constants__WEBPACK_IMPORTED_MODULE_6__.Strings.NAVIGATION_LABEL_DEFAULT;
        const label =
            template
                .replace(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.NAVIGATION_LABEL_NUMBER_VAR_NAME, `${i + 1}`)
                .replace(
                    _constants__WEBPACK_IMPORTED_MODULE_6__.Strings.NAVIGATION_LABEL_TOTAL_VAR_NAME,
                    `${this.totalPages}`);
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.root.id);
        dot.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL, label);
      }
      this.navigation.appendChild(dot);
      this.dots.push(dot);
    }
  }
  /** Destroys the dot navigation. */
  destroyNavigation() {
    var _a;
    while (this.dots.length) {
      (_a = this.dots.pop()) === null || _a === void 0 ? void 0 : _a.remove();
    }
  }
  /** Copies the first and last slides into the DOM (for cyclical carousels). */
  copyDummySlides() {
    const firstSlide = this.cloneSlide(this.slides[0]);
    const lastSlide = this.cloneSlide(this.slides[this.slides.length - 1]);
    this.slidesContainer.append(firstSlide);
    this.slidesContainer.prepend(lastSlide);
    this.slides = [lastSlide, ...this.slides, firstSlide];
  }
  /** Clones a slide (for first/last dummies). */
  cloneSlide(slide) {
    const clone = slide.cloneNode(true);
    clone.id = `${slide.id}-copy`;
    clone.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
    clone.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
    return clone;
  }
  /** Calculates the scroll values for each page. */
  calcScrollValue() {
    // Determine min/max pages (depending on dummy slides)
    const delta = this.options.cyclical ? 1 : 0;
    const min = 1 - delta;
    const max = this.totalPages + delta;
    // The direction we're moving the slide container in
    const direction = this.isRtl ? 1 : -1;
    this.pagesX = [];
    for (let page = min; page <= max; page++) {
      const pageX =
          page < max ?  // Calculate the x position for the first slide within
                        // that page (not using page - 1 * containerWidth as
                        // slides may not fit exactly)
          (page - 1 + delta) * this.slidesPerPage *
              this.slideWidth :  // For final page, ensure end position is flush
                                   // against container edge
          this.slides.length * this.slideWidth - this.containerWidth;
      this.pagesX[page] = pageX * direction;
    }
  }
  registerTouchEvents() {
    if (window.PointerEvent) {
      // Add Pointer Event Listener
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERDOWN, this.handleGestureStart, true);
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERMOVE, this.handleGestureMove, true);
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERUP, this.handleGestureEnd, true);
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERCANCEL, this.handleGestureEnd, true);
    } else {
      // Add Touch Listener
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHSTART, this.handleGestureStart, true);
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHMOVE, this.handleGestureMove, true);
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHEND, this.handleGestureEnd, true);
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHCANCEL, this.handleGestureEnd, true);
      // Add Mouse Listener
      this.viewport.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEDOWN, this.handleGestureStart, true);
    }
  }
  deregisterTouchEvents() {
    if (window.PointerEvent) {
      // Add Pointer Event Listener
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERDOWN, this.handleGestureStart, true);
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERMOVE, this.handleGestureMove, true);
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERUP, this.handleGestureEnd, true);
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERCANCEL, this.handleGestureEnd, true);
    } else {
      // Add Touch Listener
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHSTART, this.handleGestureStart, true);
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHMOVE, this.handleGestureMove, true);
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHEND, this.handleGestureEnd, true);
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHCANCEL, this.handleGestureEnd, true);
      // Add Mouse Listener
      this.viewport.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEDOWN, this.handleGestureStart, true);
    }
  }
  updateSwipeRestPosition() {
    const differenceInX =
        this.getXDistance(this.initialTouchPos, this.lastTouchPos);
    // Let CSS transition to take charge it
    this.slidesContainer.style.transition = '';
    const validDrag =
        Math.abs(differenceInX) >= this.containerWidth * _constants__WEBPACK_IMPORTED_MODULE_6__.Numbers.DRAG_THRESHOLD;
    // If dragging distance is over 20% of the viewport width, transit to
    // the next/prev page, otherwise rewind to the original position.
    if (validDrag) {
      if ((differenceInX > 0 && !this.isRtl) ||
          (differenceInX < 0 && this.isRtl)) {
        this.next();
      }
      if ((differenceInX < 0 && !this.isRtl) ||
          (differenceInX > 0 && this.isRtl)) {
        this.previous();
      }
    }
    this.transit();
  }
  /** Calculates the x distance between 2 positions. */
  getXDistance(startPosition, endPosition) {
    return startPosition && endPosition ? startPosition.x - endPosition.x : 0;
  }
  getGesturePointFromEvent(event) {
    const point = {x: 0, y: 0};
    if (this.isTouchEvent(event)) {
      if (event.targetTouches) {
        // Prefer Touch Events
        point.x = event.targetTouches[0].clientX;
        point.y = event.targetTouches[0].clientY;
      }
    } else {
      // Either Mouse event or Pointer Event
      point.x = event.clientX;
      point.y = event.clientY;
    }
    return point;
  }
  onAnimFrame() {
    if (!this.rafPending) {
      return;
    }
    const differenceInX =
        this.getXDistance(this.initialTouchPos, this.lastTouchPos);
    const newXTransform = this.currentXPosition - differenceInX;
    const transformStyle = `translate3d(${newXTransform}px, 0, 0)`;
    this.slidesContainer.style.transform = transformStyle;
    this.rafPending = false;
  }
  /** Determines whether the event is a TouchEvent. */
  isTouchEvent(event) {
    return window.TouchEvent && event instanceof TouchEvent;
  }
  /** Returns the options set via data attributes. */
  getDataAttrs() {
    const options = {};
    for (const option of Object.keys(Carousel.defaults)) {
      const attr =
          `glueCarousel${option.toUpperCase().slice(0, 1)}${option.slice(1)}`;
      if (this.root.dataset[attr]) {
        if (option === 'currentSlide' || option === 'cardsPerPage') {
          const value = Number(this.root.dataset[attr]);
          if (!isNaN(value)) options[option] = value;
        } else {
          options[option] = this.root.dataset[attr] === 'true';
        }
      }
    }
    return options;
  }
  /**
   * Retrieves the named breakpoint currently injected in DOM.
   */
  getCurrentBreakpoint() {
    const styles = window.getComputedStyle(document.body, ':after');
    const content = styles.getPropertyValue('content');
    const breakpoint = content.replace(/["']/g, '');
    return breakpoint;
  }
}
/** Clamps a number between the min and max values. */
function clamp(num, min, max) {
  return Math.max(min, Math.min(max, num));
}
/** Converts a CSS property value (as a pixel string) to a number. */
function toNumber(propertyValue) {
  return Number(propertyValue.replace('px', ''));
}
/**
 * Wraps a number between the min and max values (different to clamp as will
 * loop around).
 */
function wrap(num, min, max) {
  const range = max + 1 - min;
  const wrapped = min + ((num - min) % range);
  return wrapped < min ? wrapped + range : wrapped;
}



/***/ }),

/***/ "./_glue/lib/constants/attribute.js":
/*!******************************************!*\
  !*** ./_glue/lib/constants/attribute.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* binding */ Attribute),
/* harmony export */   DataAttrs: () => (/* binding */ DataAttrs),
/* harmony export */   Direction: () => (/* binding */ Direction),
/* harmony export */   Role: () => (/* binding */ Role),
/* harmony export */   TabIndex: () => (/* binding */ TabIndex)
/* harmony export */ });
/**
 * @fileoverview A list of Glue attributes.
 */
var Attribute;
(function(Attribute) {
Attribute['ARIA_CONTROLS'] = 'aria-controls';
Attribute['ARIA_CURRENT'] = 'aria-current';
Attribute['ARIA_DESCRIBEDBY'] = 'aria-describedby';
Attribute['ARIA_EXPANDED'] = 'aria-expanded';
Attribute['ARIA_HASPOPUP'] = 'aria-haspopup';
Attribute['ARIA_HIDDEN'] = 'aria-hidden';
Attribute['ARIA_LABELLEDBY'] = 'aria-labelledby';
Attribute['ARIA_LABEL'] = 'aria-label';
Attribute['ARIA_LIVE'] = 'aria-live';
Attribute['ARIA_MODAL'] = 'aria-modal';
Attribute['ARIA_SELECTED'] = 'aria-selected';
Attribute['INERT'] = 'inert';
Attribute['ROLE'] = 'role';
Attribute['TAB_INDEX'] = 'tabindex';
Attribute['TYPE'] = 'type';
})(Attribute || (Attribute = {}));
var DataAttrs;
(function(DataAttrs) {
DataAttrs['NO_SNIPPET'] = 'nosnippet';
})(DataAttrs || (DataAttrs = {}));
var Direction;
(function(Direction) {
Direction['LTR'] = 'ltr';
Direction['RTL'] = 'rtl';
})(Direction || (Direction = {}));
var Role;
(function(Role) {
Role['COMPLEMENTARY'] = 'complementary';
Role['BUTTON'] = 'button';
Role['DIALOG'] = 'dialog';
Role['REGION'] = 'region';
Role['TABPANEL'] = 'tabpanel';
Role['TABLIST'] = 'tablist';
Role['NAVIGATION'] = 'navigation';
Role['TAB'] = 'tab';
Role['MENU'] = 'menu';
Role['MENUITEM'] = 'menuitem';
Role['MENUBAR'] = 'menubar';
Role['TOOLTIP'] = 'tooltip';
Role['GRIDCELL'] = 'gridcell';
Role['ROW'] = 'row';
Role['PRESENTATION'] = 'presentation';
Role['NONE'] = 'none';
})(Role || (Role = {}));
var TabIndex;
(function(TabIndex) {
TabIndex[TabIndex['TABBABLE'] = 0] = 'TABBABLE';
TabIndex[TabIndex['NOT_TABBABLE'] = -1] = 'NOT_TABBABLE';
})(TabIndex || (TabIndex = {}));



/***/ }),

/***/ "./_glue/lib/constants/classes.js":
/*!****************************************!*\
  !*** ./_glue/lib/constants/classes.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses)
/* harmony export */ });
/**
 * @fileoverview A list of Glue classes.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['SHOW'] = 'glue-is-shown';
CssClasses['ACTIVE'] = 'glue-is-active';
})(CssClasses || (CssClasses = {}));



/***/ }),

/***/ "./_glue/lib/copy/constants.js":
/*!*************************************!*\
  !*** ./_glue/lib/copy/constants.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Demos: () => (/* binding */ Demos),
/* harmony export */   Message: () => (/* binding */ Message),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Copy component.
 */
/**
 * Classes that identify sub elements or adjust display of sub elements.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-copy';
CssClasses['VALUE'] = 'glue-copy-value';
CssClasses['BUTTON'] = 'glue-copy-button';
CssClasses['IS_COPIED'] = 'glue-is-copied';
CssClasses['POPOVER_ROOT'] = 'glue-popover';
CssClasses['SOCIAL_POPOVER_ROOT'] = 'glue-social__popover';
})(CssClasses || (CssClasses = {}));
/**
 * List of demos used by demo server.
 */
var Demos;
(function(Demos) {
Demos['BASE'] = 'base';
Demos['SOCIAL'] = 'social';
})(Demos || (Demos = {}));
/**
 * Data properties that identify user-provided messages.
 */
var Message;
(function(Message) {
Message['SUCCESS'] = 'glue-copy-success';
Message['FAIL'] = 'glue-copy-fail';
})(Message || (Message = {}));
/**
 * Various strings used throughout the copy component.
 */
var Strings;
(function(Strings) {
/**
 * Error message provided if input element is not found.
 */
Strings['MISSING_INPUT'] = 'Input element is missing';
/**
 * Error message provided if copy button element is not found.
 */
Strings['MISSING_COPY_BUTTON'] = 'Copy button is missing';
/**
 * Default message shown to users after successful copy operation.
 */
Strings['SUCCESS_MESSAGE'] = 'Copied to clipboard';
/**
 * Default message shown to users after failed copy operation.
 */
Strings['FAIL_MESSAGE'] = 'Press Ctrl+C or \u2318+C to copy';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/copy/index.js":
/*!*********************************!*\
  !*** ./_glue/lib/copy/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Copy: () => (/* binding */ Copy)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _popover_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../popover/constants */ "./_glue/lib/popover/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./_glue/lib/copy/constants.js");









/**
 * A class to copy text input content to clipboard.
 */
class Copy extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /** @param root root element for the Copy component. */
  constructor(root) {
    var _a;
    super(root);
    // Message to show if copy command succeeds.
    this.successMsg = _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.SUCCESS_MESSAGE;
    // Message to show if copy command fails.
    this.failMsg = _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.FAIL_MESSAGE;
    // Original label of the copy button.
    this.originalLabel = '';
    const copyValEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.VALUE}`);
    const copyButtonEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON}`);
    this.popoverParentEl =
        (_a = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.POPOVER_ROOT}`)) !== null &&
            _a !== void 0 ?
        _a :
        this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.SOCIAL_POPOVER_ROOT}`);
    if (!copyValEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.MISSING_INPUT);
    }
    if (!copyButtonEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.MISSING_COPY_BUTTON);
    }
    this.copyValueEl = copyValEl;
    this.copyButtonEl = copyButtonEl;
    this.selection = window.getSelection();
    this.clickHandler = (evt) => {
      this.copy();
      evt.preventDefault();
    };
    this.keyDownHandler = (evt) => {
      if (evt.key === _events_key__WEBPACK_IMPORTED_MODULE_2__.Key.ENTER) {
        this.copy();
        evt.preventDefault();
      }
    };
    this.closeHandler = () => {
      this.reset();
    };
    this.init();
  }
  /** Initializes the copy component. */
  init() {
    var _a;
    const success = this.root.getAttribute(_constants__WEBPACK_IMPORTED_MODULE_4__.Message.SUCCESS);
    const fail = this.root.getAttribute(_constants__WEBPACK_IMPORTED_MODULE_4__.Message.FAIL);
    this.successMsg = success ? success : this.successMsg;
    this.failMsg = fail ? fail : this.failMsg;
    this.originalLabel =
        this.copyButtonEl.textContent ? this.copyButtonEl.textContent : '';
    this.copyButtonEl.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.clickHandler);
    this.copyButtonEl.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.KEYDOWN, this.keyDownHandler);
    // Resets the copy button if its parent popover is closed
    (_a = this.popoverParentEl) === null || _a === void 0 ?
        void 0 :
        _a.addEventListener(_popover_constants__WEBPACK_IMPORTED_MODULE_3__.CustomEvent.CLOSE_EVENT, this.closeHandler);
  }
  /**
   * Resets component and removes all event listeners.
   */
  destroy() {
    var _a;
    this.reset();
    this.copyButtonEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.clickHandler);
    this.copyButtonEl.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.KEYDOWN, this.keyDownHandler);
    (_a = this.popoverParentEl) === null || _a === void 0 ?
        void 0 :
        _a.removeEventListener(_popover_constants__WEBPACK_IMPORTED_MODULE_3__.CustomEvent.CLOSE_EVENT, this.closeHandler);
  }
  /** Copies text input string to clipboard. */
  copy() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(this, void 0, void 0, function*() {
      var _a, _b;
      if (this.copyValueEl && this.copyValueEl.select) {
        this.copyValueEl.select();
        const userAgentMatch = navigator.userAgent.match(/ipad|iphone/i);
        if (userAgentMatch) {
          const range = document.createRange();
          range.selectNodeContents(this.copyValueEl);
          (_a = this.selection) === null || _a === void 0 ?
              void 0 :
              _a.removeAllRanges();
          (_b = this.selection) === null || _b === void 0 ? void 0 :
                                                            _b.addRange(range);
          this.copyValueEl.setSelectionRange(0, 999999);
        }
      }
      yield navigator.clipboard.writeText(this.copyValueEl.value)
          .then(
              () => {
                // Shows success message and updates various elements
                this.copyButtonEl.textContent = this.successMsg;
                this.copyButtonEl.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_COPIED);
                this.copyButtonEl.disabled = true;
                this.copyValueEl.blur();
              },
              () => {
                // Render failure message
                this.copyButtonEl.textContent = this.failMsg;
              });
      this.copyValueEl.focus();
    });
  }
  /**
   * Resets input and copy button and re-enables copy button.
   */
  reset() {
    var _a;
    this.copyButtonEl.textContent = this.originalLabel;
    this.copyButtonEl.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_COPIED);
    this.copyButtonEl.disabled = false;
    this.copyValueEl.setSelectionRange(0, 0);
    (_a = this.selection) === null || _a === void 0 ? void 0 :
                                                      _a.removeAllRanges();
  }
}



/***/ }),

/***/ "./_glue/lib/debounce/index.js":
/*!*************************************!*\
  !*** ./_glue/lib/debounce/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Debounce: () => (/* binding */ Debounce)
/* harmony export */ });
/**
 * @fileoverview A simple function to create a debounced function.
 * A debounced function wraps a function, and delay its execution every time
 * the debounced function is called. This is equivalent to goog.async.Debouncer
 * but lighter and a simpler API.
 *
 * @see https://glue-docs.appspot.com/docs/components/raw/debounce
 *
 * Example:
 *
 * // Call a function 250ms after the last scroll event fires.
 * var handleScroll = function() {};
 * window.addEventListener('scroll', new Debounce(handleScroll, 250).debounce);
 *
 */
/**
 * Debounces a function after a given delay.
 */
class Debounce {
  /**
   * @param fn The function to debounce.
   * @param delay The delay in ms until the function should be executed.
   */
  constructor(fn, delay) {
    this.fn = fn;
    this.delay = delay;
  }
  /**
   * Debounces by reinitializing the timer until the function should execute.
   */
  debounce() {
    clearTimeout(this.timeoutId);
    this.timeoutId = window.setTimeout(this.fn, this.delay);
  }
  /**
   * Cancels any ongoing debouncing timer.
   */
  cancel() {
    clearTimeout(this.timeoutId);
  }
}



/***/ }),

/***/ "./_glue/lib/easing/index.js":
/*!***********************************!*\
  !*** ./_glue/lib/easing/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ease: () => (/* binding */ ease),
/* harmony export */   easeInBack: () => (/* binding */ easeInBack),
/* harmony export */   easeInBounce: () => (/* binding */ easeInBounce),
/* harmony export */   easeInCirc: () => (/* binding */ easeInCirc),
/* harmony export */   easeInCubic: () => (/* binding */ easeInCubic),
/* harmony export */   easeInElastic: () => (/* binding */ easeInElastic),
/* harmony export */   easeInExpo: () => (/* binding */ easeInExpo),
/* harmony export */   easeInOutBack: () => (/* binding */ easeInOutBack),
/* harmony export */   easeInOutBounce: () => (/* binding */ easeInOutBounce),
/* harmony export */   easeInOutCirc: () => (/* binding */ easeInOutCirc),
/* harmony export */   easeInOutCubic: () => (/* binding */ easeInOutCubic),
/* harmony export */   easeInOutElastic: () => (/* binding */ easeInOutElastic),
/* harmony export */   easeInOutExpo: () => (/* binding */ easeInOutExpo),
/* harmony export */   easeInOutQuad: () => (/* binding */ easeInOutQuad),
/* harmony export */   easeInOutQuart: () => (/* binding */ easeInOutQuart),
/* harmony export */   easeInOutQuint: () => (/* binding */ easeInOutQuint),
/* harmony export */   easeInOutSine: () => (/* binding */ easeInOutSine),
/* harmony export */   easeInQuad: () => (/* binding */ easeInQuad),
/* harmony export */   easeInQuart: () => (/* binding */ easeInQuart),
/* harmony export */   easeInQuint: () => (/* binding */ easeInQuint),
/* harmony export */   easeInSine: () => (/* binding */ easeInSine),
/* harmony export */   easeOutBack: () => (/* binding */ easeOutBack),
/* harmony export */   easeOutBounce: () => (/* binding */ easeOutBounce),
/* harmony export */   easeOutCirc: () => (/* binding */ easeOutCirc),
/* harmony export */   easeOutCubic: () => (/* binding */ easeOutCubic),
/* harmony export */   easeOutElastic: () => (/* binding */ easeOutElastic),
/* harmony export */   easeOutExpo: () => (/* binding */ easeOutExpo),
/* harmony export */   easeOutQuad: () => (/* binding */ easeOutQuad),
/* harmony export */   easeOutQuart: () => (/* binding */ easeOutQuart),
/* harmony export */   easeOutQuint: () => (/* binding */ easeOutQuint),
/* harmony export */   easeOutSine: () => (/* binding */ easeOutSine),
/* harmony export */   easingFunctions: () => (/* binding */ easingFunctions),
/* harmony export */   linear: () => (/* binding */ linear)
/* harmony export */ });
/**
 * @fileoverview A series of utility functions for use in implementing easing in
 * javascript animations.
 *
 * Closure provides three easing functions (goog.fx.easing.easeIn,
 * goog.fx.easing.easeOut, goog.fx.easing.inAndOut), but as that is a woefully
 * inadequate library for broad animation use, this series of functions adds
 * many more options to be used in a similar way. Easing functions are useful
 * for adding a natural feel to what would otherwise be unrealistic, linear
 * animations.
 *
 * Example usage: Say you have a DOM element that you want to animate by moving
 * it between two arbitrary locations in a page, over 2 seconds. Normally you'd
 * determine its starting position, its ending position, set up an interval,
 * then with each iteration, determine the position you should move it to based
 * on its initial and ending position values and a percentage that represents
 * its progress from start to finish, based on the 2 second duration. Call that
 * percentage T. In order to implement an easing method using glue.fx.easing,
 * simply pass T through your desired easing method, and the returned value is
 * an "eased" value of T. Using that new T, you set the element's position,
 * and the resulting animation will have a smooth ease to it, instead of its
 * original, jarring linear movement. It's hard to understand this without
 * seeing it in action, so visit the example link below for some live animation
 * utilizing all of the easing functions provided in this library.
 *
 * If you are more familiar with jQuery's style of easing methods which expect
 * four arguments (t, b, c, d), you can use glue.fx.easing.ease(), passing in
 * those four arguments and a reference to the easing method you'd like to use.
 * Whether you should use this, or directly call one of the single-argument
 * methods, is up to the developer, and largely depends on circumstance.
 *
 * Note: Frequently, you will have the easing method by name in string form (as
 * when contained in some JSON configuration data), so you can also call it
 * like: glue.fx.easing[methodName](percentage);
 *
 * For examples, see:
 * https://glue-docs.appspot.com/docs/components/raw/fx-easing
 *
 * A namespace for the easing functions. This is being created and exported
 * because we will often have the name of our desired easing method by string
 * only, so we'll need to test to see if glue.fx.easing contains a property
 * (function) with that name, and then call it like so:
 * glue.fx.easing[methodName](percentage);
 */
/**
 * Eases values based on the typical four-argument easing method structure used
 * by popular libraries like jQuery. This is an adapter to interface with the
 * single-argument easing methods in this class.
 * @param t Current time of the animation.
 * @param b Beginning value of the property to be eased.
 * @param c Total change in the property value across this animation.
 * @param d Total duration of the animation.
 * @param func The easing method to call.
 * @return The final eased value.
 */
function ease(t, b, c, d, func) {
  return b + c * func(t / d);
}
/**
 * Eases the value in with a Sine curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInSine(t) {
  return t === 0 || t === 1 ? t : 1 - Math.cos(t * (Math.PI / 2));
}
/**
 * Eases the value out with a Sine curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutSine(t) {
  return t === 0 || t === 1 ? t : Math.sin(t * (Math.PI / 2));
}
/**
 * Eases the value in and out with a Sine curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutSine(t) {
  return t === 0 || t === 1 ? t : -0.5 * (Math.cos(Math.PI * t) - 1);
}
/**
 * Eases the value in with a quadratic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInQuad(t) {
  return t === 0 || t === 1 ? t : t * t;
}
/**
 * Eases the value out with a quadratic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutQuad(t) {
  return t === 0 || t === 1 ? t : t * (2 - t);
}
/**
 * Eases the value in and out with a quadratic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutQuad(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return 2 * t * t;
  } else {
    return -1 + (4 - 2 * t) * t;
  }
}
/**
 * Eases the value in with a cubic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInCubic(t) {
  return t === 0 || t === 1 ? t : t * t * t;
}
/**
 * Eases the value out with a cubic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutCubic(t) {
  return t === 0 || t === 1 ? t : --t * t * t + 1;
}
/**
 * Eases the value in and out with a cubic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutCubic(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return 4 * t * t * t;
  } else {
    return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }
}
/**
 * Eases the value in with a quartic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInQuart(t) {
  return t === 0 || t === 1 ? t : t * t * t * t;
}
/**
 * Eases the value out with a quartic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutQuart(t) {
  return t === 0 || t === 1 ? t : 1 - --t * t * t * t;
}
/**
 * Eases the value in and out with a quartic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutQuart(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return 8 * t * t * t * t;
  } else {
    return 1 - 8 * --t * t * t * t;
  }
}
/**
 * Eases the value in with a quintic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInQuint(t) {
  return t === 0 || t === 1 ? t : t * t * t * t * t;
}
/**
 * Eases the value out with a quintic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutQuint(t) {
  return t === 0 || t === 1 ? t : 1 + --t * t * t * t * t;
}
/**
 * Eases the value in and out with a quintic curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutQuint(t) {
  return t === 0 || t === 1 ? t :
      t < 0.5               ? 16 * t * t * t * t * t :
                              1 + 16 * --t * t * t * t * t;
}
/**
 * Eases the value in with an exponential curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInExpo(t) {
  return t === 0 || t === 1 ? t : Math.pow(2, 10 * (t - 1));
}
/**
 * Eases the value out with an exponential curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutExpo(t) {
  return t === 0 || t === 1 ? t : 1 - Math.pow(2, -10 * t);
}
/**
 * Eases the value in and out with an exponential curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutExpo(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return 0.5 * Math.pow(2, 10 * (t * 2 - 1));
  } else {
    return 0.5 * (2 - Math.pow(2, -10 * (t * 2 - 1)));
  }
}
/**
 * Eases the value in with a circular curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInCirc(t) {
  return t === 0 || t === 1 ? t : 1 - Math.sqrt(1 - t * t);
}
/**
 * Eases the value out with a circular curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutCirc(t) {
  return t === 0 || t === 1 ? t : Math.sqrt(1 - (t - 1) * (t - 1));
}
/**
 * Eases the value in and out with a circular curve.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutCirc(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return -0.5 * (Math.sqrt(1 - t * t * 4) - 1);
  } else {
    return 0.5 * (Math.sqrt(1 - 4 * (t - 1) * (t - 1)) + 1);
  }
}
/**
 * Eases the value in after bounding backwards at the beginning.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInBack(t) {
  return t === 0 || t === 1 ? t : t * t * (2.70158 * t - 1.70158);
}
/**
 * Eases the value out after bounding past the end point and back.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutBack(t) {
  return t === 0 || t === 1 ?
      t :
      (t - 1) * (t - 1) * (2.70158 * (t - 1) + 1.70158) + 1;
}
/**
 * Eases the value in and out with an initial and ending movement beyond the
 * full range.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutBack(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return 0.5 * (t * 2) * (t * 2) * (3.5949095 * (t * 2) - 2.5949095);
  } else {
    return (
        0.5 *
        ((t * 2 - 2) * (t * 2 - 2) * (3.5949095 * (t * 2 - 2) + 2.5949095) +
         2));
  }
}
/**
 * Eases the value in with an elastic springy motion.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInElastic(t) {
  if (t === 0 || t === 1) {
    return t;
  } else {
    return (
        -1 *
        (Math.pow(2, 10 * (t - 1)) *
         Math.sin(((t - 1.075) * (2 * Math.PI)) / 0.3)));
  }
}
/**
 * Eases the value out with an elastic springy motion.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutElastic(t) {
  return t === 0 || t === 1 ?
      t :
      Math.pow(2, -10 * t) * Math.sin(((t - 0.075) * (2 * Math.PI)) / 0.3) + 1;
}
/**
 * Eases the value in and out with an elastic springy motion.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutElastic(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return (
        -0.5 *
        (Math.pow(2, 10 * (t * 2 - 1)) *
         Math.sin(((t * 2 - 1.1125) * 2 * Math.PI) / 0.45)));
  } else {
    return (
        0.5 * Math.pow(2, -10 * (t * 2 - 1)) *
            Math.sin(((t * 2 - 1.1125) * 2 * Math.PI) / 0.45) +
        1);
  }
}
/**
 * Eases the value in with a simple physics bounce.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInBounce(t) {
  return t === 0 || t === 1 ? t : 1 - easeOutBounce(1 - t);
}
/**
 * Eases the value out with a simple physics bounce.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeOutBounce(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 1 / 2.75) {
    return 7.5625 * t * t;
  } else if (t < 2 / 2.75) {
    return 7.5625 * (t - 1.5 / 2.75) * (t - 1.5 / 2.75) + 0.75;
  } else if (t < 2.5 / 2.75) {
    return 7.5625 * (t - 2.25 / 2.75) * (t - 2.25 / 2.75) + 0.9375;
  } else {
    return 7.5625 * (t - 2.625 / 2.75) * (t - 2.625 / 2.75) + 0.984375;
  }
}
/**
 * Eases the value in and out with starting and ending bounces.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function easeInOutBounce(t) {
  if (t === 0 || t === 1) {
    return t;
  } else if (t < 0.5) {
    return easeInBounce(t * 2) * 0.5;
  } else {
    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
  }
}
/**
 * Returns the value without any easing. This is only useful if a script is
 * expecting an easing method, but one isn't needed in that instance.
 * @param t Input between 0 and 1.
 * @return Output between 0 and 1.
 */
function linear(t) {
  return t;
}
/**
 * A Record/Map for easing functions.
 * This is for looking up an easing function by name.
 */
const easingFunctions = {
  'easeInSine': easeInSine,
  'easeOutSine': easeOutSine,
  'easeInOutSine': easeInOutSine,
  'easeInQuad': easeInQuad,
  'easeOutQuad': easeOutQuad,
  'easeInOutQuad': easeInOutQuad,
  'easeInCubic': easeInCubic,
  'easeOutCubic': easeOutCubic,
  'easeInOutCubic': easeInOutCubic,
  'easeInQuart': easeInQuart,
  'easeOutQuart': easeOutQuart,
  'easeInOutQuart': easeInOutQuart,
  'easeInQuint': easeInQuint,
  'easeOutQuint': easeOutQuint,
  'easeInOutQuint': easeInOutQuint,
  'easeInExpo': easeInExpo,
  'easeOutExpo': easeOutExpo,
  'easeInOutExpo': easeInOutExpo,
  'easeInCirc': easeInCirc,
  'easeOutCirc': easeOutCirc,
  'easeInOutCirc': easeInOutCirc,
  'easeInBack': easeInBack,
  'easeOutBack': easeOutBack,
  'easeInOutBack': easeInOutBack,
  'easeInElastic': easeInElastic,
  'easeOutElastic': easeOutElastic,
  'easeInOutElastic': easeInOutElastic,
  'easeInBounce': easeInBounce,
  'easeOutBounce': easeOutBounce,
  'easeInOutBounce': easeInOutBounce,
  'linear': linear,
};


/***/ }),

/***/ "./_glue/lib/events/eventtarget.js":
/*!*****************************************!*\
  !*** ./_glue/lib/events/eventtarget.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventTarget: () => (/* binding */ EventTarget)
/* harmony export */ });
/**
 * @fileoverview A lightweight implementation of the Observable pattern, with
 * a Closure-like API.
 */
class EventTarget {
  constructor() {
    this.listeners = {};
  }
  /**
   * Emits an event.
   * Note: This interface differs from the Closure dispatchEvent method. The
   * parameters are different. See {@code goog.events.Listenable.dispatchEvent}
   * @param eventData Additional event data.
   */
  dispatchEvent(evtType, eventData) {
    const listeners = this.getListenersList(evtType);
    let listener;
    for (let i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      listener(eventData);
    }
  }
  /**
   * Listens to an event, and executes a handler function when it fires.
   */
  listen(evtType, handler) {
    const listeners = this.getListenersList(evtType);
    listeners.push(handler);
  }
  /**
   * Stops listening to an event.
   */
  unlisten(evtType, handler) {
    const listeners = this.getListenersList(evtType);
    for (let i = listeners.length - 1; i >= 0; i--) {
      const h = listeners[i];
      if (h === handler) {
        listeners.splice(i, 1);
      }
    }
  }
  /**
   * Returns the list of listeners for a specific event type.
   */
  getListenersList(evtType) {
    if (!this.listeners[evtType]) {
      this.listeners[evtType] = [];
    }
    return this.listeners[evtType];
  }
  /**
   * Removes all listeners on the host component.
   */
  removeAllListeners() {
    for (const evtType of Object.keys(this.listeners)) {
      if (Object.prototype.hasOwnProperty.call(this.listeners, evtType)) {
        this.listeners[evtType].forEach((handler) => {
          this.unlisten(evtType, handler);
        });
      }
    }
  }
}



/***/ }),

/***/ "./_glue/lib/events/eventtype.js":
/*!***************************************!*\
  !*** ./_glue/lib/events/eventtype.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventType: () => (/* binding */ EventType)
/* harmony export */ });
/**
 * @fileoverview Constants of event types.
 */
var EventType;
(function(EventType) {
// Mouse
EventType['CLICK'] = 'click';
EventType['FOCUS'] = 'focus';
EventType['MOUSEENTER'] = 'mouseenter';
EventType['MOUSEOVER'] = 'mouseover';
EventType['MOUSELEAVE'] = 'mouseleave';
EventType['MOUSEOUT'] = 'mouseout';
EventType['MOUSEWHEEL'] = 'mousewheel';
EventType['HOVER'] = 'hover';
EventType['NONE'] = 'none';
EventType['MOUSEDOWN'] = 'mousedown';
EventType['MOUSEMOVE'] = 'mousemove';
EventType['MOUSEUP'] = 'mouseup';
// Keyboard
EventType['KEYDOWN'] = 'keydown';
EventType['KEYPRESS'] = 'keypress';
EventType['KEYUP'] = 'keyup';
EventType['BLUR'] = 'blur';
EventType['LOAD'] = 'load';
EventType['PAN'] = 'pan';
EventType['PAN_LEFT'] = 'panleft';
EventType['PAN_RIGHT'] = 'panright';
EventType['PAN_END'] = 'panend';
EventType['PAN_START'] = 'panstart';
EventType['PAN_MOVE'] = 'panmove';
EventType['SCROLL'] = 'scroll';
// Element
EventType['CHANGE'] = 'change';
EventType['FOCUS_IN'] = 'focusin';
EventType['FOCUS_OUT'] = 'focusout';
// CSS Event
EventType['TRANSITIONEND'] = 'transitionend';
EventType['TRANSITIONSTART'] = 'transitionstart';
// Viewport
EventType['RESIZE'] = 'resize';
EventType['ORIENTATION_CHANGE'] = 'orientationchange';
EventType['DOM_CONTENT_READY'] = 'DOMContentReady';
EventType['HASHCHANGE'] = 'hashchange';
// Pointer
EventType['POINTERDOWN'] = 'pointerdown';
EventType['POINTERMOVE'] = 'pointermove';
EventType['POINTERUP'] = 'pointerup';
EventType['POINTERCANCEL'] = 'pointercancel';
// Touch
EventType['TOUCHSTART'] = 'touchstart';
EventType['TOUCHMOVE'] = 'touchmove';
EventType['TOUCHEND'] = 'touchend';
EventType['TOUCHCANCEL'] = 'touchcancel';
})(EventType || (EventType = {}));



/***/ }),

/***/ "./_glue/lib/events/key.js":
/*!*********************************!*\
  !*** ./_glue/lib/events/key.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Key: () => (/* binding */ Key),
/* harmony export */   KeyCode: () => (/* binding */ KeyCode)
/* harmony export */ });
/**
 * @fileoverview Constants used when working with key events.
 */
var Key;
(function(Key) {
Key['ENTER'] = 'Enter';
Key['SPACE'] = ' ';
Key['TAB'] = 'Tab';
Key['ESC'] = 'Escape';
// These only trigger with `keydown` not `keypress` on Chrome.
Key['LEFT'] = 'ArrowLeft';
Key['UP'] = 'ArrowUp';
Key['RIGHT'] = 'ArrowRight';
Key['DOWN'] = 'ArrowDown';
Key['HOME'] = 'Home';
Key['END'] = 'End';
Key['PAGEUP'] = 'PageUp';
Key['PAGEDOWN'] = 'PageDown';
})(Key || (Key = {}));
var KeyCode;
(function(KeyCode) {
KeyCode[KeyCode['ENTER'] = 13] = 'ENTER';
KeyCode[KeyCode['SPACE'] = 32] = 'SPACE';
KeyCode[KeyCode['TAB'] = 9] = 'TAB';
KeyCode[KeyCode['ESC'] = 27] = 'ESC';
KeyCode[KeyCode['LEFT'] = 37] = 'LEFT';
KeyCode[KeyCode['UP'] = 38] = 'UP';
KeyCode[KeyCode['RIGHT'] = 39] = 'RIGHT';
KeyCode[KeyCode['DOWN'] = 40] = 'DOWN';
KeyCode[KeyCode['HOME'] = 36] = 'HOME';
KeyCode[KeyCode['END'] = 35] = 'END';
KeyCode[KeyCode['PAGEUP'] = 33] = 'PAGEUP';
KeyCode[KeyCode['PAGEDOWN'] = 34] = 'PAGEDOWN';
})(KeyCode || (KeyCode = {}));



/***/ }),

/***/ "./_glue/lib/expansionpanels/constants.js":
/*!************************************************!*\
  !*** ./_glue/lib/expansionpanels/constants.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   DataAttr: () => (/* binding */ DataAttr),
/* harmony export */   ErrorMessages: () => (/* binding */ ErrorMessages),
/* harmony export */   EventNames: () => (/* binding */ EventNames),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used in expansion panels components.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['GROUP'] = 'glue-expansion-panels';
CssClasses['PANEL'] = 'glue-expansion-panel';
CssClasses['CONTENT'] = 'glue-expansion-panel__content';
CssClasses['TOGGLE'] = 'glue-expansion-panel__toggle';
CssClasses['BUTTON'] = 'glue-expansion-panel__button';
CssClasses['HEADER'] = 'glue-expansion-panels__header';
CssClasses['HEADER_TEXT'] = 'glue-expansion-panel__header-text';
CssClasses['TOGGLE_ALL'] = 'glue-expansion-panels__toggle-all';
CssClasses['TOGGLE_ALL_TEXT'] = 'glue-expansion-panels__toggle-text';
CssClasses['ARROW'] = 'glue-expansion-panel__header-arrow';
CssClasses['IS_EXPANDED'] = 'glue-is-expanded';
CssClasses['IS_COLLAPSED'] = 'glue-is-collapsed';
CssClasses['IS_MIXED'] = 'glue-is-mixed';
})(CssClasses || (CssClasses = {}));
var DataAttr;
(function(DataAttr) {
DataAttr['KEY'] = 'glueExpansionPanelsKey';
DataAttr['SMOOTHANIMTIMING'] = 'glueExpansionPanelsSmoothAnimTiming';
DataAttr['TOGGLEFOR'] = 'glueExpansionPanelToggleFor';
DataAttr['INITIAL'] = 'glueExpansionPanelInitial';
DataAttr['EXPAND_TOOLTIP'] = 'glueExpansionPanelExpandTooltip';
DataAttr['COLLAPSE_TOOLTIP'] = 'glueExpansionPanelCollapseTooltip';
})(DataAttr || (DataAttr = {}));
var Strings;
(function(Strings) {
Strings['DEFAULT_INSTANCE_ID'] = 'expansion_panels';
Strings['EXPANDED'] = 'expanded';
Strings['COLLAPSED'] = 'collapsed';
Strings['MIXED'] = 'mixed';
Strings['TOOLTIP_EXPAND'] = 'Press to expand';
Strings['TOOLTIP_COLLAPSE'] = 'Press to collapse';
})(Strings || (Strings = {}));
var EventNames;
(function(EventNames) {
// dispatched by model whenever there is a change in the group status
EventNames['PANELGROUP_STATUS_CHANGED'] = 'glueExpansionPanelsStatusChanged';
// dispatched by toggle to trigger content component to expand or collapse
EventNames['TOGGLE_CONTENT'] = 'glueExpansionPanelsToggleContent';
// dispatched to trigger all content components to expand
EventNames['EXPAND_ALL_CONTENT'] = 'glueExpansionPanelsExpandAllContent';
// dispatched to trigger all content components to collapse
EventNames['COLLAPSE_ALL_CONTENT'] = 'glueExpansionPanelsCollapseAllContent';
})(EventNames || (EventNames = {}));
var ErrorMessages;
(function(ErrorMessages) {
ErrorMessages['TOGGLE_MISSING_CONTENT_ID'] =
    '[Glue Expansion Panels Toggle] - Toggle is not linked to a content element.';
ErrorMessages['TOGGLE_MISSING_CONTENT_ELEMENT'] =
    '[Glue Expansion Panels Toggle] - Cannot find content element to link toggle to.';
ErrorMessages['MISSING_CONTENT_ID'] =
    '[Glue Expansion Panels Content] - An ID must be set on the content element.';
})(ErrorMessages || (ErrorMessages = {}));



/***/ }),

/***/ "./_glue/lib/expansionpanels/content/index.js":
/*!****************************************************!*\
  !*** ./_glue/lib/expansionpanels/content/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpansionPanelsContent: () => (/* binding */ ExpansionPanelsContent)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _focus___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../focus/ */ "./_glue/lib/focus/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _model_modelfactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../model/modelfactory */ "./_glue/lib/expansionpanels/model/modelfactory.js");






/**
 * Class for creating expansion panels content.
 */
class ExpansionPanelsContent extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The HTML element containing the individual panel's content.
   */
  constructor(root) {
    var _a, _b, _c;
    super(root);
    /**
     * An array to hold the tabindex value of focusable child elements of panel
     * content, so it can be adjusted when the panel content is expanded or
     * collapsed.
     */
    this.tabIndexArr = [];
    this.isCollapsed = true;
    /**
     * Keeps track of the panel height (unitless, but ultimately in pixels).
     */
    this.panelHeight = 0;
    this.groupEl = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.GROUP}`);
    this.panelEl = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.PANEL}`);
    this.toggleButton =
        (_b = (_a = this.panelEl) === null || _a === void 0 ?
             void 0 :
             _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BUTTON}`)) !== null &&
            _b !== void 0 ?
        _b :
        null;
    this.toggleContentHandler = (target) => {
      this.toggleContent(target);
    };
    this.expandHandler = () => {
      this.expand();
    };
    this.collapseHandler = () => {
      this.collapse();
    };
    this.transitionendHandler = () => {
      this.unsetPanelHeight();
    };
    const modelKey =
        (_c = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.GROUP}`)) === null ||
            _c === void 0 ?
        void 0 :
        _c.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.KEY];
    this.model = _model_modelfactory__WEBPACK_IMPORTED_MODULE_5__.ModelFactory.get(modelKey);
    if (!this.root.id) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessages.MISSING_CONTENT_ID);
    }
    this.init();
  }
  init() {
    // Store initial tabIndex value for all focusable elements in panel content.
    this.tabIndexArr = this.getTabIndexArray();
    // Toggle the panel's initial state
    if (this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.INITIAL] === 'expanded') {
      this.isCollapsed = false;
      this.updateHtmlAttributes(false);
      this.setPanelHeight('');
      this.updateStatus(false);
    } else {
      this.isCollapsed = true;
      this.updateHtmlAttributes(true);
      this.setPanelHeight('0px');
    }
    // start listening for events
    this.model.listen(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.TOGGLE_CONTENT, this.toggleContentHandler);
    this.model.listen(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.EXPAND_ALL_CONTENT, this.expandHandler);
    this.model.listen(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.COLLAPSE_ALL_CONTENT, this.collapseHandler);
    if (this.model.isAnimated === true) {
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.transitionendHandler);
    }
    // set aria properties
    this.addA11yFeatures();
  }
  destroy() {
    var _a;
    // remove styles and attributes
    (_a = this.panelEl) === null || _a === void 0 ?
        void 0 :
        _a.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_COLLAPSED, _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_EXPANDED);
    this.setPanelHeight('');
    // reset accessibility properties from expanded/collapsed state
    this.removeAriaAttributes();
    this.setFocusableElements(false, this.tabIndexArr);
    // clear tabindex values
    this.tabIndexArr = [];
    // stop listening for events
    this.model.unlisten(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.TOGGLE_CONTENT, this.toggleContentHandler);
    this.model.unlisten(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.EXPAND_ALL_CONTENT, this.expandHandler);
    this.model.unlisten(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.COLLAPSE_ALL_CONTENT, this.collapseHandler);
    if (this.model.isAnimated === true) {
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.transitionendHandler);
    }
    // reset aria properties
    this.removeA11yFeatures();
  }
  /**
   * Expands (shows) the content, both visually and to screen readers
   */
  expand() {
    if (this.isCollapsed === false) {
      return;
    }
    this.updateHtmlAttributes(false);
    this.updateHeight(false);
    this.updateStatus(false);
  }
  /**
   * Collapses (hides) the content, both visually and to screen readers
   */
  collapse() {
    if (this.isCollapsed === true) {
      return;
    }
    this.updateHtmlAttributes(true);
    this.updateHeight(true);
    this.updateStatus(true);
  }
  /**
   * When toggle event is fired, expands or collapses the content element.
   * @param target The ID of the panel that should be toggled.
   */
  toggleContent(target) {
    if (target === this.root.id) {
      this.isCollapsed ? this.expand() : this.collapse();
    }
  }
  /**
   * Updates content element's ARIA attributes and adds/removes classes based
   * on context (Expanded / Collapsed).
   * @param flag The flag to check if the state is
   * expanded or collapsed.
   */
  updateHtmlAttributes(flag) {
    var _a, _b;
    this.setAriaAttributes(flag);
    this.setFocusableElements(flag, this.tabIndexArr);
    const addClass = flag ? _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_COLLAPSED : _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_EXPANDED;
    const removeClass = flag ? _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_EXPANDED : _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.IS_COLLAPSED;
    (_a = this.panelEl) === null || _a === void 0 ? void 0 :
                                                    _a.classList.add(addClass);
    (_b = this.panelEl) === null || _b === void 0 ?
        void 0 :
        _b.classList.remove(removeClass);
  }
  /**
   * Updates height of content element based on context (Expanded / Collapsed).
   * @param flag The flag to check if the state is
   * expanded or collapsed.
   */
  updateHeight(flag) {
    this.panelHeight = this.root.scrollHeight;
    if (this.model.isAnimated === true) {
      this.setPanelHeight(`${this.panelHeight}px`);
      // Applicable when the panels are to be collapsed.
      if (flag) {
        // Force a redraw of the layout by calling scrollHeight again,
        // then set the height to 0 after a brief delay (1ms)
        // This is so broswers will reliably transition the height change
        this.panelHeight = this.root.scrollHeight;
        window.setTimeout(this.setPanelHeight.bind(this), 1, '0px');
      }
    } else {
      // If no animation is set, immediately set the height to
      // 0 or unset depending on the context.
      this.setPanelHeight(flag ? '0px' : '');
    }
  }
  /**
   * Updates status of content element based on context (Expanded / Collapsed).
   * @param flag The flag to check if the state is
   * expanded or collapsed.
   */
  updateStatus(flag) {
    flag ? this.model.panelsCollapsed++ : this.model.panelsCollapsed--;
    this.model.updatePanelsStatus();
    this.isCollapsed = flag;
  }
  /**
   * Get tabindex array.
   */
  getTabIndexArray() {
    const focusableEls = _focus___WEBPACK_IMPORTED_MODULE_3__.getFocusableElements(this.root);
    const tabIndexArray = focusableEls.map((el) => el.tabIndex);
    return tabIndexArray;
  }
  /**
   * Set content height.
   */
  setPanelHeight(height) {
    this.root.style.height = height;
  }
  /**
   * Unset content height.
   */
  unsetPanelHeight() {
    if (this.root.style.height !== '0px') {
      this.root.style.height = '';
    }
  }
  /**
   * Get localised tooltip text from the template file
   * @param isPanelExpanded The flag to check if the panel is expanded or not
   */
  getTooltipText(isPanelExpanded = false) {
    var _a, _b, _c, _d;
    const tooltipText = isPanelExpanded ?
        (_b = (_a = this.groupEl) === null || _a === void 0 ?
             void 0 :
             _a.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.EXPAND_TOOLTIP]) !== null &&
                _b !== void 0 ?
        _b :
        _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.TOOLTIP_EXPAND :
        (_d = (_c = this.groupEl) === null || _c === void 0 ?
             void 0 :
             _c.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.COLLAPSE_TOOLTIP]) !== null &&
            _d !== void 0 ?
        _d :
        _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.TOOLTIP_COLLAPSE;
    return tooltipText;
  }
  /**
   * Set aria attributes.
   */
  setAriaAttributes(isPanelCollapsed) {
    this.root.hidden = isPanelCollapsed;
    if (this.toggleButton) {
      this.toggleButton.title = this.getTooltipText(isPanelCollapsed);
      this.toggleButton.setAttribute(
          _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, String(!isPanelCollapsed));
    }
    if (isPanelCollapsed) {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, String(isPanelCollapsed));
    } else {
      this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
    }
  }
  /**
   * Remove aria attributes.
   */
  removeAriaAttributes() {
    var _a, _b;
    (_a = this.toggleButton) === null || _a === void 0 ?
        void 0 :
        _a.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED);
    (_b = this.toggleButton) === null || _b === void 0 ?
        void 0 :
        _b.removeAttribute('title');
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
    this.root.hidden = false;
  }
  /**
   * Set focusable elements.
   */
  setFocusableElements(isPanelCollapsed, tabIndexArr) {
    const focusableEls = _focus___WEBPACK_IMPORTED_MODULE_3__.getFocusableElements(this.root);
    if (isPanelCollapsed) {
      for (const el of focusableEls) {
        el.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      }
    } else {
      for (let i = 0; i < focusableEls.length; i++) {
        const el = focusableEls[i];
        el.tabIndex = tabIndexArr[i];
      }
    }
  }
  /**
   * Add a11y features.
   */
  addA11yFeatures() {
    var _a, _b;
    this.root.setAttribute(
        _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY,
        (_b = (_a = this.toggleButton) === null || _a === void 0 ?
             void 0 :
             _a.id) !== null &&
                _b !== void 0 ?
            _b :
            '');
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.REGION);
  }
  /**
   * Remove a11y features.
   */
  removeA11yFeatures() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
  }
}



/***/ }),

/***/ "./_glue/lib/expansionpanels/index.js":
/*!********************************************!*\
  !*** ./_glue/lib/expansionpanels/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpansionPanels: () => (/* binding */ ExpansionPanels)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./content */ "./_glue/lib/expansionpanels/content/index.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ "./_glue/lib/expansionpanels/model/index.js");
/* harmony import */ var _model_modelfactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/modelfactory */ "./_glue/lib/expansionpanels/model/modelfactory.js");
/* harmony import */ var _toggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toggle */ "./_glue/lib/expansionpanels/toggle/index.js");
/* harmony import */ var _toggleall__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./toggleall */ "./_glue/lib/expansionpanels/toggleall/index.js");









/**
 * Class for creating expansion panels panel group.
 */
class ExpansionPanels extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The HTML element containing the panel group.
   * @param options Expansion Panels options object.
   */
  constructor(root, options) {
    super(root);
    this.toggleAllComponents = [];
    this.panelContentComponents = [];
    this.panelToggleComponents = [];
    this.options = Object.assign({}, _model__WEBPACK_IMPORTED_MODULE_3__.ExpansionPanelsModel.defaults, options);
    this.statusChangeHandler = () => {
      this.updateStatus();
    };
    this.modelKey =
        this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_1__.DataAttr.KEY] || _constants__WEBPACK_IMPORTED_MODULE_1__.Strings.DEFAULT_INSTANCE_ID;
    this.model = _model_modelfactory__WEBPACK_IMPORTED_MODULE_4__.ModelFactory.get(this.modelKey, this.options);
    this.init();
  }
  /**
   * Initialize the component.
   */
  init() {
    this.model.panelsCount =
        this.root.getElementsByClassName(_constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.PANEL).length;
    this.model.panelsCollapsed = this.model.panelsCount;
    // Initialize child components. Track them so component can be fully
    // destroyed
    for (const toggleAllEl of this.root.querySelectorAll(
             `.${_constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.TOGGLE_ALL}`)) {
      this.toggleAllComponents.push(new _toggleall__WEBPACK_IMPORTED_MODULE_6__.ExpansionPanelsToggleAll(toggleAllEl));
    }
    for (const panelContentEl of this.root.querySelectorAll(
             `.${_constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.CONTENT}`)) {
      this.panelContentComponents.push(
          new _content__WEBPACK_IMPORTED_MODULE_2__.ExpansionPanelsContent(panelContentEl));
    }
    for (const panelToggleEl of this.root.querySelectorAll(
             `.${_constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.BUTTON}`)) {
      this.panelToggleComponents.push(new _toggle__WEBPACK_IMPORTED_MODULE_5__.ExpansionPanelsToggle(panelToggleEl));
    }
    // listen for status change events
    this.model.listen(
        _constants__WEBPACK_IMPORTED_MODULE_1__.EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);
    // Set panel group's initial status
    this.model.updatePanelsStatus();
  }
  destroy() {
    // Destroy child components
    let subcomponent;
    while (this.toggleAllComponents.length > 0) {
      subcomponent = this.toggleAllComponents.pop();
      subcomponent.destroy();
    }
    while (this.panelContentComponents.length > 0) {
      subcomponent = this.panelContentComponents.pop();
      subcomponent.destroy();
    }
    while (this.panelToggleComponents.length > 0) {
      subcomponent = this.panelToggleComponents.pop();
      subcomponent.destroy();
    }
    // reset panel group class
    this.model.panelsCount = 0;
    this.model.updatePanelsStatus();
    // remove listener for update events
    this.model.unlisten(
        _constants__WEBPACK_IMPORTED_MODULE_1__.EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);
    // remove instance from models list
    _model_modelfactory__WEBPACK_IMPORTED_MODULE_4__.ModelFactory.clearSingle(this.modelKey);
  }
  /**
   * Update the class on panel group root indicating current status
   */
  updateStatus() {
    this.root.classList.remove(
        _constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.IS_COLLAPSED, _constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.IS_MIXED, _constants__WEBPACK_IMPORTED_MODULE_1__.CssClasses.IS_EXPANDED);
    if (this.model.panelsStatus) {
      this.root.classList.add(`glue-is-${this.model.panelsStatus}`);
    }
  }
}



/***/ }),

/***/ "./_glue/lib/expansionpanels/model/index.js":
/*!**************************************************!*\
  !*** ./_glue/lib/expansionpanels/model/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpansionPanelsModel: () => (/* binding */ ExpansionPanelsModel)
/* harmony export */ });
/* harmony import */ var _events_eventtarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../events/eventtarget */ "./_glue/lib/events/eventtarget.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./_glue/lib/expansionpanels/constants.js");


/**
 * The data model used for an Expansion Panel group (a collection of one or
 * more expansion panels).
 * @unrestricted
 */
class ExpansionPanelsModel {
  /**
   * @param options Expansion Panels options object.
   */
  constructor(options) {
    const mergedOptions =
        Object.assign({}, ExpansionPanelsModel.defaults, options);
    /**
     * Whether the panels are animated on activation or not.
     */
    this.isAnimated = mergedOptions.isAnimated;
    /**
     * Total number of panels in this group.
     */
    this.panelsCount = mergedOptions.panelsCount;
    /**
     * Number of panels currently collapsed in this group. Updated whenever a
     * panel is expanded or collapsed.
     * Initially same as total panel count (all panels collapsed).
     */
    this.panelsCollapsed = this.panelsCount;
    /**
     * Current status of the panels group: collapsed, expanded, or mixed.
     * Updated whenever a panel is expanded or collapsed.
     * Initially collapsed.
     */
    this.panelsStatus = _constants__WEBPACK_IMPORTED_MODULE_1__.Strings.COLLAPSED;
    /**
     * Use EventTarget module to delegate event handling between various
     * subcomponents.
     */
    this.eventTarget = new _events_eventtarget__WEBPACK_IMPORTED_MODULE_0__.EventTarget();
  }
  /**
   * Default model options.
   */
  static get defaults() {
    return {
      isAnimated: true,
      panelsCount: 1,
    };
  }
  /**
   * Updates the panel group's status based on collapsed/expanded panel count.
   */
  updatePanelsStatus() {
    if (this.panelsCount === 0) {
      this.panelsStatus = '';
    } else if (this.panelsCount === this.panelsCollapsed) {
      this.panelsStatus = _constants__WEBPACK_IMPORTED_MODULE_1__.Strings.COLLAPSED;
    } else if (this.panelsCollapsed === 0) {
      this.panelsStatus = _constants__WEBPACK_IMPORTED_MODULE_1__.Strings.EXPANDED;
    } else {
      this.panelsStatus = _constants__WEBPACK_IMPORTED_MODULE_1__.Strings.MIXED;
    }
    // Fire event so panel group knows to update its CSS class tracking status
    this.dispatchEvent(_constants__WEBPACK_IMPORTED_MODULE_1__.EventNames.PANELGROUP_STATUS_CHANGED);
  }
  /**
   * Sets up a listener on the model's eventTarget
   */
  listen(eventName, handler) {
    this.eventTarget.listen(eventName, handler);
  }
  /**
   * Removes a listener from the model's eventTarget
   */
  unlisten(eventName, handler) {
    this.eventTarget.unlisten(eventName, handler);
  }
  /**
   * Fires an event on the model's eventTarget. Can include additional data so
   * only specific components will respond to the event.
   * @param eventData Optional additional event data.
   */
  dispatchEvent(eventName, eventData) {
    this.eventTarget.dispatchEvent(eventName, eventData);
  }
}



/***/ }),

/***/ "./_glue/lib/expansionpanels/model/modelfactory.js":
/*!*********************************************************!*\
  !*** ./_glue/lib/expansionpanels/model/modelfactory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelFactory: () => (/* binding */ ModelFactory)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./_glue/lib/expansionpanels/model/index.js");
/**
 * tslint:disable class-as-namespace
 */




/**
 * Expansion Panels model factory.
 */
class ModelFactory {
  /**
   * Returns a new or existing expansion panels model instance based on an
   * identifier.
   * Falls back on a default instance if no id is provided.
   */
  static get(
      id = _constants__WEBPACK_IMPORTED_MODULE_0__.Strings.DEFAULT_INSTANCE_ID,
      options = _index__WEBPACK_IMPORTED_MODULE_1__.ExpansionPanelsModel.defaults) {
    let instance = ModelFactory.instances[id];
    if (!instance) {
      instance = new _index__WEBPACK_IMPORTED_MODULE_1__.ExpansionPanelsModel(options);
      ModelFactory.instances[id] = instance;
    }
    return instance;
  }
  /**
   * Clears a single expansion panels model instance.
   */
  static clearSingle(id) {
    delete ModelFactory.instances[id];
  }
  /**
   * Clears all existing expansion panels model instances.
   */
  static clearAll() {
    ModelFactory.instances = {};
  }
}
/**
 * Internal list of all registered expansion panels model instances.
 */
ModelFactory.instances = {};



/***/ }),

/***/ "./_glue/lib/expansionpanels/toggle/index.js":
/*!***************************************************!*\
  !*** ./_glue/lib/expansionpanels/toggle/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpansionPanelsToggle: () => (/* binding */ ExpansionPanelsToggle)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _model_modelfactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../model/modelfactory */ "./_glue/lib/expansionpanels/model/modelfactory.js");






/**
 * Class for creating expansion panels toggle.
 */
class ExpansionPanelsToggle extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The HTML element containing the individual panel's toggle.
   */
  constructor(root) {
    var _a;
    super(root);
    this.clickHandler = (e) => {
      e.preventDefault();
      this.toggle();
    };
    this.keydownHandler = (e) => {
      this.handleKeydown(e);
    };
    const modelKey =
        (_a = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.GROUP}`)) === null ||
            _a === void 0 ?
        void 0 :
        _a.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.KEY];
    this.model = _model_modelfactory__WEBPACK_IMPORTED_MODULE_5__.ModelFactory.get(modelKey);
    const contentId = this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.TOGGLEFOR];
    // stop setup if toggle cannot be linked to content
    if (!contentId) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessages.TOGGLE_MISSING_CONTENT_ID);
    } else {
      this.contentId = contentId;
    }
    this.init();
  }
  /**
   * Initialize the component.
   */
  init() {
    // stop initialization if content element is not found
    const panelEl = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.PANEL}`);
    const contentEl = panelEl === null || panelEl === void 0 ?
        void 0 :
        panelEl.querySelector('#' + this.contentId);
    if (!contentEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_4__.ErrorMessages.TOGGLE_MISSING_CONTENT_ELEMENT);
    }
    // set up accessibility features
    this.addA11yFeatures();
    // set up handlers
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.clickHandler);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.keydownHandler);
  }
  destroy() {
    // remove accessibility features
    this.removeA11yFeatures();
    // remove handlers
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.clickHandler);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.keydownHandler);
  }
  /**
   * Toggles a panel open or closed depending on its current state.
   * Dispatches an event so the panel content targeted will expand/collapse.
   */
  toggle() {
    this.model.dispatchEvent(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.TOGGLE_CONTENT, this.contentId);
  }
  /**
   * Triggers a toggle on the ENTER or SPACE keyboard event.
   */
  handleKeydown(event) {
    if (event.key === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER || event.key === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE) {
      event.preventDefault();
      this.toggle();
    }
  }
  /**
   * Add a11y features.
   */
  addA11yFeatures() {
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.contentId);
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.BUTTON);
    this.root.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE;
  }
  /**
   * Remove a11y features.
   */
  removeA11yFeatures() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
  }
}



/***/ }),

/***/ "./_glue/lib/expansionpanels/toggleall/index.js":
/*!******************************************************!*\
  !*** ./_glue/lib/expansionpanels/toggleall/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpansionPanelsToggleAll: () => (/* binding */ ExpansionPanelsToggleAll)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _model_modelfactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../model/modelfactory */ "./_glue/lib/expansionpanels/model/modelfactory.js");






/**
 * Class for creating expansion panel toggle all.
 */
class ExpansionPanelsToggleAll extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The HTML element containing the panel group's toggle all.
   */
  constructor(root) {
    var _a;
    super(root);
    this.statusChangeHandler = () => {
      this.updateToggleAllStatus();
    };
    this.clickHandler = (e) => {
      e.preventDefault();
      this.toggleAll();
    };
    this.keydownHandler = (e) => {
      this.handleKeydown(e);
    };
    this.keyupHandler = (e) => {
      this.handleKeyup(e);
    };
    this.model = _model_modelfactory__WEBPACK_IMPORTED_MODULE_5__.ModelFactory.get(
        (_a = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.GROUP}`)) === null ||
                _a === void 0 ?
            void 0 :
            _a.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.KEY]);
    this.init();
  }
  /**
   * Initialize component.
   */
  init() {
    // set up accessibility features
    this.addA11yFeatures();
    // set up handlers
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.clickHandler);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.keydownHandler);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYUP, this.keyupHandler);
    // listen for status change events
    this.model.listen(
        _constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);
  }
  destroy() {
    // remove accessibility features
    this.removeA11yFeatures();
    // remove handlers
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.clickHandler);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.keydownHandler);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYUP, this.keyupHandler);
    // remove listener for update events
    this.model.unlisten(
        _constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);
  }
  /**
   * Toggles all the panels in the group to either expand or collapsed based
   * on the panel group's status
   */
  toggleAll() {
    if (this.model.panelsStatus === _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.EXPANDED) {
      // if all panels are expanded, collapse all panels
      this.model.dispatchEvent(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.COLLAPSE_ALL_CONTENT);
    } else {
      // if at least one panel is collapsed, expand all panels
      this.model.dispatchEvent(_constants__WEBPACK_IMPORTED_MODULE_4__.EventNames.EXPAND_ALL_CONTENT);
    }
    // Update group status
    this.model.updatePanelsStatus();
  }
  /**
   * Triggers a toggleAll on the ENTER or SPACE keyboard event.
   */
  handleKeydown(event) {
    if (event.key === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER || event.key === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE) {
      event.preventDefault();
      this.toggleAll();
    }
  }
  /**
   * Prevents Firefox from firing a click event on spacebar keyup event
   * Fixes http://b/194148554
   */
  handleKeyup(event) {
    if (event.key === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE) {
      event.preventDefault();
    }
  }
  /**
   * Add a11y features.
   */
  addA11yFeatures() {
    this.root.setAttribute(
        _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED,
        this.model.panelsStatus === _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.EXPANDED ? 'true' : 'false');
    const toggleText = Array.from(
        this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.TOGGLE_ALL_TEXT}`));
    for (const text of toggleText) {
      text.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
    }
  }
  /**
   * Remove a11y features.
   */
  removeA11yFeatures() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED);
    const toggleText = Array.from(
        this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.TOGGLE_ALL_TEXT}`));
    for (const text of toggleText) {
      text.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
    }
  }
  /**
   * Update the aria-expanded attribute on toggle button
   */
  updateToggleAllStatus() {
    if (this.model.panelsStatus === _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.EXPANDED) {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'true');
    } else {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'false');
    }
  }
}



/***/ }),

/***/ "./_glue/lib/filter/category/index.js":
/*!********************************************!*\
  !*** ./_glue/lib/filter/category/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterCategory: () => (/* binding */ FilterCategory)
/* harmony export */ });
/* harmony import */ var _material_web_checkbox_checkbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material/web/checkbox/checkbox */ "./node_modules/@material/web/checkbox/checkbox.js");
/* harmony import */ var _material_web_radio_radio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material/web/radio/radio */ "./node_modules/@material/web/radio/radio.js");
/* harmony import */ var _material_web_select_filled_select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material/web/select/filled-select */ "./node_modules/@material/web/select/filled-select.js");
/* harmony import */ var _material_web_select_outlined_select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material/web/select/outlined-select */ "./node_modules/@material/web/select/outlined-select.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../observer */ "./_glue/lib/observer/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants */ "./_glue/lib/filter/constants.js");
/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../state_manager */ "./_glue/lib/filter/state_manager/index.js");
// taze: material_dts from //marketing/glue/cdn:material_dts











/**
 * A filter category class to manage an individual Glue filter.
 */
class FilterCategory extends _base__WEBPACK_IMPORTED_MODULE_4__.Component {
  /**
   * Creates an instance of GlueFilterCategory.
   */
  constructor(root) {
    super(root);
    this.chips = {};
    this.stateManager = new _state_manager__WEBPACK_IMPORTED_MODULE_8__.FilterStateManager();
    this.handleSelectChangeFunc = (evt) => {
      this.handleSelectChange(evt);
    };
    this.handleMaterialSelectChangeFunc = (evt) => {
      this.handleMaterialSelectChange(evt);
    };
    this.handleMWC3SelectChangeFunc = (evt) => {
      this.handleMWC3SelectChange(evt);
    };
    this.handleInputChangeFunc = (evt) => {
      this.handleInputChange(evt);
    };
    this.selectEl = this.root.querySelector('select');
    this.nativeCategoryItems = [
      ...this.root.querySelectorAll(`input.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CATEGORY_ITEM}`),
    ];
    this.materialCategoryItems = [
      ...this.root.querySelectorAll(
          `li.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CATEGORY_ITEM}:not(.${_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.LIST_ITEM})`),
    ];
    this.materialSelectEl =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.SELECT}`);
    this.mwc3SelectEl =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.MWC3_SELECT} :first-child`);
    this.category = this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.CATEGORY];
    // Grab the category counter, if provided
    this.categoryCountEl = document.querySelector(
        `#${_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.CATEGORY_COUNT_ID}-${this.category}`);
    this.init();
  }
  init() {
    var _a;
    // Throws an error if filter category is not set.
    if (!this.category) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_CATEGORY);
    }
    this.model = (_a = this.stateManager.getModel(this.category)) !== null &&
            _a !== void 0 ?
        _a :
        new _observer__WEBPACK_IMPORTED_MODULE_6__.Observer({});
    // Initializes select element.
    if (this.selectEl) {
      this.initSelect(this.selectEl);
    }
    // Initializes native HTML input checkbox or radio elements.
    if (this.nativeCategoryItems.length !== 0) {
      this.initNativeInputs(this.nativeCategoryItems);
    }
    // Initializes Material 2 or 3 input checkbox or radio elements.
    if (this.materialCategoryItems.length !== 0) {
      this.initMaterialInputs(this.materialCategoryItems);
    }
    // Initializes Material 2 select element.
    if (this.materialSelectEl) {
      this.initMaterialSelect(this.materialSelectEl);
    }
    // Initializes Material 3 select element.
    if (this.mwc3SelectEl) {
      this.initMWC3Select(this.mwc3SelectEl);
    }
    // Add the data model to stateManager.
    this.stateManager.setModel(this.category, this.model);
    // Sets initial category count
    this.renderCategoryCounter();
  }
  /**
   * Removes event listeners on filter elementss.
   */
  destroy() {
    this.selectEl &&
        this.root.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleSelectChangeFunc);
    this.materialSelectEl &&
        this.root.removeEventListener(
            _constants__WEBPACK_IMPORTED_MODULE_7__.Strings.MATERIALSELECT_CHANGE, this.handleMaterialSelectChangeFunc);
    this.mwc3SelectEl &&
        this.root.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleMWC3SelectChangeFunc);
    this.nativeCategoryItems &&
        this.root.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleInputChangeFunc);
    this.materialCategoryItems &&
        this.root.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleInputChangeFunc);
  }
  /**
   * Resets the data model.
   */
  reset() {
    for (const key of Object.keys(this.model.data)) {
      this.model.data[key] = false;
    }
    // Updates Material 2 Select rendering manually
    if (this.materialSelect) {
      this.materialSelect.selectedIndex = 0;
    }
    // Reset Material 3 Select rendering manually
    if (this.mwc3SelectEl) {
      this.mwc3SelectEl.value = '';
    }
    // Reset category counter rendering
    this.renderCategoryCounter();
  }
  /** Initializes the select element. */
  initSelect(selectEl) {
    // Iterates all select options except the first default option.
    const filterItems = [
      ...selectEl.querySelectorAll(`option.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CATEGORY_ITEM}`),
    ];
    const filterElements = filterItems.slice(1);
    for (const el of filterElements) {
      if (el.value) {
        const filterOption = el.value;
        const isSelected = selectEl.value === filterOption;
        // Updates data model and subscribes to the data change.
        this.setModelProperty(filterOption, isSelected);
        this.model.listen(filterOption, () => {
          el.selected = this.model.data[filterOption];
        });
        // Updates chip data.
        this.chips[filterOption] = el.innerText;
      } else {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_VALUE);
      }
    }
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleSelectChangeFunc);
  }
  /**
   * Initializes the Material Select element.
   */
  initMaterialSelect(materialSelectEl) {
    var _a;
    this.materialSelect = new mdc.select.MDCSelect(materialSelectEl);
    const initialValue =
        ((_a = this.materialSelect) === null || _a === void 0 ? void 0 :
                                                                _a.value) ||
        '';
    // Iterates all select options except the first default option.
    const filterItems = [
      ...materialSelectEl.querySelectorAll(`li.${_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.LIST_ITEM}`),
    ];
    const filterElements = filterItems.slice(1);
    for (const el of filterElements) {
      const filterOption = el.dataset[_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.DATA_VALUE];
      const filterLabelEl =
          el.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.SELECT_LABEL}`);
      if (filterOption && filterLabelEl) {
        const isSelected = initialValue === filterOption;
        // Updates data model.
        this.setModelProperty(filterOption, isSelected);
        // Updates chips data.
        this.chips[filterOption] = filterLabelEl.innerText;
      }
    }
    this.root.addEventListener(
        _constants__WEBPACK_IMPORTED_MODULE_7__.Strings.MATERIALSELECT_CHANGE, this.handleMaterialSelectChangeFunc);
  }
  /**
   * Initializes the MWC3 Select element.
   */
  initMWC3Select(mwc3SelectEl) {
    // Iterates all select options
    const filterElements = [
      ...mwc3SelectEl.querySelectorAll(`md-select-option`),
    ];
    for (const el of filterElements) {
      if (el.value) {
        // Updates data model.
        this.setModelProperty(el.value, el.selected);
        // Updates chips data. Use display text if provided or text content
        this.chips[el.value] =
            el.displayText ? el.displayText : el.innerText.trim();
      }
    }
    this.root.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleMWC3SelectChangeFunc);
  }
  /**
   * Initializes native HTML input checkbox or radio elements.
   */
  initNativeInputs(nativeCategoryItems) {
    var _a, _b;
    // Iterates all checkbox or radio elements to update data object, and
    // throws an error if attribute 'value' is not set on the element.
    for (const el of nativeCategoryItems) {
      const filterOption = el.value;
      if (filterOption) {
        const isSelected = el.checked;
        // Updates data model and subscribes to the data change.
        this.setModelProperty(filterOption, isSelected);
        this.model.listen(filterOption, () => {
          el.checked = this.model.data[filterOption];
        });
        // Updates chip data.
        this.chips[filterOption] =
            ((_b = (_a = el.parentNode) === null || _a === void 0 ?
                  void 0 :
                  _a.querySelector('label')) === null ||
                     _b === void 0 ?
                 void 0 :
                 _b.innerText) ||
            '';
      } else {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_VALUE);
      }
    }
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleInputChangeFunc);
  }
  /**
   * Initializes Material input checkbox or radio elements.
   */
  initMaterialInputs(materialCategoryItems) {
    // Iterates all checkbox or radio elements to update data object, and
    // throws an error if attribute 'value' is not set on the element.
    for (const el of materialCategoryItems) {
      // Initialize Material elements
      const materialFormFieldEl =
          el.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.FORM_FIELD}`);
      if (materialFormFieldEl) {
        // Initialize Material 2 components
        // TODO: b/323929145 - Remove this as part of Material 2 removal.
        const materialFormField =
            new mdc.formField.MDCFormField(materialFormFieldEl);
        const materialInput = materialFormFieldEl.children[0];
        if (materialInput.classList.contains('mdc-checkbox')) {
          const materialCheckbox = new mdc.checkbox.MDCCheckbox(materialInput);
          materialFormField.input = materialCheckbox;
        } else if (materialInput.classList.contains('mdc-radio')) {
          const materialRadio = new mdc.radio.MDCRadio(materialInput);
          materialFormField.input = materialRadio;
        } else {
          throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_MATERIAL);
        }
        // Set up filter
        const inputEl = el.querySelector('input');
        const labelEl = el.querySelector('label');
        if (inputEl) {
          const filterOption = inputEl.value;
          const isSelected = inputEl.checked;
          if (filterOption) {
            // Updates data model and subscribes to the data change.
            this.setModelProperty(filterOption, isSelected);
            this.model.listen(filterOption, () => {
              inputEl.checked = this.model.data[filterOption];
            });
            // Updates chip data.
            this.chips[filterOption] =
                (labelEl === null || labelEl === void 0 ? void 0 :
                                                          labelEl.innerText) ||
                '';
          } else {
            throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_VALUE);
          }
        }
      } else {
        // Set up Material 3 inputs
        const labelEl = el.querySelector('label');
        const checkboxEl = el.querySelector('md-checkbox');
        const radioEl = el.querySelector('md-radio');
        let chipText = '';
        if (labelEl && labelEl.textContent) {
          chipText = labelEl.textContent.trim();
        }
        if (checkboxEl) {
          const filterOption = checkboxEl.value;
          const isSelected = checkboxEl.checked;
          if (filterOption) {
            // Updates data model and subscribes to the data change.
            this.setModelProperty(filterOption, isSelected);
            this.model.listen(filterOption, () => {
              checkboxEl.checked = this.model.data[filterOption];
            });
            // Updates chip data.
            this.chips[filterOption] = chipText;
          } else {
            throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_VALUE);
          }
        } else if (radioEl) {
          const filterOption = radioEl.value;
          const isSelected = radioEl.checked;
          if (filterOption) {
            // Updates data model and subscribes to the data change.
            this.setModelProperty(filterOption, isSelected);
            this.model.listen(filterOption, () => {
              radioEl.checked = this.model.data[filterOption];
            });
            // Updates chip data.
            this.chips[filterOption] = chipText;
          } else {
            throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_VALUE);
          }
        } else {
          throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.ERROR_MISSING_MATERIAL);
        }
      }
    }
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_5__.EventType.CHANGE, this.handleInputChangeFunc);
  }
  /**
   * Handles the select element when it changes using single-select parameters.
   * @param evt Change event.
   */
  handleSelectChange(evt) {
    for (const key of Object.keys(this.model.data)) {
      // reset all select options to false (single select)
      this.setModelProperty(key, false);
    }
    if (evt.target instanceof HTMLSelectElement && evt.target.value) {
      // set only the current option as true in the data model
      this.setModelProperty(evt.target.value, true);
    }
  }
  /**
   * Handles the Material Select element when it changes by updating the data
   * model and the Material Select element.
   * @param evt Change event from MDCSelect.
   */
  handleMaterialSelectChange(evt) {
    const el = evt.target;
    // As a custom event, includes information on the value being changed to
    const filterOption = evt.detail.value;
    if (this.materialSelect && el instanceof HTMLDivElement &&
        el.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_7__.MaterialClasses.SELECT)) {
      // reset all select options to false (single select)
      for (const key of Object.keys(this.model.data)) {
        this.setModelProperty(key, false);
      }
      // set only the current option as true in the data model
      if (filterOption) {
        this.setModelProperty(filterOption, true);
      }
    }
  }
  /**
   * Handles the MWC3 Select element when it changes by updating the data
   * model and the Material Select element.
   * @param evt Change event from md-select.
   */
  handleMWC3SelectChange(evt) {
    const el = evt.target;
    if (el instanceof _material_web_select_outlined_select__WEBPACK_IMPORTED_MODULE_3__.MdOutlinedSelect || el instanceof _material_web_select_filled_select__WEBPACK_IMPORTED_MODULE_2__.MdFilledSelect) {
      // reset all select options to false (single select)
      for (const key of Object.keys(this.model.data)) {
        this.setModelProperty(key, false);
      }
      // set currently selected value to true
      if (el.value) {
        this.setModelProperty(el.value, true);
      }
    }
  }
  /**
   * Handles native HTML or Material input checkbox or radio elements on change.
   * @param evt Change event.
   */
  handleInputChange(evt) {
    const el = evt.target;
    if (el instanceof HTMLInputElement || el instanceof _material_web_radio_radio__WEBPACK_IMPORTED_MODULE_1__.MdRadio ||
        el instanceof _material_web_checkbox_checkbox__WEBPACK_IMPORTED_MODULE_0__.MdCheckbox) {
      if ((el instanceof HTMLInputElement && el.type === 'radio') ||
          el instanceof _material_web_radio_radio__WEBPACK_IMPORTED_MODULE_1__.MdRadio) {
        if (el.checked) {
          // Reset all other radio options and then re-check the radio
          for (const key of Object.keys(this.model.data)) {
            this.setModelProperty(key, false);
          }
          el.checked = true;
        }
      }
      // Update the filter item's value in the model
      const filterOption = el.value;
      this.setModelProperty(filterOption, el.checked);
    }
    // Update the category counter
    this.renderCategoryCounter();
  }
  /**
   * Updates the filter item's value in the data model if it already exists, or
   * adds it to the model.
   * @param key The filter item's name
   * @param value Whether the filter item is active or inactive
   */
  setModelProperty(key, value) {
    this.model.data[key] !== undefined ?
        (this.model.data[key] = value) :
        this.model.defineReactive(this.model.data, key, value);
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.UPDATE_STATUS, {}, true);
  }
  /**
   * Renders the count of active filters into the counter element if it exists.
   * TODO(b/373719612): Optimize later by storing count in data model and
   * re-rendering whenever model is changed
   */
  renderCategoryCounter() {
    if (this.categoryCountEl) {
      let activeCategories = 0;
      // Count active categories
      for (const key of Object.keys(this.model.data)) {
        if (this.model.data[key] === true) {
          activeCategories++;
        }
      }
      // Removes all child nodes
      while (this.categoryCountEl.firstChild) {
        this.categoryCountEl.removeChild(this.categoryCountEl.firstChild);
      }
      // Sets the new count
      let numEl;
      if (activeCategories) {
        numEl = document.createTextNode(activeCategories.toString());
      } else {
        // if no categories are active, show total category count
        numEl = document.createTextNode(
            Object.keys(this.model.data).length.toString());
      }
      this.categoryCountEl.appendChild(numEl);
    }
  }
}



/***/ }),

/***/ "./_glue/lib/filter/chip/index.js":
/*!****************************************!*\
  !*** ./_glue/lib/filter/chip/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterChips: () => (/* binding */ FilterChips)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./_glue/lib/filter/constants.js");
/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state_manager */ "./_glue/lib/filter/state_manager/index.js");






/**
 * A class to manage Filter Chips subcomponent.
 */
class FilterChips extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, data) {
    super(root);
    this.data = data;
    this.chipArr = [];
    this.stateManager = new _state_manager__WEBPACK_IMPORTED_MODULE_5__.FilterStateManager();
    this.isRtl = document.documentElement.dir === _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.RTL;
    /**
     * Handles key press events on the root container to navigate between chips
     */
    this.handleRootKeydown = (evt) => {
      if (evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.LEFT || evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.RIGHT ||
          evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.HOME || evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.END) {
        const isLeft = evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.LEFT;
        const isRight = evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.RIGHT;
        if (isLeft || isRight) {
          // Move to previous or next chip based on language direction
          const isNext = this.isRtl ? isLeft : isRight;
          if (isNext) {
            this.focusedChip++;
          } else {
            this.focusedChip--;
          }
        } else if (evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.HOME) {
          // Move to first chip
          this.focusedChip = 0;
        } else if (evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.END) {
          // Move to last chip
          this.focusedChip = this.chipArr.length - 1;
        }
        // Keep chip position within bounds of chipArr
        if (this.focusedChip < 0) {
          this.focusedChip = 0;
        } else if (this.focusedChip >= this.chipArr.length) {
          this.focusedChip = this.chipArr.length - 1;
        }
        this.chipArr[this.focusedChip].focus();
        evt.stopPropagation();
        evt.preventDefault();
      }
    };
    /**
     * Handles clicks on filter chips.
     */
    this.handleChipClick = (evt) => {
      let chipEl;
      const element = evt.target;
      if (element instanceof HTMLElement) {
        // Find the chip element.
        element.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP) ?
            (chipEl = element) :
            (chipEl = element.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP}`));
        if (chipEl) {
          this.updateChip(chipEl);
        }
      }
    };
    /**
     * Handles keyboard events on filter chips.
     */
    this.handleChipKeydown = (evt) => {
      let chipEl;
      const element = evt.target;
      if (element instanceof HTMLElement &&
          (evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER || evt.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE)) {
        // Find the chip element.
        element.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP) ?
            (chipEl = element) :
            (chipEl = element.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP}`));
        if (chipEl) {
          this.updateChip(chipEl);
        }
        evt.stopPropagation();
        evt.preventDefault();
      }
    };
    this.isPrimary = root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIPS_PRIMARY);
    this.addFilterLabel = root.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CHIPS_LABEL_ADD] ?
        root.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CHIPS_LABEL_ADD] :
        _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.ADD_FILTER;
    this.removeFilterLabel = root.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CHIPS_LABEL_REMOVE] ?
        root.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CHIPS_LABEL_REMOVE] :
        _constants__WEBPACK_IMPORTED_MODULE_4__.Strings.REMOVE_FILTER;
    // Set initial focused chip as out of bounds, so when you hit left or right
    // the first time you tab into the element, you focus on the first chip
    this.focusedChip = -1;
    this.init();
  }
  /**
   * Initializes the chips component.
   */
  init() {
    this.root.tabIndex =
        this.isPrimary ? _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE : _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
    const rowEl = document.createElement('div');
    rowEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.ROW);
    for (const filterCategory of Object.keys(this.data)) {
      const model = this.stateManager.getModel(filterCategory);
      for (const filterCategoryItem of Object.keys(this.data[filterCategory])) {
        if (this.isPrimary) {
          // Primary chips container should render and display all chips
          const chipEl = this.createChip(filterCategory, filterCategoryItem);
          rowEl.appendChild(chipEl);
          const chipButton = chipEl.firstElementChild;
          chipButton.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleChipClick);
          chipButton.addEventListener(
              _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleChipKeydown);
          this.chipArr.push(chipButton);
        }
        // Subscribes to the filter changes.
        model === null || model === void 0 ?
            void 0 :
            model.listen(filterCategoryItem, () => {
              this.render(
                  filterCategory, filterCategoryItem,
                  model.data[filterCategoryItem]);
            });
      }
    }
    if (this.isPrimary) {
      // Append the chips bar
      this.root.appendChild(rowEl);
    }
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleRootKeydown);
  }
  /**
   * Creates a chip element and returns it.
   */
  createChip(filterCategory, filterCategoryItem) {
    const chipContainerEl = document.createElement('span');
    chipContainerEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.GRIDCELL);
    const chipEl = document.createElement('button');
    chipEl.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP);
    chipEl.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
    chipEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TYPE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.BUTTON);
    chipEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CATEGORY] = filterCategory;
    chipEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CATEGORY_ITEM] = filterCategoryItem;
    const chipTextNode =
        document.createTextNode(this.data[filterCategory][filterCategoryItem]);
    chipEl.setAttribute(
        _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL,
        `${this.addFilterLabel} ${chipTextNode.textContent}`);
    chipEl.append(chipTextNode);
    if (this.isPrimary) {
      // Primary chips have a checkmark icon before the text content
      const checkmarkIcon = this.createCheckmarkIcon();
      chipEl.prepend(checkmarkIcon);
    } else {
      // Secondary chips have a close icon after the text content
      const closeButton = this.createCloseIconDiv();
      chipEl.append(closeButton);
    }
    chipContainerEl.appendChild(chipEl);
    return chipContainerEl;
  }
  /**
   * Changes the rendering of a specific chip and the container based on filter
   * status
   */
  render(category, categoryItem, isActive) {
    // Find the chip related to this filter, if it exists
    const chipEl = this.root.querySelector(`[data-glue-filter-category='${
        category}'][data-glue-filter-category-item='${categoryItem}']`);
    if (this.isPrimary) {
      // Primary chips are always visible; adjust their classes and labels
      if (chipEl) {
        chipEl.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP_ISACTIVE, isActive);
        const ariaLabel =
            isActive ? `${this.removeFilterLabel}` : `${this.addFilterLabel}`;
        chipEl.setAttribute(
            _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL, `${ariaLabel} ${chipEl.textContent}`);
      }
    } else {
      // If not primary chips, chip needs to be either added or removed to DOM
      // First find the row parent for chips bar, or create one if it doesn't
      // exists
      let rowEl = this.root.querySelector(`[role='${_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.ROW}']`);
      if (!rowEl) {
        rowEl = document.createElement('div');
        rowEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.ROW);
        this.root.appendChild(rowEl);
      }
      if (chipEl && !isActive) {
        // If chip is already in the DOM, and filter is inactive, remove it.
        // unassign handlers
        chipEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleChipClick);
        chipEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleChipKeydown);
        const cellEl = chipEl.parentElement;
        // remove element from the row
        rowEl.removeChild(cellEl);
        // remove it from chipArr
        const chipIndex = this.chipArr.indexOf(chipEl);
        this.chipArr.splice(chipIndex, 1);
        if (this.chipArr.length === 0) {
          // if row is now empty, remove it
          this.root.removeChild(rowEl);
        }
      } else if (isActive) {
        // If chip is not already in the DOM, and filter is active, add it.
        // Add DOM to the row parent
        const newChipEl = this.createChip(category, categoryItem);
        rowEl.appendChild(newChipEl);
        const chipButton = newChipEl.firstElementChild;
        if (chipButton instanceof HTMLElement) {
          // Add event handlers
          chipButton.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleChipClick);
          chipButton.addEventListener(
              _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleChipKeydown);
          // Set classes and labels
          chipButton.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP_ISACTIVE);
          chipButton.setAttribute(
              _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL,
              `${this.removeFilterLabel} ${chipButton.textContent}`);
          // Updates chips array.
          this.chipArr.push(chipButton);
        }
      }
      // If there is at least 1 chip (row exists), make the container tabbable.
      rowEl = this.root.querySelector(`[role='${_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.ROW}']`);
      this.root.tabIndex = rowEl ? _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE : _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      if (!rowEl) {
        // Reset focused chip if no chips are visible.
        this.focusedChip = -1;
      }
    }
  }
  /**
   * Creates and returns an SVG checkmark icon
   */
  createCheckmarkIcon() {
    const checkmarkIcon =
        document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    checkmarkIcon.setAttribute('viewBox', '-2 -3 30 30');
    checkmarkIcon.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.PRESENTATION);
    checkmarkIcon.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
    checkmarkIcon.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP_CHECKMARK, 'glue-icon');
    const checkmarkPath =
        document.createElementNS('http://www.w3.org/2000/svg', 'path');
    checkmarkPath.setAttribute('d', 'M1.73,12.91 8.1,19.28 22.79,4.59');
    checkmarkIcon.appendChild(checkmarkPath);
    return checkmarkIcon;
  }
  /**
   * Creates and returns a div with the close icon styles applied
   */
  createCloseIconDiv() {
    const closeButton = document.createElement('div');
    closeButton.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP_CLOSEBTN);
    return closeButton;
  }
  /**
   * Updates the status of the current chip
   */
  updateChip(chipEl) {
    var _a;
    const filterCategory = chipEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CATEGORY];
    const filterCategoryItem = chipEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CATEGORY_ITEM];
    const isActive = chipEl.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CHIP_ISACTIVE);
    // Store chip's position in chipArr
    this.focusedChip = this.chipArr.indexOf(chipEl);
    if (filterCategory && filterCategoryItem) {
      const model = this.stateManager.getModel(filterCategory);
      if (model) {
        model.data[filterCategoryItem] = !isActive;
        this.emit(_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.UPDATE_STATUS, {}, true);
        // Adjusts focused (secondary) chip by finding nearest chip
        if (!this.isPrimary && !model.data[filterCategoryItem]) {
          if (this.chipArr.length === 0) {
            // if array is completely empty, no chip is focusable.
            this.focusedChip = -1;
          } else {
            // move index back 1 position since chip was removed from array
            this.focusedChip--;
            if (this.focusedChip < 0) {
              // If we moved before start of array, return there
              this.focusedChip = 0;
            } else if (this.focusedChip >= this.chipArr.length) {
              // If we are beyond the end of the array, return there
              this.focusedChip = this.chipArr.length - 1;
            }
          }
        }
        (_a = this.chipArr[this.focusedChip]) === null || _a === void 0 ?
            void 0 :
            _a.focus();
      }
    }
  }
  /**
   * Destroys the chips component: removes event handlers and resets container.
   */
  destroy() {
    this.root.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleRootKeydown);
    this.chipArr.forEach((el) => {
      el.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleChipClick);
      el.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleChipKeydown);
    });
    const chipsRowEl = this.root.querySelector('div[role=row]');
    if (chipsRowEl) {
      this.root.removeChild(chipsRowEl);
    }
  }
}



/***/ }),

/***/ "./_glue/lib/filter/constants.js":
/*!***************************************!*\
  !*** ./_glue/lib/filter/constants.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   MaterialClasses: () => (/* binding */ MaterialClasses),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-filter';
CssClasses['ROOT_MWS'] = 'glue-filter--mws';
CssClasses['APPLY_FILTERS'] = 'glue-filter__apply-filters';
CssClasses['CATEGORIES'] = 'glue-filter__categories';
CssClasses['CATEGORY'] = 'glue-filter__category';
CssClasses['CATEGORY_COUNT'] = 'glue-filter__category-count';
CssClasses['CATEGORY_ITEM'] = 'glue-filter__category-item';
CssClasses['CHIP'] = 'glue-filter__chip';
CssClasses['CHIP_ISACTIVE'] = 'glue-filter__chip--is-active';
CssClasses['CHIP_CHECKMARK'] = 'glue-filter__chip-checkmark';
CssClasses['CHIP_CLOSEBTN'] = 'glue-filter__chip-close-btn';
CssClasses['CHIPS'] = 'glue-filter__chips';
CssClasses['CHIPS_BAR'] = 'glue-filter__chips-bar';
CssClasses['CHIPS_HEADER'] = 'glue-filter__chips-header';
CssClasses['CHIPS_PRIMARY'] = 'glue-filter__chips--primary';
CssClasses['CONTROLS'] = 'glue-filter__filter-controls';
CssClasses['EXPANSIONPANELS'] = 'glue-filter__panels';
CssClasses['MODAL'] = 'glue-filter__modal';
CssClasses['MODAL_CONTENT'] = 'glue-filter__modal-content';
CssClasses['MODAL_CONTROLS'] = 'glue-filter__modal-controls';
CssClasses['MODAL_TOGGLE'] = 'glue-filter__modal-toggle';
CssClasses['MODAL_VIEWRESULTS'] = 'glue-filter__view-results';
CssClasses['RESET_ALL'] = 'glue-filter__reset-all';
CssClasses['RESET_ALL_FILTERED'] = 'glue-filter__reset-all--filtered';
CssClasses['RESULT'] = 'glue-filter__result';
CssClasses['RESULT_IS_MATCHING'] = 'glue-filter__result--is-matching';
CssClasses['RESULTS'] = 'glue-filter__results';
CssClasses['RESULTS_COUNT'] = 'glue-filter__results-count';
CssClasses['RESULTS_STATUS'] = 'glue-filter__results-status';
CssClasses['SHOW_RESULTS'] = 'glue-filter__show-results';
CssClasses['TITLE'] = 'glue-filter__filter-title';
})(CssClasses || (CssClasses = {}));
var MaterialClasses;
(function(MaterialClasses) {
MaterialClasses['CHECKBOX'] = 'mdc-checkbox__native-control';
MaterialClasses['RADIO'] = 'mdc-radio__native-control';
MaterialClasses['LIST_ITEM'] = 'mdc-list-item';
MaterialClasses['FORM_FIELD'] = 'mdc-form-field';
MaterialClasses['LABEL'] = 'mdc-floating-label';
MaterialClasses['SELECT'] = 'mdc-select';
MaterialClasses['SELECT_LABEL'] = 'mdc-list-item__text';
MaterialClasses['MWC3_CHECKBOX'] = 'glue-mwc3-checkbox';
MaterialClasses['MWC3_RADIO'] = 'glue-mwc3-radio';
MaterialClasses['MWC3_SELECT'] = 'glue-mwc3-select';
})(MaterialClasses || (MaterialClasses = {}));
var Strings;
(function(Strings) {
// data parameters
Strings['CATEGORIES'] = 'glueFilterCategories';
Strings['CATEGORY'] = 'glueFilterCategory';
Strings['CATEGORY_ITEM'] = 'glueFilterCategoryItem';
Strings['CHIPS_LABEL_ADD'] = 'glueFilterChipsLabelAdd';
Strings['CHIPS_LABEL_REMOVE'] = 'glueFilterChipsLabelRemove';
Strings['CHIPS_LABEL_RESET'] = 'glueFilterChipsLabelReset';
Strings['RESULT_MATCH'] = 'glueFilterResultMatch';
Strings['DATA_VALUE'] = 'value';
Strings['STRATEGY'] = 'glueFilterStrategy';
Strings['PREFIX'] = 'data-glue-filter-';
// Layout
Strings['RTL'] = 'rtl';
// Events
Strings['UPDATE_STATUS'] = 'gluefilterupdatestatus';
Strings['MATERIALSELECT_CHANGE'] = 'MDCSelect:change';
// Defaults
Strings['CLEAR_FILTERS'] = 'Clear filters';
Strings['ADD_FILTER'] = 'Add filter';
Strings['REMOVE_FILTER'] = 'Remove filter';
Strings['RESULTS_COUNT'] = '[COUNT] results';
Strings['MODAL_TOGGLE_TEXT'] = 'Filter';
Strings['MODAL_CLOSE_TEXT'] = 'Close filter modal';
Strings['MODAL_RESULTS_COUNT'] = 'Show [COUNT] results';
Strings['PANELS_COLLAPSE_LABEL'] = 'Collapse this filter category';
Strings['PANELS_EXPAND_LABEL'] = 'Expand this filter category';
Strings['APPLIED_FILTERS'] = 'Applied filters';
// Error messages
Strings['ERROR_MISSING_CATEGORY'] =
    'Filter category is not set on the element.';
Strings['ERROR_MISSING_MATERIAL'] =
    'Material input was not found on this element';
Strings['ERROR_MISSING_VALUE'] = 'Attribute "value" is not set on the element.';
// Layout types
Strings['LAYOUT_VERTICAL'] = 'vertical';
Strings['LAYOUT_HORIZONTAL_DROPDOWN'] = 'horizontal-dropdown';
Strings['LAYOUT_HORIZONTAL_CHIPS'] = 'horizontal-chips';
// ID generators
Strings['CATEGORY_COUNT_ID'] = 'glue-filter-category-count';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/filter/index.js":
/*!***********************************!*\
  !*** ./_glue/lib/filter/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Filter: () => (/* binding */ Filter),
/* harmony export */   FilterStateManager: () => (/* reexport safe */ _state_manager__WEBPACK_IMPORTED_MODULE_9__.FilterStateManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _expansionpanels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expansionpanels */ "./_glue/lib/expansionpanels/index.js");
/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modal */ "./_glue/lib/modal/index.js");
/* harmony import */ var _responsivemonitor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../responsivemonitor */ "./_glue/lib/responsivemonitor/index.js");
/* harmony import */ var _category__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./category */ "./_glue/lib/filter/category/index.js");
/* harmony import */ var _chip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chip */ "./_glue/lib/filter/chip/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "./_glue/lib/filter/constants.js");
/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./result */ "./_glue/lib/filter/result/index.js");
/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./state_manager */ "./_glue/lib/filter/state_manager/index.js");












/** A class to filter a list of content. */
class Filter extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /** Creates an instance of GlueFilter. */
  constructor(root) {
    super(root);
    /** A collection of filter categories. */
    this.categories = [];
    this.handleReset = () => {
      this.reset();
    };
    this.handleUpdateResetButton = () => {
      this.updateResetButton();
    };
    this.handleOpenModal = () => {
      var _a;
      (_a = this.modal) === null || _a === void 0 ? void 0 : _a.open();
    };
    this.handleCloseModal = () => {
      var _a;
      (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();
    };
    this.resetAllEls = [
      ...this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.RESET_ALL}`),
    ];
    // Grab subcomponent elements
    this.modalEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.MODAL}`);
    this.modalToggleEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.MODAL_TOGGLE}`);
    this.modalCloseEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.SHOW_RESULTS}`);
    this.expansionPanelsEl =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.EXPANSIONPANELS}`);
    this.init();
  }
  /** Initializes subfeatures of the filter component. */
  init() {
    this.initCategories();
    this.initResults();
    this.initChips();
    this.initPanels();
    this.initResponsiveModal();
    this.initResetAll();
  }
  /** Initializes filter category elements. */
  initCategories() {
    const filters = [
      ...this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CATEGORY}`),
    ];
    if (!filters.length) {
      throw new Error('There are no filter category elements found.');
    }
    for (const el of filters) {
      const filterCategory = new _category__WEBPACK_IMPORTED_MODULE_5__.FilterCategory(el);
      this.categories.push(filterCategory);
    }
  }
  /** Initializes results container element. */
  initResults() {
    const resultsEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.RESULTS}`);
    if (!resultsEl) {
      throw new Error('There is no filter results container found.');
    }
    this.results = new _result__WEBPACK_IMPORTED_MODULE_8__.FilterResult(resultsEl);
  }
  /** Initializes chips if the container element exists. */
  initChips() {
    var _a;
    const chipsEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CHIPS}`);
    if (chipsEl) {
      const chipsCollection = {};
      for (const [index, filterCategory] of Object.entries(this.categories)) {
        const category =
            (_a = filterCategory.category) !== null && _a !== void 0 ?
            _a :
            `glue-filter-category-${index}`;
        chipsCollection[category] = filterCategory.chips;
      }
      this.chips = new _chip__WEBPACK_IMPORTED_MODULE_6__.FilterChips(chipsEl, chipsCollection);
    }
  }
  /** Initializes reset all buttons if they exist. */
  initResetAll() {
    this.resetAllEls = [
      ...this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.RESET_ALL}`),
    ];
    if (this.resetAllEls.length) {
      for (const el of this.resetAllEls) {
        el.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleReset);
      }
      this.root.addEventListener(
          _constants__WEBPACK_IMPORTED_MODULE_7__.Strings.UPDATE_STATUS, this.handleUpdateResetButton);
    }
  }
  /** Initializes expansion panels if they exist */
  initPanels() {
    if (this.expansionPanelsEl) {
      this.expansionPanels = new _expansionpanels__WEBPACK_IMPORTED_MODULE_2__.ExpansionPanels(this.expansionPanelsEl);
    }
  }
  /** Initializes responsive monitor to create/destroy modal if modal exists */
  initResponsiveModal() {
    if (this.modalEl) {
      if (!this.modalToggleEl) {
        throw new Error('Filter modal exists but its toggle is missing.');
      }
      this.responsiveModal = new _responsivemonitor__WEBPACK_IMPORTED_MODULE_4__.ResponsiveMonitor({
        breakpoint: ['sm', 'md'],
        enter: () => {
          var _a, _b;
          // Initializes modal and toggle handlers on small/medium viewports
          this.modal = new _modal__WEBPACK_IMPORTED_MODULE_3__.Modal(this.modalEl, this.modalToggleEl);
          (_a = this.modalToggleEl) === null || _a === void 0 ?
              void 0 :
              _a.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleOpenModal);
          (_b = this.modalCloseEl) === null || _b === void 0 ?
              void 0 :
              _b.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleCloseModal);
        },
        leave: () => {
          var _a, _b, _c, _d;
          // Closes/destroys modal and remove handlers on large/xl viewports
          (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();
          (_b = this.modal) === null || _b === void 0 ? void 0 : _b.destroy();
          (_c = this.modalToggleEl) === null || _c === void 0 ?
              void 0 :
              _c.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleOpenModal);
          (_d = this.modalCloseEl) === null || _d === void 0 ?
              void 0 :
              _d.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleCloseModal);
        },
      });
    }
  }
  /**
   * Removes event listeners and destroys subcomponents.
   */
  destroy() {
    var _a, _b, _c, _d, _e, _f, _g;
    // Destroys/resets filter categories and chips
    this.categories.forEach((filterCategory) => {
      filterCategory.destroy();
    });
    (_a = this.chips) === null || _a === void 0 ? void 0 : _a.destroy();
    _state_manager__WEBPACK_IMPORTED_MODULE_9__.FilterStateManager.reset();
    // Cleans up resetall buttons
    if (this.resetAllEls.length) {
      for (const el of this.resetAllEls) {
        el.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleReset);
      }
      this.root.removeEventListener(
          _constants__WEBPACK_IMPORTED_MODULE_7__.Strings.UPDATE_STATUS, this.handleUpdateResetButton);
    }
    // Destroys panels
    (_b = this.expansionPanels) === null || _b === void 0 ? void 0 :
                                                            _b.destroy();
    // Destroys/cleans up modal
    (_c = this.responsiveModal) === null || _c === void 0 ? void 0 :
                                                            _c.destroy();
    (_d = this.modal) === null || _d === void 0 ? void 0 : _d.close();
    (_e = this.modal) === null || _e === void 0 ? void 0 : _e.destroy();
    (_f = this.modalToggleEl) === null || _f === void 0 ?
        void 0 :
        _f.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleOpenModal);
    (_g = this.modalCloseEl) === null || _g === void 0 ?
        void 0 :
        _g.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.CLICK, this.handleCloseModal);
  }
  /**
   * Resets all filters, or a single filter if the filter category is specified.
   * @param category The filter category to reset.
   */
  reset(category) {
    if (category) {
      this.categories
          .filter((val) => {
            return val.category === category;
          })[0]
          .reset();
    } else {
      this.categories.forEach((filterCategory) => {
        filterCategory.reset();
      });
      // Updates classes
      this.updateResetButton();
    }
  }
  /**
   * Returns a list of matched items.
   */
  getFilteredItems() {
    return this.results.filteredItems;
  }
  /**
   * Returns the StateManager.
   */
  getStateManager() {
    return new _state_manager__WEBPACK_IMPORTED_MODULE_9__.FilterStateManager();
  }
  /**
   * Updates class on the Reset All buttons when filters are toggled.
   * Class should only be added when at least one filter is active.
   */
  updateResetButton() {
    let areFiltersActive = false;
    const isActive = (filterValue) => filterValue === true;
    for (const filterCategory of this.categories) {
      if (!areFiltersActive) {
        areFiltersActive =
            Object.values(filterCategory.model.data).some(isActive);
      }
    }
    for (const el of this.resetAllEls) {
      if (areFiltersActive) {
        el.classList.add(_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.RESET_ALL_FILTERED);
      } else {
        el.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.RESET_ALL_FILTERED);
      }
    }
  }
}



/***/ }),

/***/ "./_glue/lib/filter/result/index.js":
/*!******************************************!*\
  !*** ./_glue/lib/filter/result/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterResult: () => (/* binding */ FilterResult)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./_glue/lib/filter/constants.js");
/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../state_manager */ "./_glue/lib/filter/state_manager/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util */ "./_glue/lib/filter/util/index.js");





/**
 * A class to manage filter result component.
 */
class FilterResult extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * Creates an instance of GlueFilterResult.
   */
  constructor(root) {
    super(root);
    this.resultItems = [];
    this.filteredItems = [];
    this.resultTags = [];
    this.filterCategories = [];
    this.filterData = {};
    this.init();
  }
  /** Initializes filter result component. */
  init() {
    var _a;
    // Updates strategy value of the filter.
    this.filterData.strategy = this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_2__.Strings.STRATEGY];
    // Validates filter categories.
    const filterCategories = this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_2__.Strings.CATEGORIES];
    if (!filterCategories) {
      throw new Error('Filter categories are not set on the result element.');
    }
    this.filterCategories = filterCategories.split(' ');
    if (!this.checkfilterCategories(this.filterCategories)) {
      throw new Error('These filter categories are not valid.');
    }
    // Subscribes to filter data changes.
    for (const filterCategory of this.filterCategories) {
      const model = new _state_manager__WEBPACK_IMPORTED_MODULE_3__.FilterStateManager().getModel(filterCategory);
      const data =
          (_a = model === null || model === void 0 ? void 0 : model.data) !==
                  null &&
              _a !== void 0 ?
          _a :
          {};
      for (const key of Object.keys(data)) {
        model === null || model === void 0 ? void 0 : model.listen(key, () => {
          this.render();
        });
      }
    }
    // Collects tags from each result item.
    this.resultItems = [
      ...this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.RESULT}`),
    ];
    this.resultItems.forEach((el) => {
      // Parse data-glue-filter-result-match as data-glue-filter-CATEGORY
      if (el.dataset[_constants__WEBPACK_IMPORTED_MODULE_2__.Strings.RESULT_MATCH]) {
        JSON.parse(el.dataset[_constants__WEBPACK_IMPORTED_MODULE_2__.Strings.RESULT_MATCH], (key, value) => {
          if (key) {
            el.dataset[key] = value;
          }
        });
      }
      const tags = {};
      this.filterCategories.forEach((filterCategory) => {
        const filterTag = el.getAttribute(_constants__WEBPACK_IMPORTED_MODULE_2__.Strings.PREFIX + filterCategory);
        tags[filterCategory] = filterTag ? filterTag.split(' ') : [];
      });
      this.resultTags.push(tags);
    });
    this.render();
  }
  /** Returns true if all filter categories are valid. */
  checkfilterCategories(filterCategories) {
    for (const category of filterCategories) {
      if (!new _state_manager__WEBPACK_IMPORTED_MODULE_3__.FilterStateManager().getModel(category)) {
        return false;
      }
    }
    return true;
  }
  /** Returns filter results. */
  getFilterResults() {
    var _a;
    const data = {};
    for (const category of this.filterCategories) {
      data[category] =
          (_a = new _state_manager__WEBPACK_IMPORTED_MODULE_3__.FilterStateManager().getModel(category)) === null ||
              _a === void 0 ?
          void 0 :
          _a.data;
    }
    this.filterData = Object.assign({}, this.filterData, data);
    return (0,_util__WEBPACK_IMPORTED_MODULE_4__.filterlist)(this.resultTags, this.filterData);
  }
  /**
   * Renders filter results elements.
   */
  render() {
    const results = this.getFilterResults();
    for (const [index, el] of this.resultItems.entries()) {
      el.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.RESULT_IS_MATCHING, results[index]);
      results[index] ? el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN) :
                       el.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
    }
    this.filteredItems = [
      ...this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.RESULT_IS_MATCHING}`),
    ];
    this.renderCounter();
  }
  /**
   * Renders the count of filtered results.
   */
  renderCounter() {
    const counter = this.filteredItems.length;
    const filterRootEl = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.ROOT}`) ?
        this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.ROOT}`) :
        this.root;
    const resultsCount =
        filterRootEl.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.RESULTS_COUNT}`);
    if (resultsCount.length) {
      for (const el of resultsCount) {
        // Removes all child nodes
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
        const numEl = document.createTextNode(counter.toString());
        el.appendChild(numEl);
      }
    }
  }
}



/***/ }),

/***/ "./_glue/lib/filter/state_manager/index.js":
/*!*************************************************!*\
  !*** ./_glue/lib/filter/state_manager/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterStateManager: () => (/* binding */ FilterStateManager)
/* harmony export */ });
/**
 * A class to manage state of list filter component.
 * It manages a collection of models.
 */
class FilterStateManager {
  constructor() {
    this.models = {};
    if (!FilterStateManager.instance) {
      FilterStateManager.instance = this;
    } else {
      this.models = FilterStateManager.instance.getModels();
    }
    return FilterStateManager.instance;
  }
  /**
   * Returns the data object based on the key.
   * @param key The key of the data.
   */
  getModel(key) {
    return this.models[key];
  }
  /**
   * Returns all data objects.
   */
  getModels() {
    return this.models;
  }
  /**
   * Sets data model.
   * @param key The key of the data.
   * @param model The data to be set.
   */
  setModel(key, model) {
    this.models[key] = model;
  }
  // Resets the StateManager instance.
  static reset() {
    FilterStateManager.instance = undefined;
  }
}



/***/ }),

/***/ "./_glue/lib/filter/util/index.js":
/*!****************************************!*\
  !*** ./_glue/lib/filter/util/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filterlist: () => (/* binding */ filterlist)
/* harmony export */ });
/**
 * Returns matching results for a list of data.
 *
 *  The first argument is targetArray which includes a list of targets.
 *  Each target is an object which represents a filter category and
 *  possible values.
 *  Example:
 *  targetArray: Target[] = [
 *    {
 *      'color': ['green', 'red'],
 *      'type': ['fruit'],
 *    },
 *    {
 *      'color': ['yellow'],
 *      'type': ['vegetable'],
 *    }
 *  ]
 *
 *  The second parameter is a filter object, which represents the matching
 *  criteria used to evaluate the list of items.
 *  Example:
 *  filter: Filter = {
 *    'type': {
 *      'vegetable': true,
 *      'fruit': false,
 *    },
 *    'color': {
 *      'red': true,
 *      'orange': true,
 *      'yellow': false,
 *      'green': false
 *    }
 *  }
 *  The output is an array of boolean values, they represent whether the
 *  corresponding items are matched. Example: [true,true,false].
 * @param targetArr The target data object to filter
 * @param filter The filter object with stategy and filters.
 * @param matchFunc An optional function to use for matching.
 * @return The result showing whether the data matches the filter.
 */
function filterlist(targetArr, filter, matchFunc) {
  const output = [];
  targetArr.forEach((target) => {
    const filtered = filterData(target, filter, matchFunc);
    output.push(filtered);
  });
  return output;
}
/**
 * Returns matching result for a single data based on the filter.
 * @return Shows whether the data matches the filter.
 */
function filterData(target, filter, matchFunc) {
  let isMatch = false;
  // Set a default filter strategy to 'strict'
  if (filter.strategy === undefined ||
      !['strict', 'loose'].includes(filter.strategy)) {
    filter.strategy = 'strict';
  }
  for (const key of Object.keys(target)) {
    isMatch = false;
    // Ignores the filter if the filter is inactive. The filter is inactive
    // if all filter options are false.
    if (!checkActiveState(filter, key) || filter[key] === undefined) {
      isMatch = true;
    } else {
      for (const value of target[key]) {
        const filterGroup = filter[key];
        let matchResult = false;
        if (matchFunc) {
          matchResult = matchFunc.call(undefined, filter, key, value);
        } else if (typeof filterGroup === 'object') {
          matchResult = filterGroup[value];
        }
        if (matchResult === true) {
          isMatch = true;
          break;
        }
      }
    }
    if ((filter.strategy === 'strict') === isMatch) {
      continue;
    } else {
      return isMatch;
    }
  }
  return isMatch;
}
/**
 * Checks whether the filter is active. Returns true if users have
 * changed the filter value.
 * @param filter The object includes all filters.
 * @param filterId The id of the filter item.
 * @return If the state is active.
 */
function checkActiveState(filter, filterId) {
  const item = filter[filterId];
  if (typeof item === 'object') {
    for (const filterOption in item) {
      if (item[filterOption]) return true;
    }
  }
  if (typeof item === 'string' && item.length > 0) {
    return true;
  }
  return false;
}



/***/ }),

/***/ "./_glue/lib/focus/index.js":
/*!**********************************!*\
  !*** ./_glue/lib/focus/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FOCUSABLE_ELEMENT_SELECTORS: () => (/* binding */ FOCUSABLE_ELEMENT_SELECTORS),
/* harmony export */   getFocusableElements: () => (/* binding */ getFocusableElements),
/* harmony export */   isElementFocusable: () => (/* binding */ isElementFocusable)
/* harmony export */ });
/**
 * @fileoverview Utilities relating to keyboard focus.
 */
/**
 * Query selectors for elements that can receive focus.
 * Include Material 3 custom elements that Glue uses.
 */
const FOCUSABLE_ELEMENT_SELECTORS = [
  'input',
  'textarea',
  'select',
  'button',
  'iframe',
  '[role="button"]',
  'a',
  '[tabindex]',
  'md-checkbox',
  'md-radio',
  'md-switch',
  'md-outlined-select',
  'md-filled-select',
  'md-outlined-text-field',
  'md-filled-text-field',
];
/**
 * Returns true if the element is able to receive focus. Note that this will
 * return true even for elements where the user isn't able to move focus
 * to the element but javascript is able to move focus.
 * @param el The Element to check for focusability.
 * @return Returns true if the element is focusable
 */
function isElementFocusable(el) {
  return (
      FOCUSABLE_ELEMENT_SELECTORS
          .filter((selector) => {
            return el.matches(selector);
          })
          .length > 0);
}
/**
 * Get all child focusable elements.
 * @param el The parent element.
 * @return Array containing all child focusable elements.
 */
function getFocusableElements(el) {
  const inputs = el.querySelectorAll('input');
  const anchors = el.querySelectorAll('a');
  const textareas = el.querySelectorAll('textarea');
  const selects = el.querySelectorAll('select');
  const buttons = el.querySelectorAll('button');
  const iframes = el.querySelectorAll('iframe');
  const roleBtnElements = el.querySelectorAll(
      '[role="button"]' +
      ':not(input)' +
      ':not(a)' +
      ':not(textarea)' +
      ':not(select)' +
      ':not(button)' +
      ':not(iframe)');
  const tabindexElements = el.querySelectorAll(
      '[tabindex="0"]' +
      ':not([role="button"])' +
      ':not(input)' +
      ':not(a)' +
      ':not(textarea)' +
      ':not(select)' +
      ':not(button)' +
      ':not(iframe)' +
      ':not(md-checkbox)' +
      ':not(md-radio)' +
      ':not(md-switch)' +
      ':not(md-outlined-select)' +
      ':not(md-filled-select)' +
      ':not(md-outlined-text-field)' +
      ':not(md-filled-text-field)');
  const mdCheckboxes = el.querySelectorAll('md-checkbox');
  const mdRadios = el.querySelectorAll('md-radio');
  const mdSwitches = el.querySelectorAll('md-switch');
  const mdOutlinedSelects = el.querySelectorAll('md-outlined-select');
  const mdFilledSelects = el.querySelectorAll('md-filled-select');
  const mdOutlinedTextFields = el.querySelectorAll('md-outlined-text-field');
  const mdFilledTextFields = el.querySelectorAll('md-filled-text-field');
  return [
    ...inputs,
    ...anchors,
    ...textareas,
    ...selects,
    ...buttons,
    ...iframes,
    ...roleBtnElements,
    ...tabindexElements,
    ...mdCheckboxes,
    ...mdRadios,
    ...mdSwitches,
    ...mdOutlinedSelects,
    ...mdFilledSelects,
    ...mdOutlinedTextFields,
    ...mdFilledTextFields,
  ];
}



/***/ }),

/***/ "./_glue/lib/footer/constants.js":
/*!***************************************!*\
  !*** ./_glue/lib/footer/constants.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   DataAttr: () => (/* binding */ DataAttr)
/* harmony export */ });
/**
 * @fileoverview Constants used in footer component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['FOOTER_ROOT'] = 'glue-footer';
CssClasses['FOOTER_UPPER'] = 'glue-footer__upper';
CssClasses['FOOTER_LINK'] = 'glue-footer__link';
CssClasses['FOOTER_LOGO'] = 'glue-footer__logo';
CssClasses['FOOTER_LOGO_IMG'] = 'glue-footer__logo-img';
CssClasses['FOOTER_PANELS'] = 'glue-footer__site-links';
CssClasses['FOOTER_PANELS_GROUP'] = 'glue-footer__site-links-grid';
CssClasses['FOOTER_PANELS_PANEL'] = 'glue-footer__site-links-column';
CssClasses['FOOTER_PANELS_TOGGLE'] = 'glue-footer__site-links-header';
CssClasses['FOOTER_PANELS_BUTTON'] = 'glue-footer__site-links-header-button';
CssClasses['FOOTER_PANELS_CONTENT'] = 'glue-footer__site-links-list';
CssClasses['FOOTER_PANELS_CONTENT_ITEM'] = 'glue-footer__site-links-list-item';
CssClasses['FOOTER_PANELS_HEADER_TEXT'] = 'glue-footer__site-links-header-text';
CssClasses['FOOTER_GLOBAL'] = 'glue-footer__global';
CssClasses['FOOTER_GLOBAL_LINKS'] = 'glue-footer__global-links';
CssClasses['FOOTER_GLOBAL_LINKS_EXTRA'] = 'glue-footer__global-links--extra';
CssClasses['FOOTER_GLOBAL_LINKS_LIST_ITEM'] =
    'glue-footer__global-links-list-item';
CssClasses['FOOTER_GLOBAL_LINKS_LIST_ITEM_EXTRA'] =
    'glue-footer__global-links-list-item--extra';
CssClasses['FOOTER_LANG_DROPDOWN'] = 'glue-footer__lang-dropdown';
})(CssClasses || (CssClasses = {}));
var DataAttr;
(function(DataAttr) {
DataAttr['MODEL_NAME'] = 'footer';
DataAttr['KEY'] = 'glueExpansionPanelsKey';
DataAttr['TOGGLEFOR'] = 'glueExpansionPanelToggleFor';
})(DataAttr || (DataAttr = {}));



/***/ }),

/***/ "./_glue/lib/footer/index.js":
/*!***********************************!*\
  !*** ./_glue/lib/footer/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Footer: () => (/* binding */ Footer)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _expansionpanels__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expansionpanels */ "./_glue/lib/expansionpanels/index.js");
/* harmony import */ var _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expansionpanels/constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _responsivemonitor___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../responsivemonitor/ */ "./_glue/lib/responsivemonitor/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./_glue/lib/footer/constants.js");







/**
 * Class for creating Footer.
 */
class Footer extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The element that contains the footer sitelinks.
   * @param options Footer sitelink options.
   */
  constructor(root, options) {
    super(root);
    this.options = Object.assign({}, Footer.defaults, options);
    // Set up expansion panel options
    this.panelsOptions = {
      isAnimated: this.options.isAnimated,
      panelsCount: this.options.columnCount,
    };
    this.panelGroupEl =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.FOOTER_PANELS_GROUP}`);
    // Set up rules for Responsive Monitor if panel group exists
    if (this.panelGroupEl) {
      this.responsiveSitelinks = new _responsivemonitor___WEBPACK_IMPORTED_MODULE_3__.ResponsiveMonitor({
        breakpoint: this.options.panelsBreakpoints,
        enter: () => {
          if (this.panelGroupEl) {
            // Set up expansion panels
            this.configureExpansionPanels(true);
            this.panelsComponent =
                new _expansionpanels__WEBPACK_IMPORTED_MODULE_1__.ExpansionPanels(this.panelGroupEl, this.panelsOptions);
          }
        },
        leave: () => {
          var _a;
          if (this.panelGroupEl) {
            // Remove expansion panels
            (_a = this.panelsComponent) === null || _a === void 0 ?
                void 0 :
                _a.destroy();
            this.configureExpansionPanels(false);
          }
        },
      });
    }
  }
  /**
   * Default footer sitelinks options.
   */
  static get defaults() {
    return {
      panelsBreakpoints: ['sm'],
      isAnimated: true,
      columnCount: 4,
    };
  }
  /**
   * Destroy the component.
   */
  destroy() {
    var _a;
    // Destroy panels (if set)
    if (this.panelsComponent) {
      this.panelsComponent.destroy();
      this.configureExpansionPanels(false);
    }
    // Destroy Responsive monitor instance
    (_a = this.responsiveSitelinks) === null || _a === void 0 ? void 0 :
                                                                _a.destroy();
  }
  /**
   * Configure expansion panels if they exist
   */
  configureExpansionPanels(isPanels) {
    if (!this.panelGroupEl) {
      return;
    }
    // Group settings
    this.panelGroupEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.GROUP, isPanels);
    if (isPanels) {
      this.panelGroupEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.KEY] = _constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.MODEL_NAME;
    } else {
      delete this.panelGroupEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.KEY];
    }
    // Individual panel settings
    for (const panelEl of this.panelGroupEl.querySelectorAll(
             `.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.FOOTER_PANELS_PANEL}`)) {
      const panelToggleEl =
          panelEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.FOOTER_PANELS_TOGGLE}`);
      const panelButtonEl =
          panelEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.FOOTER_PANELS_BUTTON}`);
      const panelContentEl =
          panelEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.FOOTER_PANELS_CONTENT}`);
      panelEl === null || panelEl === void 0 ?
          void 0 :
          panelEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.PANEL, isPanels);
      panelToggleEl === null || panelToggleEl === void 0 ?
          void 0 :
          panelToggleEl.classList.toggle(
              _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.TOGGLE, isPanels);
      panelButtonEl === null || panelButtonEl === void 0 ?
          void 0 :
          panelButtonEl.classList.toggle(
              _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.BUTTON, isPanels);
      panelContentEl === null || panelContentEl === void 0 ?
          void 0 :
          panelContentEl.classList.toggle(
              _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.CONTENT, isPanels);
      // Accessibility attributes for various elements
      if (isPanels && panelButtonEl && panelContentEl) {
        panelButtonEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.TOGGLEFOR] = panelContentEl.id;
      } else {
        panelButtonEl === null || panelButtonEl === void 0 ?
            void 0 :
            panelButtonEl.removeAttribute(_constants__WEBPACK_IMPORTED_MODULE_4__.DataAttr.TOGGLEFOR);
      }
    }
  }
}



/***/ }),

/***/ "./_glue/lib/header/constants.js":
/*!***************************************!*\
  !*** ./_glue/lib/header/constants.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Icons: () => (/* binding */ Icons),
/* harmony export */   Numbers: () => (/* binding */ Numbers),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Header component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-header';
CssClasses['BAR'] = 'glue-header__bar';
CssClasses['TOGGLE_BTN'] = 'glue-header__drawer-toggle-btn';
CssClasses['DRAWER_EL'] = 'glue-header__drawer';
CssClasses['DRAWER_EL_BACKDROP'] = 'glue-header__drawer-backdrop';
CssClasses['HAMBURGER'] = 'glue-header__hamburger';
CssClasses['DRAWER_IS_SHOWN'] = 'glue-is-showing-drawer';
CssClasses['DOUBLE'] = 'glue-header--double';
CssClasses['SINGLE'] = 'glue-header--single';
CssClasses['WHOLLY_SCROLLED'] = 'glue-header-is-wholly-scrolled';
CssClasses['LOCK_UP'] = 'glue-header__lock-up';
CssClasses['ICON_LOCK_UP'] = 'glue-header--icon-lockup';
CssClasses['LINK_BAR'] = 'glue-header__link-bar';
CssClasses['LIST'] = 'glue-header__list';
CssClasses['LIST_ITEM'] = 'glue-header__item';
CssClasses['NESTED_LIST'] = 'glue-header__list--nested';
CssClasses['LINK_ITEM'] = 'glue-header__link';
CssClasses['LOGO'] = 'glue-header__logo';
CssClasses['LOGO_LINK'] = 'glue-header__logo-link';
CssClasses['LOGO_PRODUCT'] = 'glue-header__logo--product';
CssClasses['LOGO_CONTAINER'] = 'glue-header__logo-container';
CssClasses['LOGO_PRODUCT_CAMPAIGN'] = 'glue-header__logo--product-campaign';
CssClasses['LOGO_SVG'] = 'glue-header__logo-svg';
CssClasses['NO_DRAWER'] = 'glue-header-no-drawer';
CssClasses['STEPPED_NAV_ENABLE'] = 'glue-header-stepped-nav-enabled';
CssClasses['ACTIVE_MENU'] = 'glue-header--is-active';
CssClasses['ACTIVE_LINK'] = 'glue-header__item--active';
CssClasses['IS_ANIMATING'] = 'glue-is-animating';
CssClasses['BAR_DESKTOP'] = 'glue-header__bar--desktop';
CssClasses['BAR_MOBILE'] = 'glue-header__bar--mobile';
CssClasses['REWIND_SHADOW'] = 'glue-header--rewind-box-shadow';
CssClasses['HEADER_CONTAINER'] = 'glue-header__container';
CssClasses['HEADER_CONTAINER_LINKBAR'] = 'glue-header__container--linkbar';
CssClasses['HEADER_CONTAINER_CTA'] = 'glue-header__container--cta';
CssClasses['SKIP_BTN'] = 'glue-header__skip-content';
CssClasses['DEEP_NAV'] = 'glue-header__deep-nav';
CssClasses['TRANSPARENT'] = 'glue-header--transparent';
CssClasses['HOVERED'] = 'glue-header--hovered';
CssClasses['FOCUSED'] = 'glue-header--focused';
CssClasses['ACTIVE'] = 'glue-header--active';
CssClasses['TIER'] = 'glue-header__tier';
CssClasses['STACKED'] = 'glue-header--complex-stacked';
CssClasses['SIMPLE'] = 'glue-header--simple';
CssClasses['REVERSE'] = 'glue-header--reverse';
CssClasses['NO_CTA'] = 'glue-header--no-cta';
CssClasses['CTA'] = 'glue-header__cta';
CssClasses['SUPPLEMENTAL'] = 'glue-header__supplemental';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['MISSING_ROOT_ELEMENT'] =
    'No element with "glue-header class" was found. Header component needs a root element.';
Strings['MISSING_HEADER_BAR_ELEMENT'] =
    'No element with "glue-header__bar" class was found. This is required by Header component.';
Strings['MISSING_DRAWER_ELEMENT'] =
    'No element with "glue-header__drawer" class was found. This is required by Header component.';
Strings['MISSING_TOGGLE_BTN_ELEMENT'] =
    'No element with "glue-header__drawer-toggle-btn" class was found. This is required by Header component.';
Strings['MISSING_LINK_BAR_ELEMENT'] =
    'No element with "glue-header__link-bar" class was found. This is required by Header component.';
Strings['UNKNOWN_CUSTOM_BREAKPOINT'] =
    'Unknown custom breakpoint. Valid values are "md", "lg", or "xl".';
Strings['SCROLL_UP'] = 'up';
Strings['SCROLL_DOWN'] = 'down';
Strings['INCORRECT_TYPE'] = 'Incorrect data type';
Strings['SHOW_EVENT'] = 'glueheadershow';
Strings['HIDE_EVENT'] = 'glueheaderhide';
})(Strings || (Strings = {}));
var Numbers;
(function(Numbers) {
Numbers[Numbers['MAX_PAGE_OFFSET'] = 500] = 'MAX_PAGE_OFFSET';
Numbers[Numbers['ANIMATING_STATE_BUFFER'] = 20] = 'ANIMATING_STATE_BUFFER';
Numbers[Numbers['SCROLL_THRESHOLD'] = 50] = 'SCROLL_THRESHOLD';
Numbers[Numbers['POSITION_CHANGE_BUFFER'] = 300] = 'POSITION_CHANGE_BUFFER';
})(Numbers || (Numbers = {}));
var Icons;
(function(Icons) {
Icons['DOWN_ARROW'] = 'expand-more';
Icons['RIGHT_ARROW'] = 'chevron-right';
Icons['LEFT_ARROW'] = 'chevron-left';
Icons['HAMBURGER'] = 'menu';
})(Icons || (Icons = {}));



/***/ }),

/***/ "./_glue/lib/header/deepnav/constants.js":
/*!***********************************************!*\
  !*** ./_glue/lib/header/deepnav/constants.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
var Strings;
(function(Strings) {
Strings['ERROR_MSG_NO_CHILDREN'] = 'has no element children.';
Strings['ERROR_PREFIX'] = 'Menubar constructor argument el ';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/header/deepnav/index.js":
/*!*******************************************!*\
  !*** ./_glue/lib/header/deepnav/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Menubar: () => (/* binding */ Menubar)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./_glue/lib/header/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/deepnav/constants.js");
/* harmony import */ var _menubaritem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./menubaritem */ "./_glue/lib/header/deepnav/menubaritem.js");







/**
 * This class creates a navigation menu bar instance, each menu item may control
 * a dropdown sub menu.
 */
class Menubar extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root) {
    super(root);
    /** A collection of the menu items */
    this.menubarItems = [];
    /** A collection of the first characters of each menu item label */
    this.firstChars = [];
    /** The first  menu item. */
    this.firstItem = null;
    /** The last  menu item. */
    this.lastItem = null;
    /** A flag to show menubar's focus status. */
    this.hasFocus = false;
    /** A flag to show menubar's hover status. */
    this.hasHover = false;
    if (root.childElementCount === 0) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_3__.Strings.ERROR_PREFIX + _constants__WEBPACK_IMPORTED_MODULE_3__.Strings.ERROR_MSG_NO_CHILDREN);
    }
    this.init();
  }
  /**
   * Initializes the menubar component.
   * Throws an error if the menubar is empty.
   */
  init() {
    var _a;
    const listItems =
        this.root.querySelectorAll(`:scope > .${_constants__WEBPACK_IMPORTED_MODULE_2__.CssClasses.LIST_ITEM}`);
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.MENUBAR);
    for (const listItem of listItems) {
      listItem.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.NONE);
    }
    // Traverse the children elements and store reference in menuitems array.
    let elem = this.root.firstElementChild;
    let menubarItem;
    let menuElement;
    let textContent;
    while (elem) {
      menuElement = elem.firstElementChild;
      if (elem && menuElement instanceof HTMLAnchorElement) {
        menubarItem = new _menubaritem__WEBPACK_IMPORTED_MODULE_4__.MenubarItem(menuElement, this);
        this.menubarItems.push(menubarItem);
        textContent = (_a = menuElement.textContent) === null || _a === void 0 ?
            void 0 :
            _a.trim();
        if (textContent) {
          this.firstChars.push(textContent.substring(0, 1).toLowerCase());
        }
      }
      elem = elem.nextElementSibling;
    }
    const numItems = this.menubarItems.length;
    if (numItems > 0) {
      this.firstItem = this.menubarItems[0];
      this.lastItem = this.menubarItems[numItems - 1];
      this.firstItem.root.tabIndex = 0;
    }
  }
  destroy() {
    for (const item of this.menubarItems) {
      item.destroy();
    }
  }
  /**
   * Sets focus to the specified menu item.
   */
  setFocusToItem(newItem) {
    var _a;
    let isExpanded = false;
    for (const menubarItem of this.menubarItems) {
      if (menubarItem.root.tabIndex === 0) {
        isExpanded =
            menubarItem.root.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED) === 'true';
      }
      menubarItem.root.tabIndex = -1;
      (_a = menubarItem.popupMenu) === null || _a === void 0 ? void 0 :
                                                               _a.close();
    }
    newItem.root.focus();
    newItem.root.tabIndex = 0;
    if (isExpanded && newItem.popupMenu) {
      newItem.popupMenu.open();
    }
  }
  setFocusToFirstItem() {
    this.setFocusToItem(this.firstItem);
  }
  setFocusToLastItem() {
    this.setFocusToItem(this.lastItem);
  }
  /**
   * Sets focus to the previous menu item.
   * If the current item is the first menu item, move focus to the last
   * menu item.
   */
  setFocusToPreviousItem(currentItem) {
    let index;
    let newItem;
    if (currentItem === this.firstItem) {
      newItem = this.lastItem;
    } else {
      index = this.menubarItems.indexOf(currentItem);
      newItem = this.menubarItems[index - 1];
    }
    this.setFocusToItem(newItem);
  }
  /**
   * Sets focus to the next menu item.
   * If the current item is the last menu item, move focus to the first
   * menu item.
   */
  setFocusToNextItem(currentItem) {
    let index;
    let newItem;
    if (currentItem === this.lastItem) {
      newItem = this.firstItem;
    } else {
      index = this.menubarItems.indexOf(currentItem);
      newItem = this.menubarItems[index + 1];
    }
    this.setFocusToItem(newItem);
  }
  /**
   * Sets focus to the menu item based on the first Character.
   * Search matching label from the current item, if it hits the end,
   * start from the first item, vice versa.
   */
  setFocusByFirstCharacter(currentItem, char) {
    let start;
    let index;
    char = char.toLowerCase();
    start = this.menubarItems.indexOf(currentItem) + 1;
    if (start === this.menubarItems.length) {
      start = 0;
    }
    const findIndexFunc = (item, index) => {
      return item === char && index >= start;
    };
    index = this.firstChars.findIndex(findIndexFunc);
    if (index === -1) {
      start = 0;
      index = this.firstChars.findIndex(findIndexFunc);
    }
    if (index > -1) {
      this.setFocusToItem(this.menubarItems[index]);
    }
  }
}



/***/ }),

/***/ "./_glue/lib/header/deepnav/menubaritem.js":
/*!*************************************************!*\
  !*** ./_glue/lib/header/deepnav/menubaritem.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MenubarItem: () => (/* binding */ MenubarItem)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _popupmenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../popupmenu */ "./_glue/lib/header/popupmenu/index.js");





/**
 * This class creates a menu item instance, which may control a dropdown menu.
 */
class MenubarItem extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /** The menu argument is the menu bar element that contains this menu item. */
  constructor(root, parentMenu) {
    super(root);
    this.parentMenu = parentMenu;
    /** A popup menu component, controlled by the menu item. */
    this.popupMenu = null;
    /** A flag to show menu bar item's focus status. */
    this.hasFocus = false;
    /** A flag to show menu bar item's hover status. */
    this.hasHover = false;
    /**
     * This flag is used to determine if this controller is a menu bar item.
     * This flag is set to false in other controllers such as site switcher and
     * popup menu item.
     */
    this.isMenubarItem = true;
    /**
     * Handles keydown events.
     * - When press the Space, Enter or Down keys, open the menu if able and
     * focus to the first item.
     * - When press the Up key, open the popup menu if able and focus to the
     * last item.
     * - When press the left key, move focus to the previous menu item.
     * - When press the right key, move focus to the next menu item.
     * - When press the Home or PageUp key, move focus to the first item.
     * - When press the End or PageDown key, move focus to the last item.
     * - When press the Tab key, close the popup menu, and move focus to the
     * next focusable element.
     * - When press the ESC key, close the popup menu, move focus to the
     * controller.
     */
    this.handleKeydown = (event) => {
      var _a, _b;
      const char = event.key;
      let preventDefault = false;
      function isPrintableCharacter(str) {
        return str.length === 1 && str.match(/\S/);
      }
      switch (event.key) {
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.DOWN:
          if (this.popupMenu) {
            this.popupMenu.open();
            this.popupMenu.setFocusToFirstItem();
            preventDefault = true;
          }
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.LEFT:
          this.parentMenu.setFocusToPreviousItem(this);
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.RIGHT:
          this.parentMenu.setFocusToNextItem(this);
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.UP:
          if (this.popupMenu) {
            this.popupMenu.open();
            this.popupMenu.setFocusToLastItem();
            preventDefault = true;
          }
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.HOME:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.PAGEUP:
          this.parentMenu.setFocusToFirstItem();
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.END:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.PAGEDOWN:
          this.parentMenu.setFocusToLastItem();
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.TAB:
          (_a = this.popupMenu) === null || _a === void 0 ? void 0 :
                                                            _a.close(true);
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ESC:
          (_b = this.popupMenu) === null || _b === void 0 ? void 0 :
                                                            _b.close(true);
          break;
        default:
          if (isPrintableCharacter(char)) {
            this.parentMenu.setFocusByFirstCharacter(this, char);
            preventDefault = true;
          }
          break;
      }
      if (preventDefault) {
        event.stopPropagation();
        event.preventDefault();
      }
    };
    /** Sets expanded attribute. */
    this.setExpanded = (flag) => {
      if (flag) {
        this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'true');
      } else {
        this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'false');
      }
    };
    /** Sets hasFocus to true when the menu item is in focus. */
    this.handleFocus = () => {
      this.parentMenu.hasFocus = true;
    };
    /** Sets hasFocus to false when the menu item is blurred. */
    this.handleBlur = () => {
      this.parentMenu.hasFocus = false;
    };
    /**
     * When the menu item in hovered, set hasHover to true and open the
     * popupmenu if able.
     */
    this.handleMouseenter = () => {
      var _a;
      this.hasHover = true;
      (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.open();
    };
    /**
     * When the mouse is moved away from the menu item, set hasHover to false
     * and close the popupmenu after 300 mills.
     */
    this.handleMouseleave = () => {
      this.hasHover = false;
      setTimeout(() => {
        var _a;
        (_a = this.popupMenu) === null || _a === void 0 ? void 0 :
                                                          _a.close(false);
      }, 300);
    };
    this.init();
  }
  /**
   * Initializes the menu item and the associated popup menu.
   */
  init() {
    this.root.tabIndex = -1;
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.MENUITEM);
    const nextElement = this.root.nextElementSibling;
    if (nextElement instanceof HTMLUListElement) {
      this.popupMenu = new _popupmenu__WEBPACK_IMPORTED_MODULE_4__.PopupMenu(nextElement, this);
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HASPOPUP, 'true');
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus);
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.BLUR, this.handleBlur);
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseleave);
    }
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
  }
  destroy() {
    var _a;
    (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.destroy();
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HASPOPUP);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.BLUR, this.handleBlur);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseleave);
  }
}



/***/ }),

/***/ "./_glue/lib/header/drawer/constants.js":
/*!**********************************************!*\
  !*** ./_glue/lib/header/drawer/constants.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Header component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-header__drawer';
CssClasses['DRAWER_IS_OPEN'] = 'glue-header__drawer--is-open';
CssClasses['TOGGLE_BTN'] = 'glue-header__drawer-toggle-btn';
CssClasses['IS_ANIMATING'] = 'glue-is-animating';
CssClasses['GLUE_BUTTON'] = 'glue-button';
CssClasses['NO_SCROLL'] = 'glue-no-scroll';
CssClasses['BACKDROP'] = 'glue-header__drawer-backdrop';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['MISSING_DRAWER_ELEMENT'] =
    'No element with "glue-header__drawer" class was found. Drawer component needs a root element.';
Strings['MISSING_BACKDROP_ELEMENT'] =
    'No element with "glue-header__drawer-backdrop" class was found.';
Strings['OPEN'] = 'glueHeaderDrawerOpen';
Strings['CLOSE'] = 'glueHeaderDrawerClose';
Strings['TOGGLE_BTN'] = 'toggleBtn';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/header/drawer/index.js":
/*!******************************************!*\
  !*** ./_glue/lib/header/drawer/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Drawer: () => (/* binding */ Drawer)
/* harmony export */ });
/* harmony import */ var _base___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/ */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _focus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../focus */ "./_glue/lib/focus/index.js");
/* harmony import */ var _math_coordinate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/coordinate */ "./_glue/lib/math/coordinate.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/drawer/constants.js");









class Drawer extends _base___WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The element that contains options object.
   * @param toggleEl The element that toggles the drawer open and closed.
   */
  constructor(root, toggleEl) {
    var _a;
    super(root);
    this.toggleEl = toggleEl;
    this.closed = true;
    this.isAnimating = false;
    this.ariaHiddenElements = [];
    this.focusableElements = [];
    /** Start time of the drag movement */
    this.startTime = 0;
    /** Initial touch position */
    this.initialTouchPos = null;
    /** Last touch poistion */
    this.lastTouchPos = null;
    /** True when it is ready to call request animatino frame */
    this.rafPending = false;
    this.handleGestureStart = (event) => {
      // Returns if there are multi touch points.
      if (this.isTouchEvent(event) && event.touches.length > 1) {
        return;
      }
      // Add the move and end listeners if PointerEvent is supported.
      // Otherwise add mouse listeners.
      if (this.isPointerEvent(event) && event.target instanceof Element) {
        event.target.setPointerCapture(event.pointerId);
      } else {
        document.addEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEMOVE, this.handleGestureMove, true);
        document.addEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEUP, this.handleGestureEnd, true);
      }
      this.initialTouchPos = this.getGesturePointFromEvent(event);
      this.startTime = new Date().getTime();
      // Overwrites the transition value set up in CSS
      this.root.style.transition = 'initial';
    };
    this.handleGestureMove = (event) => {
      event.preventDefault();
      if (!this.initialTouchPos) {
        return;
      }
      // Prevent small taps/etc triggering a dragging interaction
      const currentTouchPos = this.getGesturePointFromEvent(event);
      const distanceDragged = Math.abs(
          _math_coordinate__WEBPACK_IMPORTED_MODULE_5__.Coordinate.difference(currentTouchPos, this.initialTouchPos).x);
      if (distanceDragged < 10) {
        return;
      }
      this.lastTouchPos = currentTouchPos;
      // Returns if it is waiting for request animation frame callback.
      if (this.rafPending) {
        return;
      }
      this.rafPending = true;
      window.requestAnimationFrame(() => {
        this.onAnimFrame();
      });
    };
    this.handleGestureEnd = (event) => {
      var _a;
      event.preventDefault();
      if (this.isTouchEvent(event) &&
          ((_a = event.touches) === null || _a === void 0 ? void 0 :
                                                            _a.length) > 0) {
        return;
      }
      this.rafPending = false;
      // Remove Event Listeners
      if (this.isPointerEvent(event) && event.target instanceof Element) {
        event.target.releasePointerCapture(event.pointerId);
      } else {
        // Remove Mouse Listeners
        document.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEMOVE, this.handleGestureMove, true);
        document.removeEventListener(
            _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEUP, this.handleGestureEnd, true);
      }
      this.updateDrawerPosition();
      // Resets drag status
      this.startTime = 0;
      this.initialTouchPos = null;
      this.lastTouchPos = null;
    };
    // Check class names
    if (!this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.ROOT)) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_DRAWER_ELEMENT);
    }
    this.setAttributes();
    const element = (_a = this.root.parentElement) === null || _a === void 0 ?
        void 0 :
        _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.BACKDROP}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_BACKDROP_ELEMENT);
    }
    this.backdrop = element;
    this.transitionEndHandler = () => {
      this.handleTransitionEndEvent();
    };
    this.handleKeydown = (event) => {
      if (event.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.TAB) {
        // Move focus back to the root.
        this.root.focus();
        return;
      }
      event.preventDefault();
      if (event.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER) {
        this.close();
      }
    };
    this.handleOpen = () => {
      document.body.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.NO_SCROLL);
      document.documentElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.NO_SCROLL);
      this.backdrop.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    };
    this.handleClose = () => {
      document.body.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.NO_SCROLL);
      document.documentElement.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.NO_SCROLL);
      this.backdrop.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    };
    // CSS Animation event handlers
    this.root.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.transitionEndHandler);
    // Adding and removing body no scroll class
    document.body.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.OPEN, this.handleOpen);
    document.body.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.CLOSE, this.handleClose);
  }
  registerTouchEvents() {
    if (window.PointerEvent) {
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERDOWN, this.handleGestureStart, true);
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERMOVE, this.handleGestureMove, true);
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERUP, this.handleGestureEnd, true);
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERCANCEL, this.handleGestureEnd, true);
    } else {
      // Add Touch Listener
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHSTART, this.handleGestureStart, true);
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHMOVE, this.handleGestureMove, true);
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHEND, this.handleGestureEnd, true);
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHCANCEL, this.handleGestureEnd, true);
      // Add Mouse Listener
      this.root.addEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEDOWN, this.handleGestureStart, true);
    }
  }
  deregisterTouchEvents() {
    if (window.PointerEvent) {
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERDOWN, this.handleGestureStart, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERMOVE, this.handleGestureMove, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERUP, this.handleGestureEnd, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.POINTERCANCEL, this.handleGestureEnd, true);
    } else {
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHSTART, this.handleGestureStart, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHMOVE, this.handleGestureMove, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHEND, this.handleGestureEnd, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TOUCHCANCEL, this.handleGestureEnd, true);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEDOWN, this.handleGestureStart, true);
    }
  }
  destroy() {
    this.deregisterTouchEvents();
    this.root.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.transitionEndHandler);
    document.body.removeEventListener(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.OPEN, this.handleOpen);
    document.body.removeEventListener(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.CLOSE, this.handleClose);
  }
  /** Determines whether the event is a TouchEvent. */
  isTouchEvent(event) {
    return window.TouchEvent && event instanceof TouchEvent;
  }
  /** Determines whether the event is a PointerEvent. */
  isPointerEvent(event) {
    return window.PointerEvent && event instanceof PointerEvent;
  }
  // Transits the drawer based on the last touch position.
  // Drag to right should do nothing.
  onAnimFrame() {
    if (!this.rafPending || !this.initialTouchPos || !this.lastTouchPos) {
      return;
    }
    const differenceInX =
        _math_coordinate__WEBPACK_IMPORTED_MODULE_5__.Coordinate.difference(this.lastTouchPos, this.initialTouchPos).x;
    // Do thing if move to right
    if (differenceInX > 0) {
      this.root.style.transform = '';
    } else {
      const transformStyle = `translate3d(${differenceInX}px, 0, 0)`;
      this.root.style.transform = transformStyle;
    }
    this.rafPending = false;
  }
  getGesturePointFromEvent(event) {
    const point = new _math_coordinate__WEBPACK_IMPORTED_MODULE_5__.Coordinate(0, 0);
    if (this.isTouchEvent(event)) {
      if (event.targetTouches) {
        point.x = event.targetTouches[0].clientX;
        point.y = event.targetTouches[0].clientY;
      }
    } else {
      point.x = event.clientX;
      point.y = event.clientY;
    }
    return point;
  }
  updateDrawerPosition() {
    // Resets the inline styles so the CSS transition style takes in charge
    // During the drag phase, inline transition style overwrites the CSS
    // transition.
    this.root.style.transition = '';
    this.root.style.transform = '';
    if (!this.lastTouchPos || !this.initialTouchPos) return;
    const differenceInX =
        _math_coordinate__WEBPACK_IMPORTED_MODULE_5__.Coordinate.difference(this.lastTouchPos, this.initialTouchPos).x;
    const validDrag = Math.abs(differenceInX) >= this.root.clientWidth * 0.5;
    const currentTime = new Date().getTime();
    const duration = currentTime - this.startTime;
    const validSwipe = duration < 300 && Math.abs(differenceInX) > 10;
    if (validDrag || validSwipe) {
      this.close();
    }
  }
  /**
   * Opens the drawer
   */
  open() {
    if (this.closed && !this.isAnimating) {
      this.isAnimating = true;
      this.emit(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.OPEN, {}, true);
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.DRAWER_IS_OPEN);
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_ANIMATING);
      this.setDefaultAttrs();
      // set aria-expanded property of button to true while opening drawer
      this.toggleEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'true');
      this.backdrop.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, 'button');
      this.backdrop.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE;
      this.removeAriaHidden();
      this.ariaHideElements();
      this.root.focus();
      this.removeKeyboardFocus();
      this.registerTouchEvents();
    }
  }
  /**
   * Removes keyboard focus from all the focusable elements outside the drawer.
   */
  removeKeyboardFocus() {
    const focusable = (0,_focus__WEBPACK_IMPORTED_MODULE_4__.getFocusableElements)(window.document.body);
    this.focusableElements = [];
    for (const el of focusable) {
      if (!this.root.contains(el) && !this.backdrop.contains(el) &&
          el.tabIndex !== -1) {
        this.focusableElements.push(el);
        el.tabIndex = -1;
      }
    }
  }
  /**
   * Adds keyboard focus for all the focusable elements outside the drawer.
   */
  addKeyboardFocus() {
    for (const el of this.focusableElements) {
      el.removeAttribute('tabindex');
    }
  }
  /**
   * Closes the drawer and sets the focus to the toggle btn.
   */
  close() {
    if (!this.closed && !this.isAnimating) {
      this.isAnimating = true;
      this.emit(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.CLOSE, {}, true);
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_ANIMATING);
      this.removeDefaultAttrs();
      // set aria-expanded property of button  to false while closing drawer
      this.toggleEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'false');
      this.toggleEl.focus();
      this.setAriaHidden();
      this.ariaUnhideElements();
      this.addKeyboardFocus();
      if (this.backdrop) {
        this.backdrop.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
        this.backdrop.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
      }
      this.deregisterTouchEvents();
    }
  }
  setAttributes() {
    if (!this.root.id) {
      const randomId = Math.round(Math.random() * 99999999).toString(16);
      this.root.id = `glue-drawer-${randomId}`;
    }
    this.toggleEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.root.id);
    this.toggleEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'false');
    this.toggleEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HASPOPUP, 'true');
  }
  /**
   * Check to see if drawer is open
   */
  isOpen() {
    return this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.DRAWER_IS_OPEN);
  }
  /**
   * Check to see if the event target is a child element of the drawer component
   */
  containsElement(event) {
    return event.target instanceof Node && this.root.contains(event.target);
  }
  /**
   * Check to see if the event target is a child element of the drawer component
   */
  isCtaElement(event) {
    return (
        event.target instanceof Element &&
        event.target.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.GLUE_BUTTON));
  }
  /**
   * This method will take care of any logic that needs to run after the CSS
   * transition has ended.
   */
  handleTransitionEndEvent() {
    if (this.isAnimating) {
      this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_ANIMATING);
      if (this.closed) {
        this.closed = false;
      } else {
        this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.DRAWER_IS_OPEN);
        this.closed = true;
      }
      this.isAnimating = false;
    }
  }
  /**
   * This method will remove applied aria attributes
   */
  removeAriaHidden() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
  }
  /**
   * This method will set aria attributes
   */
  setAriaHidden() {
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
  }
  /**
   * This method sets default attributes when the drawer is opened
   */
  setDefaultAttrs() {
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL, 'Navigation drawer');
    this.root.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE;
  }
  /**
   * This method removes default attributes when the drawer is closed
   */
  removeDefaultAttrs() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
  }
  /**
   * Set aria hidden to true for all other elements.
   * This method provides complementary A11y support before aria-modal
   * The code is referenced from
   * https://source.corp.google.com/piper///depot/google3/googledata/html/external_content/scs_corp/ariablueprints/dialog/dialog-modal-1.0.html;l=81-101
   * gets broader browser support.
   */
  ariaHideElements() {
    let current = this.root;
    while (current && current.parentNode) {
      for (const child of Array.from(current.parentNode.children)) {
        if (child !== current && child !== this.backdrop &&
            child.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN) !== 'true') {
          this.ariaHiddenElements.push(child);
          child.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
        }
      }
      current = current.parentNode;
    }
  }
  /**
   * Remove aria hidden to false for all other elements.
   */
  ariaUnhideElements() {
    this.ariaHiddenElements.forEach((el) => {
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
    });
    this.ariaHiddenElements = [];
  }
}



/***/ }),

/***/ "./_glue/lib/header/index.js":
/*!***********************************!*\
  !*** ./_glue/lib/header/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Header: () => (/* binding */ Header)
/* harmony export */ });
/* harmony import */ var _base___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _responsivemonitor___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../responsivemonitor/ */ "./_glue/lib/responsivemonitor/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/constants.js");
/* harmony import */ var _deepnav___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./deepnav/ */ "./_glue/lib/header/deepnav/index.js");
/* harmony import */ var _drawer___WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawer/ */ "./_glue/lib/header/drawer/index.js");
/* harmony import */ var _drawer_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./drawer/constants */ "./_glue/lib/header/drawer/constants.js");
/* harmony import */ var _siteswitcher___WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./siteswitcher/ */ "./_glue/lib/header/siteswitcher/index.js");
/* harmony import */ var _siteswitcher_constants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./siteswitcher/constants */ "./_glue/lib/header/siteswitcher/constants.js");
/* harmony import */ var _steppednav___WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./steppednav/ */ "./_glue/lib/header/steppednav/index.js");














/**
 * Glue Header Component
 */
class Header extends _base___WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, headerOptions) {
    super(root);
    this.isAnimating = false;
    this.scrolling = false;
    this.lastPositionY = 0;
    this.atTopOfPage = true;
    this.allowTransitionEndEvent = false;
    this.isTransparent = false;
    /**
     * This flag needs to be set to true. This is needed to block a scroll event
     * on reload and adds box shadow to the header.
     */
    this.blockFalseScroll = true;
    /**
     * Handler for key down events
     */
    this.keydownHandler = (e) => {
      var _a, _b;
      const isEscape = e.key === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ESC;
      if (this.options.drawer) {
        if (((_a = this.drawer) === null || _a === void 0 ? void 0 :
                                                            _a.isOpen()) &&
            isEscape) {
          (_b = this.drawer) === null || _b === void 0 ? void 0 : _b.close();
        }
      }
    };
    /**
     * Handler for mouseover event. This will add an active class so we can put
     * the default header styles back for transparent header.
     */
    this.handleMouseOver = (e) => {
      if (this.root === e.target || this.containsElement(e)) {
        this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE);
      }
    };
    /**
     * Handler for mouseleave event. This will remove active class, this is used
     * only for the transparent header variation.
     */
    this.handleMouseLeave = (e) => {
      !this.root.matches(':focus-within') &&
          !this.activeBarElement.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.REWIND_SHADOW) &&
          this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE);
    };
    /**
     * Handler for header focus event. This adds an acive class to the header
     * it's currently focused. We have to add a class due to the face that, the
     * peudo selector ':focus-within' doesn't work with :not(), this is a better
     * solution.
     */
    this.handleFocus = () => {
      if (this.root.matches(':focus-within')) {
        this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE);
      } else {
        !this.activeBarElement.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.REWIND_SHADOW) &&
            this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE);
      }
    };
    /**
     * Handles focus within state. Used to reshow header for keyboard users are
     * trying to navigate back to the header
     */
    this.handleFocusWithin = () => {
      this.show();
    };
    if (!this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ROOT)) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.MISSING_ROOT_ELEMENT);
    }
    this.options = Object.assign(
        {}, Header.defaultOptions, headerOptions, this.getOptions());
    // Set up breakpoints array for responsive monitor
    switch (this.options.breakpoint) {
      case 'md':
        this.breakpointsMobileNav = ['sm'];
        break;
      case 'lg':
        this.breakpointsMobileNav = ['sm', 'md'];
        break;
      case 'xl':
        this.breakpointsMobileNav = ['sm', 'md', 'lg'];
        break;
      default:  // unknown breakpoint value
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.UNKNOWN_CUSTOM_BREAKPOINT);
    }
    this.initialize();
    this.initializeNavigationSubcomponents();
    this.responsiveMonitorInit();
  }
  /**
   * Default Header options.
   */
  static get defaultOptions() {
    return {
      breakpoint: 'lg',
      drawer: true,
      hideOnScroll: true,
      steppedNav: false,
    };
  }
  /**
   * Initialize Drawer and Bar
   */
  initialize() {
    var _a, _b;
    this.headerBar = this.getHeaderBarElement();
    this.headerBarMobile = this.getHeaderBarElement(true);
    this.activeBarElement = this.getActiveBarElement();
    if (this.options.drawer) {
      const drawerEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.DRAWER_EL}`);
      const linkBarEl = (_a = this.headerBar) === null || _a === void 0 ?
          void 0 :
          _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.LINK_BAR}`);
      // Throw exception if element is missing
      if (drawerEl === null) {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.MISSING_DRAWER_ELEMENT);
      } else if (linkBarEl === null) {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.MISSING_LINK_BAR_ELEMENT);
      }
      this.toggleBtnEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.TOGGLE_BTN}`);
      // Throw exception if element is missing
      if (this.toggleBtnEl === null) {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.MISSING_TOGGLE_BTN_ELEMENT);
      }
      this.drawer = new _drawer___WEBPACK_IMPORTED_MODULE_7__.Drawer(drawerEl, this.toggleBtnEl);
    } else {
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.NO_DRAWER);
    }
    this.setPositionStyle();
    this.setActiveBarPosition(this.headerBar.style.position);
    // Set required attributes
    // Add aria attrs
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, `false`);
    // Bind handlers
    this.handleClick = (e) => {
      this.clickHandler(e);
    };
    this.handleKeydown = (e) => {
      this.keydownHandler(e);
    };
    this.handleScroll = () => {
      this.scrollThrottlerHandler();
    };
    this.handleDrawOpen = () => {
      this.handleDrawerOpenEvent();
    };
    this.handleDrawClose = () => {
      this.handleDrawerCloseEvent();
    };
    this.handleTransitionEnd = () => {
      this.handleTransitionEndEvent();
    };
    // Event listeners
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS_IN, this.handleFocusWithin);
    // DRAWER
    this.options.drawer &&
        this.root.addEventListener(_drawer_constants__WEBPACK_IMPORTED_MODULE_8__.Strings.OPEN, this.handleDrawOpen);
    this.options.drawer &&
        this.root.addEventListener(_drawer_constants__WEBPACK_IMPORTED_MODULE_8__.Strings.CLOSE, this.handleDrawClose);
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.SCROLL, this.handleScroll);
    this.headerBar.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnd);
    this.headerBarMobile.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnd);
    if (this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.TRANSPARENT)) {
      this.isTransparent = true;
      this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.DOUBLE) &&
          ((_b = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE_MENU} > a`)) ===
                       null ||
                   _b === void 0 ?
               void 0 :
               _b.appendChild(document.createElement('div')));
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEOVER, this.handleMouseOver);
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseLeave);
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS_IN, this.handleFocus);
      this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS_OUT, this.handleFocus);
    }
    this.injectVersion();
  }
  injectVersion() {
    document.documentElement.dataset['glue'] = 'glue@28.2.0';
  }
  /**
   * Initialize SteppedNav, DeepNav and SiteSwitcher.
   */
  initializeNavigationSubcomponents() {
    // Init the popovers for deep nav and site switcher if present.
    const siteSwitcherElem =
        this.root.querySelector(`.${_siteswitcher_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.COMPONENT}`);
    if (siteSwitcherElem) {
      this.siteSwitcher = new _siteswitcher___WEBPACK_IMPORTED_MODULE_9__.SiteSwitcher(siteSwitcherElem);
    }
    const menuBar = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.DEEP_NAV}`);
    if (menuBar) {
      this.deepNav = new _deepnav___WEBPACK_IMPORTED_MODULE_6__.Menubar(menuBar);
    }
    // Init the Stepped Nav if the option is on and the element is present.
    if (this.options.steppedNav) {
      const steppedNavElem = _steppednav___WEBPACK_IMPORTED_MODULE_11__.SteppedNav.getSteppedNavElement(this.root);
      if (steppedNavElem) {
        this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.STEPPED_NAV_ENABLE);
        // If there is a failure to init the stepped nav, just fail back to
        // the standard nav.
        try {
          this.steppedNav = new _steppednav___WEBPACK_IMPORTED_MODULE_11__.SteppedNav(steppedNavElem);
        } catch (error) {
          this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.STEPPED_NAV_ENABLE);
          throw error;
        }
      }
    }
  }
  destroy() {
    var _a, _b, _c;
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS_IN, this.handleFocusWithin);
    this.headerBar.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnd);
    this.headerBarMobile.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnd);
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.SCROLL, this.handleScroll);
    // Cancel the animation frame
    window.cancelAnimationFrame(this.animationsFrameId);
    this.rm.unlisten((size) => {
      if (this.breakpointsMobileNav.includes(size)) {
        this.setActiveBarPosition();
      }
    });
    this.rm.destroy();
    if (this.options.drawer) {
      this.root.removeEventListener(_drawer_constants__WEBPACK_IMPORTED_MODULE_8__.Strings.OPEN, this.handleDrawOpen);
      this.root.removeEventListener(_drawer_constants__WEBPACK_IMPORTED_MODULE_8__.Strings.CLOSE, this.handleDrawClose);
      (_a = this.drawer) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    (_b = this.siteSwitcher) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.deepNav) === null || _c === void 0 ? void 0 : _c.destroy();
    if (this.steppedNav) this.steppedNav.destroy();
    if (this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.TRANSPARENT)) {
      this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEOVER, this.handleMouseOver);
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseLeave);
      this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS_IN, this.handleFocus);
      this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS_OUT, this.handleFocus);
    }
  }
  /**
   * Get the options passed or returns the default options
   */
  getOptions() {
    const options = {};
    for (const option of Object.keys(Header.defaultOptions)) {
      const attr =
          `glueHeader${option.toUpperCase().slice(0, 1)}${option.slice(1)}`;
      if (this.root.dataset[attr] === 'true' ||
          this.root.dataset[attr] === 'false') {
        options[option] = this.root.dataset[attr] === 'true';
      } else {
        if (this.root.dataset[attr]) {
          options[option] = this.root.dataset[attr];
        }
      }
    }
    return options;
  }
  /**
   * Handles the event delegation for the click handlers on the root element.
   */
  clickHandler(e) {
    var _a, _b, _c, _d, _e, _f;
    if (this.options.drawer) {
      if ((_a = this.drawer) === null || _a === void 0 ? void 0 : _a.isOpen()) {
        if (!((_b = this.drawer) === null || _b === void 0 ?
                  void 0 :
                  _b.containsElement(e))) {
          (_c = this.drawer) === null || _c === void 0 ? void 0 : _c.close();
        } else if (
            (_d = this.drawer) === null || _d === void 0 ? void 0 :
                                                           _d.isCtaElement(e)) {
          (_e = this.drawer) === null || _e === void 0 ? void 0 : _e.close();
        }
      } else {
        if (this.toggleBtnEl.contains(e.target)) {
          (_f = this.drawer) === null || _f === void 0 ? void 0 : _f.open();
        }
      }
    }
  }
  /**
   * Checks to see if the event target is a child of the root element.
   */
  containsElement(event) {
    return event.target instanceof Node && this.root.contains(event.target);
  }
  /**
   * This is to throttle the scrolling logic with window.requestAnimationFrame.
   * this is also using a requestAnimationFrame to help with performance.
   */
  scrollThrottlerHandler() {
    if (!this.scrolling) {
      this.animationsFrameId = window.requestAnimationFrame(() => {
        this.scrollHandler();
        this.scrolling = false;
      });
      this.scrolling = true;
    }
  }
  /**
   * Called via window.requestAnimationFrame, this helps check state
   * in a more accurate way and helps avoid getting lock in an incorrect
   * position.
   */
  scrollHandler() {
    const hasScrolledClass =
        this.activeBarElement.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.WHOLLY_SCROLLED);
    // Get the direction
    const direction = this.getScrollDirection();
    // Need to set a threshold to avoid browser elastic scrolling triggering
    // nav hide
    const nearBottom =
        document.body.clientHeight - window.scrollY - window.innerHeight <=
        _constants__WEBPACK_IMPORTED_MODULE_5__.Numbers.SCROLL_THRESHOLD;
    const scrollingDown = direction === _constants__WEBPACK_IMPORTED_MODULE_5__.Strings.SCROLL_DOWN;
    const scrollingUp = direction === _constants__WEBPACK_IMPORTED_MODULE_5__.Strings.SCROLL_UP;
    // Will hide the nav once it haves the scroll class and scrolling down
    if (!this.atTopOfPage && scrollingDown && !hasScrolledClass &&
        !this.isAnimating) {
      // Hide the nav after scrolling down to pass the nav element.
      if (window.scrollY > this.activeBarElement.clientHeight) {
        this.hide();
      }
      // This is for scrolling up and not at the top of the page. We also block
      // the elastic recoil causing a scroll up to fire.
    } else if (
        !this.atTopOfPage && scrollingUp && hasScrolledClass &&
        !this.isAnimating && !nearBottom) {
      // This fix a bug in some mobile safari browsers. It randomly causes
      // this block to run while scrolling down
      if (this.lastPositionY - window.scrollY !== 0) {
        this.show();
      }
      // This is for preventing the nav from getting lock in a hidden state.
    } else if (this.atTopOfPage && !this.isAnimating && hasScrolledClass) {
      this.show();
    }
    this.atTopOfPage = window.scrollY <= 0;
    this.lastPositionY = window.scrollY;
    // There is still a bug where scroll events are incorrectly being fired. We
    // need to block this from causing rewind shadow being added
    this.blockFalseScroll = false;
    // Apply box shadow on header bar element.
    this.rewindBoxShadow();
    // This ensures that the position is correct when at the top of the page.
    // Because of fast resizing and scrolling the Nav gets stuck with the wrong
    // position.
    this.atTopOfPage && this.setActiveBarPosition();
    this.isTransparent && this.setTransparentActiveClass();
    // This is a fail-safe, last check to see if that state has changed whilst
    // animating. This is the main cause of header issues.
    if (this.isAnimating && window.scrollY <= _constants__WEBPACK_IMPORTED_MODULE_5__.Numbers.MAX_PAGE_OFFSET) {
      window.requestAnimationFrame(() => {
        this.scrollThrottlerHandler();
      });
    }
  }
  /**
   * Need to reset the position of the desktop header bar. This needs to be
   * reset to avoid issues with the drawer.
   */
  resetDesktopHeaderPosition() {
    const {display} = window.getComputedStyle(this.headerBarMobile);
    // Reset drawer
    if (display === 'block') {
      this.headerBar.style.top = '0';
      this.headerBar.style.position = 'fixed';
    } else {
      this.headerBar.style.position = 'static';
    }
  }
  /**
   * Set initial headerBar position style based on the scroll position.
   */
  setPositionStyle() {
    if (window.scrollY > this.activeBarElement.clientHeight) {
      this.headerBar.style.position = 'fixed';
    } else {
      this.headerBar.style.position = 'static';
    }
  }
  /**
   * The active class adds the normal styles back to the header, which is
   * anytime the header is not at the top of the page. So when the @root element
   * has position set to 'static' and atthe top of the page is the only time it
   * will be transparent.
   */
  setTransparentActiveClass() {
    if (window.scrollY > this.activeBarElement.clientHeight) {
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE);
    } else {
      !this.root.matches(':focus-within') &&
          this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE);
    }
  }
  /**
   * Update the position of the active header element, needed for animation.
   * position should be 'static' at the top of the page and 'fixed' once
   * scrolled
   * @param pos position to be set on the active bar element
   */
  setActiveBarPosition(pos = 'static') {
    if (!this.options.hideOnScroll) {
      pos = 'fixed';
    }
    const activeEl = this.activeBarElement;
    const {display} = window.getComputedStyle(this.headerBarMobile);
    display === 'block' && this.resetDesktopHeaderPosition();
    if (pos === 'static') {
      activeEl.style.top = `-${activeEl.clientHeight}px`;
    } else {
      setTimeout(() => {
        activeEl.style.top = (0).toString();
      }, _constants__WEBPACK_IMPORTED_MODULE_5__.Numbers.POSITION_CHANGE_BUFFER);
    }
    activeEl.style.position = pos;
  }
  /**
   * Check if root has the correct child element, which is required for
   * animations. There are two bar elements for desktop and mobile
   */
  getHeaderBarElement(isMobile = false) {
    const filterByStr =
        isMobile ? _constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.BAR_MOBILE : _constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.BAR_DESKTOP;
    const headerBarEl =
        Array.from(this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.BAR}`))
            .filter((item) => item.classList.contains(filterByStr));
    if (!headerBarEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.MISSING_HEADER_BAR_ELEMENT);
    }
    return headerBarEl[0];
  }
  /**
   * Some classes need to be removed form the DOM when the close event is
   * emitted from the Drawer component
   */
  handleDrawerCloseEvent() {
    this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.DRAWER_IS_SHOWN);
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'false');
  }
  /**
   * Some classes need to be added to the DOM when the open event is emitted
   * from the drawer component
   */
  handleDrawerOpenEvent() {
    this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.DRAWER_IS_SHOWN);
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'true');
  }
  /**
   * This method will take care of any logic that needs to run after the CSS
   * transition has ended
   */
  handleTransitionEndEvent() {
    if (this.allowTransitionEndEvent) {
      this.isAnimating = false;
      this.allowTransitionEndEvent = false;
      this.activeBarElement.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.IS_ANIMATING);
    }
  }
  /**
   * The drawer needs to be closed if the window is resized to desktop and
   * drawer is left open
   */
  responsiveMonitorInit() {
    this.rm = new _responsivemonitor___WEBPACK_IMPORTED_MODULE_4__.ResponsiveMonitor({
      breakpoint: this.breakpointsMobileNav,
      enter: () => {
        var _a, _b, _c;
        this.activeBarElement = this.getActiveBarElement();
        this.setActiveBarPosition();
        (_a = this.drawer) === null || _a === void 0 ? void 0 :
                                                       _a.setAriaHidden();
        (_b = this.siteSwitcher) === null || _b === void 0 ? void 0 :
                                                             _b.destroy();
        (_c = this.deepNav) === null || _c === void 0 ? void 0 : _c.destroy();
      },
      leave: () => {
        var _a, _b, _c, _d, _e;
        if (this.options.drawer &&
            ((_a = this.drawer) === null || _a === void 0 ? void 0 :
                                                            _a.isOpen())) {
          (_b = this.drawer) === null || _b === void 0 ? void 0 : _b.close();
        }
        (_c = this.drawer) === null || _c === void 0 ? void 0 :
                                                       _c.removeAriaHidden();
        this.activeBarElement = this.getActiveBarElement();
        this.setActiveBarPosition();
        (_d = this.siteSwitcher) === null || _d === void 0 ? void 0 : _d.init();
        (_e = this.deepNav) === null || _e === void 0 ? void 0 : _e.init();
      },
    });
    // RM needs to trigger on resize, not just on enter.
    this.rm.listen((size) => {
      if (this.breakpointsMobileNav.includes(size)) {
        this.setActiveBarPosition();
      }
    });
  }
  /**
   * Get scroll direction
   */
  getScrollDirection() {
    return this.lastPositionY >= window.scrollY ? _constants__WEBPACK_IMPORTED_MODULE_5__.Strings.SCROLL_UP :
                                                  _constants__WEBPACK_IMPORTED_MODULE_5__.Strings.SCROLL_DOWN;
  }
  /**
   * Will hide the nav and add the animation class.
   */
  hide() {
    if (!this.options.hideOnScroll) return;
    this.isAnimating = true;
    this.allowTransitionEndEvent = true;
    this.activeBarElement.classList.add(
        _constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.WHOLLY_SCROLLED, _constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.IS_ANIMATING);
    this.setActiveBarPosition('fixed');
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.HIDE_EVENT, {});
  }
  /**
   * Will show the nav and add the animation class. Will also remove the
   * scroll class
   */
  show() {
    if (!this.options.hideOnScroll) return;
    this.isAnimating = true;
    this.allowTransitionEndEvent = true;
    // Add animation class to header-bar elements
    this.activeBarElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.IS_ANIMATING);
    // Remove Scrolled class to header-bar elements
    this.activeBarElement.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.WHOLLY_SCROLLED);
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.SHOW_EVENT, {});
  }
  /**
   * On rewind add the box shadow class but remove it once you reach the top of
   * the page
   */
  rewindBoxShadow() {
    if (this.atTopOfPage) {
      this.activeBarElement.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.REWIND_SHADOW);
    } else if (
        !this.atTopOfPage && !this.isAnimating && !this.blockFalseScroll) {
      // Header must but out of view before adding box shadow
      if (window.scrollY > this.activeBarElement.clientHeight) {
        this.activeBarElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.REWIND_SHADOW);
      }
    }
  }
  /**
   * Checks to see if Mobile navbar is visible. This will be set in init method
   * and again with @type {ResponsiveMonitor}
   */
  getActiveBarElement() {
    const {display} = window.getComputedStyle(this.headerBarMobile);
    return display === 'block' ? this.headerBarMobile : this.headerBar;
  }
}



/***/ }),

/***/ "./_glue/lib/header/popupmenu/constants.js":
/*!*************************************************!*\
  !*** ./_glue/lib/header/popupmenu/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['MENU_OPEN'] = 'glue-header__menu--open';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['NO_CHILDREN'] =
    'PopupMenu constructor argument el has no element children.';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/header/popupmenu/index.js":
/*!*********************************************!*\
  !*** ./_glue/lib/header/popupmenu/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PopupMenu: () => (/* binding */ PopupMenu)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _math_coordinate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/coordinate */ "./_glue/lib/math/coordinate.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./_glue/lib/header/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/popupmenu/constants.js");
/* harmony import */ var _menuitem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./menuitem */ "./_glue/lib/header/popupmenu/menuitem.js");









/**
 * This class creates a PopupMenu instance, which uses a controller to
 * show and hide the menu.
 */
class PopupMenu extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, controller) {
    super(root);
    this.menuItemCollection = [];
    this.firstChars = [];
    this.firstItem = null;
    this.lastItem = null;
    this.hasFocus = false;
    this.hasHover = false;
    /**
     * Sets hasHover to true when the menu is hovered.
     */
    this.handleMouseenter = () => {
      this.hasHover = true;
    };
    /**
     * Waits for 300 mills to close the menu after moving mouse out of the menu.
     */
    this.handleMouseleave = (event) => {
      this.hasHover = false;
      const mousePos = new _math_coordinate__WEBPACK_IMPORTED_MODULE_3__.Coordinate(event.clientX, event.clientY);
      if (this.isInController(mousePos)) return;
      setTimeout(() => {
        this.close(false);
      }, 300);
    };
    /**
     * Sets focus to the item based on the first key that users press.
     */
    this.setFocusByFirstCharacter = (currentItem, char) => {
      char = char.toLowerCase();
      // Gets the search start point.
      let start = this.menuItemCollection.indexOf(currentItem) + 1;
      if (start === this.menuItemCollection.length) {
        start = 0;
      }
      const findIndexFunc = (item, index) => {
        return item === char && index >= start;
      };
      let index = this.firstChars.findIndex(findIndexFunc);
      if (index === -1) {
        start = 0;
        index = this.firstChars.findIndex(findIndexFunc);
      }
      if (index > -1) {
        this.menuItemCollection[index].root.focus();
      }
    };
    this.open = () => {
      this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.MENU_OPEN);
      this.controller.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'true');
      this.controller.setExpanded(true);
    };
    if (this.root.childElementCount === 0) {
      throw new Error(`${_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.NO_CHILDREN}`);
    }
    this.menuItems = Array.from(
        this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.LIST_ITEM}`));
    this.controller = controller;
    this.init();
  }
  init() {
    let menuItem;
    this.root.tabIndex = -1;
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.MENU);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseleave);
    for (const item of this.menuItems) {
      item.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.NONE);
    }
    const menuLinks = Array.from(this.root.querySelectorAll(
        `:scope > .glue-header__item > .glue-header__link`));
    // Initiates the popup menu attached to the menu item
    for (const link of menuLinks) {
      menuItem = new _menuitem__WEBPACK_IMPORTED_MODULE_6__.MenuItem(link, this);
      const nextElement = menuItem.root.nextElementSibling;
      if (nextElement instanceof HTMLUListElement) {
        menuItem.popupMenu = new PopupMenu(nextElement, menuItem);
      }
      this.menuItemCollection.push(menuItem);
      this.addFirstChar(link);
    }
    // Sets the first and last item in the menu.
    const numItems = this.menuItemCollection.length;
    if (numItems > 0) {
      this.firstItem = this.menuItemCollection[0];
      this.lastItem = this.menuItemCollection[numItems - 1];
    }
  }
  destroy() {
    var _a;
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
    for (const item of this.menuItems) {
      item.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    }
    for (const menuItem of this.menuItemCollection) {
      (_a = menuItem.popupMenu) === null || _a === void 0 ? void 0 :
                                                            _a.destroy();
      menuItem.destroy();
    }
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseleave);
  }
  /**
   * Add first charector of each link text to the collection.
   */
  addFirstChar(link) {
    var _a;
    const textContent = (_a = link.textContent) === null || _a === void 0 ?
        void 0 :
        _a.trim().charAt(0).toLowerCase();
    this.firstChars.push(
        textContent !== null && textContent !== void 0 ? textContent : '');
  }
  /**
   * Checks whether the cursor is in the controller area,
   */
  isInController(mousePos) {
    const rect = this.controller.root.getBoundingClientRect();
    return (
        mousePos.x >= rect.left && mousePos.x <= rect.right &&
        mousePos.y >= rect.top && mousePos.y <= rect.bottom);
  }
  /** Assert this is a MenuItem */
  isMenuItem(controller) {
    return controller.parentMenu !== null && controller.isMenubarItem === false;
  }
  /**
   * Sets focus to the menubar item.
   * Looks for the parent node if the current node is a menu item.
   */
  setFocusToMenubarItem(controller) {
    while (controller) {
      if (controller.isMenubarItem) {
        controller.root.focus();
        return controller;
      } else if (this.isMenuItem(controller)) {
        controller.parentMenu.hasFocus = false;
        controller = controller.parentMenu.controller;
      }
    }
    return null;
  }
  /**
   * Sets focus to the controller depending on the keys.
   * Sets focus to the controller element if no argument is passed.
   * Sets focus to the next or previous menubar item when command is passed.
   */
  setFocusToController(command) {
    var _a, _b, _c, _d, _e;
    if (command === undefined) {
      (_b = (_a = this.controller) === null || _a === void 0 ?
           void 0 :
           _a.root) === null ||
              _b === void 0 ?
          void 0 :
          _b.focus();
      return;
    }
    // If the controller is a menuBar item, set focus to the previous
    // or next menuBar item.
    if (this.controller.isMenubarItem) {
      if (command === 'previous') {
        (_c = this.controller.parentMenu) === null || _c === void 0 ?
            void 0 :
            _c.setFocusToPreviousItem(this.controller);
      } else if (command === 'next') {
        (_d = this.controller.parentMenu) === null || _d === void 0 ?
            void 0 :
            _d.setFocusToNextItem(this.controller);
      }
      // If the controller is a popup menu item, set the focus to its
      // controller. If the command is next, set the focus to the next menubar
      // item.
    } else {
      this.controller.root.focus();
      this.close();
      if (command === 'next') {
        const menubarItem = this.setFocusToMenubarItem(this.controller);
        (_e = menubarItem === null || menubarItem === void 0 ?
             void 0 :
             menubarItem.parentMenu) === null ||
                _e === void 0 ?
            void 0 :
            _e.setFocusToNextItem(menubarItem);
      }
    }
  }
  setFocusToFirstItem() {
    var _a;
    (_a = this.firstItem) === null || _a === void 0 ? void 0 : _a.root.focus();
  }
  setFocusToLastItem() {
    var _a;
    (_a = this.lastItem) === null || _a === void 0 ? void 0 : _a.root.focus();
  }
  setFocusToPreviousItem(currentItem) {
    var _a;
    if (currentItem === this.firstItem) {
      (_a = this.lastItem) === null || _a === void 0 ? void 0 : _a.root.focus();
    } else {
      const index = this.menuItemCollection.indexOf(currentItem);
      this.menuItemCollection[index - 1].root.focus();
    }
  }
  setFocusToNextItem(currentItem) {
    var _a;
    if (currentItem === this.lastItem) {
      (_a = this.firstItem) === null || _a === void 0 ? void 0 :
                                                        _a.root.focus();
    } else {
      const index = this.menuItemCollection.indexOf(currentItem);
      this.menuItemCollection[index + 1].root.focus();
    }
  }
  /**
   * Closes the menu only when:
   *  - A true force flag is passed in.
   *  - The menu or its chlid menus do not have focus, and the menu does not
   *    have hover, and when its controller is a menubar item, it is not
   *    hovered.
   */
  close(force = false) {
    var _a;
    // True if the controller is a menubar item and it is hovered.
    let controllerHasHover = false;
    // True when this popup menu or any child popup menu is focused.
    let hasFocus = this.hasFocus;
    // Updates controllerHasHover flag for the menubar item.
    if (this.controller.isMenubarItem) {
      controllerHasHover = this.controller.hasHover;
    }
    if (!hasFocus) {
      for (const item of this.menuItemCollection) {
        hasFocus = hasFocus ||
            !!((_a = item.popupMenu) === null || _a === void 0 ? void 0 :
                                                                 _a.hasFocus);
      }
    }
    if (force || (!hasFocus && !this.hasHover && !controllerHasHover)) {
      this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.MENU_OPEN);
      this.controller.setExpanded(false);
    }
  }
}



/***/ }),

/***/ "./_glue/lib/header/popupmenu/menuitem.js":
/*!************************************************!*\
  !*** ./_glue/lib/header/popupmenu/menuitem.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MenuItem: () => (/* binding */ MenuItem)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");




/**
 * This class creates a child menu item component in a menu.
 * This menu item may/not control a popup menu.
 */
class MenuItem extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, parentMenu) {
    super(root);
    this.parentMenu = parentMenu;
    this.isMenubarItem = false;
    /** The  popopMenu is the menu controlled by the menu item. */
    this.popupMenu = null;
    /**
     * Handles keydown event on the menu item.
     *
     */
    this.handleKeydown = (event) => {
      let preventDefault = false;
      const char = event.key;
      function isPrintableCharacter(str) {
        return str.length === 1 && str.match(/\S/);
      }
      switch (event.key) {
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER:
          if (this.popupMenu) {
            this.popupMenu.open();
            this.popupMenu.setFocusToFirstItem();
          }
          // Allows default behavior so it can trigger links.
          preventDefault = false;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.UP:
          this.parentMenu.setFocusToPreviousItem(this);
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.DOWN:
          this.parentMenu.setFocusToNextItem(this);
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.LEFT:
          // Returns if the controller does not have a parent menu
          if (this.controllerWithoutParentMenu(this.parentMenu.controller)) {
            return;
          }
          this.parentMenu.setFocusToController('previous');
          this.parentMenu.close(true);
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.RIGHT:
          // Returns if the controller does not have a parent menu
          if (this.controllerWithoutParentMenu(this.parentMenu.controller)) {
            return;
          }
          if (this.popupMenu) {
            this.popupMenu.open();
            this.popupMenu.setFocusToFirstItem();
          } else {
            this.parentMenu.setFocusToController('next');
            this.parentMenu.close(true);
          }
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.HOME:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.PAGEUP:
          this.parentMenu.setFocusToFirstItem();
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.END:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.PAGEDOWN:
          this.parentMenu.setFocusToLastItem();
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ESC:
          this.parentMenu.setFocusToController();
          this.parentMenu.close(true);
          preventDefault = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.TAB:
          this.parentMenu.setFocusToController();
          this.parentMenu.close(true);
          break;
        default:
          if (isPrintableCharacter(char)) {
            this.parentMenu.setFocusByFirstCharacter(this, char);
            preventDefault = true;
          }
          break;
      }
      if (preventDefault) {
        event.stopPropagation();
        event.preventDefault();
      }
    };
    this.handleClick = () => {
      this.parentMenu.setFocusToController();
      this.parentMenu.close(true);
    };
    this.handleFocus = () => {
      this.parentMenu.hasFocus = true;
    };
    this.handleBlur = () => {
      this.parentMenu.hasFocus = false;
      setTimeout(() => {
        this.parentMenu.close(false);
      }, 300);
    };
    this.handleMouseenter = () => {
      var _a;
      this.parentMenu.hasHover = true;
      this.parentMenu.open();
      if (this.popupMenu) {
        this.popupMenu.hasHover = true;
      }
      (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.open();
    };
    this.handleMouseleave = () => {
      var _a;
      if (this.popupMenu) {
        this.popupMenu.hasHover = false;
      }
      (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.close(true);
    };
    this.init();
  }
  init() {
    this.root.tabIndex = -1;
    if (!this.root.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE)) {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.MENUITEM);
    }
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.BLUR, this.handleBlur);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseleave);
  }
  destroy() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.BLUR, this.handleBlur);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseleave);
  }
  /** Assert this is a MenuItem */
  controllerWithoutParentMenu(controller) {
    return controller.parentMenu === null;
  }
  setExpanded(flag) {
    if (flag) {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'true');
    } else {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, 'false');
    }
  }
}



/***/ }),

/***/ "./_glue/lib/header/siteswitcher/constants.js":
/*!****************************************************!*\
  !*** ./_glue/lib/header/siteswitcher/constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['COMPONENT'] = 'glue-header__site-switcher';
CssClasses['MENU'] = 'glue-header__site-switcher-menu';
CssClasses['MENU_ITEM'] = 'glue-header__item';
CssClasses['MENU_LINK'] = 'glue-header__link';
CssClasses['MENU_ITEM_DESCRIPTION'] =
    'glue-header__site-switcher-item-description';
CssClasses['MORE_PRODUCTS'] = 'glue-header__site-switcher-more-products';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['NO_ARIA_CONTROL'] =
    'aria-control value is not set on the site switcher element.';
Strings['NO_MENU'] = 'Header Site Switcher could not find a menu element.';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/header/siteswitcher/index.js":
/*!************************************************!*\
  !*** ./_glue/lib/header/siteswitcher/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SiteSwitcher: () => (/* binding */ SiteSwitcher)
/* harmony export */ });
/* harmony import */ var _base___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/ */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./_glue/lib/header/constants.js");
/* harmony import */ var _drawer_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawer/constants */ "./_glue/lib/header/drawer/constants.js");
/* harmony import */ var _popupmenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../popupmenu */ "./_glue/lib/header/popupmenu/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/siteswitcher/constants.js");










/**
 * This class creates a Site Switcher instance, it is triggered to show
 * a list of micro sites options.
 */
class SiteSwitcher extends _base___WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root) {
    super(root);
    this.parentMenu = null;
    /** A flag to show the switcher's focus status. */
    this.hasFocus = false;
    /** A flag to show switcher's hover status. */
    this.hasHover = false;
    /**
     * A flag to indicate whether this element is a menubar item. Both the
     * menubar item and site switcher can be dropdown trigger.
     */
    this.isMenubarItem = false;
    /**
     * Handles keydown events.
     * When press the Space, Enter or Down keys, open the popup menu and focus
     * to the first item. When press the Up key, open the popup menu and focus
     * to the last item.
     */
    this.handleKeydown = (event) => {
      let flag = false;
      switch (event.key) {
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER:
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.DOWN:
          this.popupMenu.open();
          this.popupMenu.setFocusToFirstItem();
          flag = true;
          break;
        case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.UP:
          this.popupMenu.open();
          this.popupMenu.setFocusToLastItem();
          flag = true;
          break;
        default:
          break;
      }
      if (flag) {
        event.stopPropagation();
        event.preventDefault();
      }
    };
    /**
     * Handles the click event.
     * Toggles the menu when users click the site switcher.
     */
    this.handleClick = () => {
      if (this.root.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED) === 'true') {
        this.popupMenu.close(true);
      } else {
        this.popupMenu.open();
        this.popupMenu.setFocusToFirstItem();
      }
    };
    /**
     * Sets hasFocus to true when the switcher is focused.
     */
    this.handleFocus = () => {
      this.popupMenu.hasFocus = true;
    };
    /**
     * Sets hasFocus to false when the switcher is blurred.
     */
    this.handleBlur = () => {
      this.popupMenu.hasFocus = false;
    };
    /**
     * Opens the menu and set hasHover to true when it is hovered.
     */
    this.handleMouseenter = (e) => {
      this.hasHover = true;
      this.popupMenu.open();
    };
    /**
     * Waits for 300 mills to close the menu after moving mouse out of the
     * switcher.
     */
    this.handleMouseLeave = () => {
      this.hasHover = false;
      setTimeout(() => {
        this.popupMenu.close(false);
      }, 300);
    };
    if (!this.root.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS)) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.NO_ARIA_CONTROL);
    }
    const menu = this.root.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.BAR_DESKTOP}`)
                     .querySelector(
                         '#' + this.root.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS));
    if (!menu) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.Strings.NO_MENU);
    }
    this.popupMenu = new _popupmenu__WEBPACK_IMPORTED_MODULE_6__.PopupMenu(menu, this);
    this.init();
  }
  init() {
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HASPOPUP, 'true');
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.BLUR, this.handleBlur);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseLeave);
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.BUTTON);
    this.root.tabIndex = 0;
    const drawer = this.root.closest(`.${_drawer_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ROOT}`);
    drawer === null || drawer === void 0 ?
        void 0 :
        drawer.addEventListener(_drawer_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.OPEN, () => {
          for (const link of this.popupMenu.menuItemCollection) {
            link.destroy();
          }
        });
    drawer === null || drawer === void 0 ?
        void 0 :
        drawer.addEventListener(_drawer_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.CLOSE, () => {
          for (const link of this.popupMenu.menuItemCollection) {
            link.init();
          }
        });
  }
  destroy() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HASPOPUP);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeydown);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.BLUR, this.handleBlur);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSEENTER, this.handleMouseenter);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.MOUSELEAVE, this.handleMouseLeave);
  }
  /** Sets the expanded attribute when the menu is open. */
  setExpanded(flag) {
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_EXPANDED, flag.toString());
  }
}



/***/ }),

/***/ "./_glue/lib/header/steppednav/constants.js":
/*!**************************************************!*\
  !*** ./_glue/lib/header/steppednav/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attributes: () => (/* binding */ Attributes),
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-header__stepped-nav';
CssClasses['CONTROLS_CONTAINER'] =
    'glue-header__stepped-nav-controls-container';
CssClasses['CONTROLS'] = 'glue-header__stepped-nav-controls';
CssClasses['CONTROLS_ARROW'] = 'glue-header__stepped-nav-controls-arrow';
CssClasses['CONTROLS_TITLE'] = 'glue-header__stepped-nav-controls-title';
CssClasses['MENU_CONTAINER'] = 'glue-header__stepped-nav-menus';
CssClasses['SUBNAV_ICON'] = 'glue-header__stepped-nav-subnav-icon';
CssClasses['PARENT_POSITION'] = 'glue-header__stepped-nav-parent-position';
CssClasses['PAGE'] = 'glue-stepped-page';
CssClasses['PAGES'] = 'glue-stepped-pages';
})(CssClasses || (CssClasses = {}));
var Attributes;
(function(Attributes) {
Attributes['PARENT_INDEX'] = 'data-glue-stepped-nav-parent-index';
Attributes['PARENT_INDEX_CAMEL'] = 'glueSteppedNavParentIndex';
Attributes['STEPPED_PAGE'] = 'data-glue-stepped-page';
Attributes['STEPPED_PAGE_CAMEL'] = 'glueSteppedPage';
Attributes['STEPPEDNAV_LABEL'] = 'glueSteppednavLabel';
})(Attributes || (Attributes = {}));
var Strings;
(function(Strings) {
Strings['CURRENT_PAGE'] = 'currentPage';
Strings['TOTAL_PAGES'] = 'totalPages';
Strings['NEXT_EVENT'] = 'nextPage';
Strings['CONTROLS_MODEL_ID'] = 'stepped-nav-controls';
Strings['MISSING_CONTROLS'] =
    'Some of the Stepped Nav controls elements are missing.';
Strings['MISSING_PAGES_CONT'] =
    'The container element for Stepped Nav Pages is missing.';
Strings['MISSING_LINK_BAR'] =
    'Stepped Nav can\'t find the Link Bar Header element.';
Strings['STEPPED_PAGE'] = 'glue-stepped-page';
Strings['STEPPED_NAV_LABEL_VAR_NAME'] = '$glue_steppednav_label$';
Strings['STEPPEDNAV_LABEL'] =
    '$glue_steppednav_label$, Navigate back to parent menu, $glue_steppednav_label$ opened';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/header/steppednav/index.js":
/*!**********************************************!*\
  !*** ./_glue/lib/header/steppednav/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SteppedNav: () => (/* binding */ SteppedNav)
/* harmony export */ });
/* harmony import */ var _base___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/ */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../observer */ "./_glue/lib/observer/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./_glue/lib/header/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/steppednav/constants.js");
/* harmony import */ var _pages__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pages */ "./_glue/lib/header/steppednav/pages.js");










class SteppedNav extends _base___WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * Get the element for the Stepped Nav. Useful in detemining if the
   * element is present.
   * @param root The element in which to look.
   * @return A stepped nav root element if present.
   */
  static getSteppedNavElement(root) {
    return root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.ROOT}`);
  }
  constructor(root) {
    super(root);
    this.activeInitPageIndex = 1;
    this.modelDefaults = {
      currentPage: 1,
      totalPages: 0,
    };
    this.handleKeyPress = (evt) => {
      this.keyPress(evt);
    };
    this.handleClick = (evt) => {
      var _a;
      if (evt.target instanceof Element) this.selectPage(evt.target);
      // When the user clicks on a link that is a pointer to anther page, do not
      // follow the link href.
      if (evt.target instanceof HTMLAnchorElement &&
          ((_a = evt.target.parentElement) === null || _a === void 0 ?
               void 0 :
               _a.hasAttribute(_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.STEPPED_PAGE))) {
        evt.preventDefault();
      }
    };
    this.updateHandler = () => {
      // Set the active element to the container so event listeners will pick
      // up events.
      this.root.focus();
    };
    // Set up the data model.
    this.observer = new _observer__WEBPACK_IMPORTED_MODULE_4__.Observer(Object.assign({}, this.modelDefaults));
    this.model = this.observer.data;
    // Sets up the oage containers that will be used for the Menus.
    this.initMenuPages();
    // Sets up the controls containers.
    this.initControls();
    // Build a menu list out of the existing menu structure. Must be called
    // after the controls and menu pages are initialized.
    this.buildPagesFromNav();
    // Init the active page if it's not the default first page.
    // This must happen after the Pages is created because
    // the page model needs to know how many pages there are.
    this.model.currentPage = this.activeInitPageIndex;
    // Designate this as a navigation element.
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.NAVIGATION);
    this.root.tabIndex = Number(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeyPress);
    this.observer.listen(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.CURRENT_PAGE, this.updateHandler);
  }
  /**
   * Initialize the menu Page containers.
   */
  initMenuPages() {
    // Set the page attributes of the stepped menu container.
    this.pagesContainer =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.MENU_CONTAINER}`);
    if (!this.pagesContainer) throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_PAGES_CONT);
    this.pagesContainer.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PAGES);
  }
  /**
   * Initialize the controls over the Pages.
   */
  initControls() {
    this.steppedControlsContainer =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.CONTROLS_CONTAINER}`);
    this.steppedControls = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.CONTROLS}`);
    this.steppedControlsTitle =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.CONTROLS_TITLE}`);
    if (!this.steppedControlsContainer || !this.steppedControls ||
        !this.steppedControlsTitle) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_CONTROLS);
    }
    this.steppedControls.remove();
    // Grab the subnav icon from the controls for later use - and remove it.
    this.subnavIcon =
        this.steppedControls.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.SUBNAV_ICON}`);
    if (this.subnavIcon) this.subnavIcon.remove();
    this.steppedControls.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PAGE);
  }
  /**
   * Initialize all the menu pages. This adds them to the menu container and
   * sets up page and controls for UI actions.
   * @return activePageIndex {number}
   */
  buildPagesFromNav() {
    var _a, _b;
    // Clone the existing menu structure.
    const linkBar = (_a = this.root.parentElement) === null || _a === void 0 ?
        void 0 :
        _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.LINK_BAR}`);
    if (!linkBar) throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_LINK_BAR);
    const rootMenu =
        (_b = linkBar.firstElementChild) === null || _b === void 0 ?
        void 0 :
        _b.cloneNode(true);
    // Start the recursive search with the root menu.
    if (rootMenu instanceof HTMLElement) this.harvestMenu(rootMenu);
    // Create Pages from the pages and controls containers. This
    // must be done after the pages are built.
    this.menuPages = new _pages__WEBPACK_IMPORTED_MODULE_7__.Pages(this.pagesContainer, this.observer);
    this.controlsPages =
        new _pages__WEBPACK_IMPORTED_MODULE_7__.Pages(this.steppedControlsContainer, this.observer);
    this.model.totalPages = this.pagesContainer.children.length;
  }
  /**
   * Harvest a menu element. Creates a new page in the stepped nav.
   * @param menuElement The menu Element to look in.
   * @param menuParentTitle  The title of the menu parent.
   * @return The index of this menu page.
   */
  harvestMenu(menuElement, parentIndex, menuParentTitle = '') {
    // Set Page properties of the new menu clone, make it a page
    // and add it to the menu container as a new page.
    menuElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PAGE);
    this.pagesContainer.appendChild(menuElement);
    // Build and add the controls for this menu.
    this.steppedControlsTitle.textContent = menuParentTitle;
    const controlsElem = this.steppedControls.cloneNode(true);
    controlsElem.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.LINK_ITEM);
    if (menuElement.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PARENT_POSITION)) {
      controlsElem.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PARENT_POSITION);
    }
    if (parentIndex) {
      // Set the controls page to the index of the parent menu.
      controlsElem.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.PARENT_INDEX_CAMEL] = String(parentIndex);
      // Set the parent index of the stepped page for positioning.
      menuElement.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.PARENT_INDEX_CAMEL] = String(parentIndex);
    }
    // Set the tab index so this element is focusable.
    controlsElem.tabIndex = Number(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE);
    this.steppedControlsContainer.appendChild(controlsElem);
    // Harvest the menu children to look for more menus.
    const thisMenuPageIndex = this.pagesContainer.children.length;
    for (const menuItem of Array.from(menuElement.children)) {
      if (menuItem instanceof HTMLElement) {
        this.harvestListItem(thisMenuPageIndex, menuItem);
      }
      // Put this menu in the right position if the list item is active.
      if (menuItem.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE_MENU)) {
        menuElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PARENT_POSITION);
        controlsElem.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PARENT_POSITION);
      }
    }
    // Set role and aria-label for accessibility purposes.
    if (menuParentTitle) {
      const labelTemplate = controlsElem.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.STEPPEDNAV_LABEL] ||
          _constants__WEBPACK_IMPORTED_MODULE_6__.Strings.STEPPEDNAV_LABEL;
      const navLabel = labelTemplate.replaceAll(
          _constants__WEBPACK_IMPORTED_MODULE_6__.Strings.STEPPED_NAV_LABEL_VAR_NAME, menuParentTitle);
      controlsElem.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL, navLabel);
      controlsElem.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.BUTTON);
    }
    // Return the index of this menu.
    return thisMenuPageIndex;
  }
  /**
   * Harvest a menu list item element. If it finds a menu, it is harvested
   * via harvestMenu();
   * @param parentMenuPageIndex The index of the parent menu.
   * @param listItemElement The menu list item element.
   */
  harvestListItem(parentMenuPageIndex, listItemElement) {
    var _a;
    const subMenuElement = this.getChildOfNodeType(listItemElement, 'UL');
    const linkElement = this.getChildOfNodeType(listItemElement, 'A');
    // See if this is a leaf node (i.e. if it doesn't have a submenu.)
    // If it's active, we've found the currently active page.
    if (!subMenuElement &&
        listItemElement.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ACTIVE_LINK)) {
      this.activeInitPageIndex = parentMenuPageIndex;
    }
    // Make the link not tabbable.
    if (linkElement) {
      linkElement.tabIndex = Number(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE);
    }
    if (!subMenuElement || !linkElement) return;
    // Take this submenu out of the li so it doesn't appear in the UI.
    subMenuElement.remove();
    // Since this is a submenu node, get the anchor element and submenu
    // and make a new page out of it.
    const menuElementPageIndex = this.harvestMenu(
        subMenuElement, parentMenuPageIndex,
        (_a = linkElement.textContent) === null || _a === void 0 ? void 0 :
                                                                   _a.trim());
    // Set the pointer to the page this link points to.
    listItemElement.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.STEPPED_PAGE_CAMEL] =
        String(menuElementPageIndex);
    // Remove any svg that was there from the deep nav. Add the correct svg.
    const existingArrow = this.getChildOfNodeType(linkElement, 'svg');
    existingArrow === null || existingArrow === void 0 ? void 0 :
                                                         existingArrow.remove();
    if (this.subnavIcon) {
      linkElement.appendChild(this.subnavIcon.cloneNode(true));
    }
  }
  /**
   * Moves the page model to the next or previous page when the user uses
   * the enter, space or directional keys.
   */
  keyPress(evt) {
    const target = evt.target;
    const isRtl = !!this.root.closest('[dir=rtl]');
    // Selectable Elements are whichever elements are selectable via arrow
    // navigation in each of the groups of pages.
    const selectableElements = this.controlsPages.selectableElements.concat(
        this.menuPages.selectableElements);
    const selectedIndex = selectableElements.indexOf(document.activeElement);
    switch (evt.key) {
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER:
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE:
        this.selectPage(target);
        break;
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.LEFT:
        isRtl ? this.selectSubPage(target) : this.selectParentPage();
        break;
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.RIGHT:
        isRtl ? this.selectParentPage() : this.selectSubPage(target);
        break;
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.UP:
        selectedIndex > 0 ?
            selectableElements[selectedIndex - 1].focus() :
            selectableElements[selectableElements.length - 1].focus();
        break;
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.DOWN:
        selectedIndex >= selectableElements.length - 1 ?
            selectableElements[0].focus() :
            selectableElements[selectedIndex + 1].focus();
        break;
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.HOME:
        selectableElements[0].focus();
        break;
      case _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.END:
        selectableElements[selectableElements.length - 1].focus();
        break;
      default:
    }
  }
  /**
   * Handle a select action without a forward/back direction.
   */
  selectPage(elem) {
    // If it's in the controls container, then it's a parent page select action.
    if (this.steppedControlsContainer.contains(elem)) {
      this.selectParentPage();
    } else {
      this.selectSubPage(elem);
    }
  }
  /**
   * Handle when a new page has been selected from a submenu element action.
   */
  selectSubPage(elem) {
    // Find parent elem that is either a controls element or a subnav element.
    const dataElem = elem.closest(`[${_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.STEPPED_PAGE}]`);
    if (dataElem) {
      const pageIndex = Number(
          dataElem === null || dataElem === void 0 ?
              void 0 :
              dataElem.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.Attributes.STEPPED_PAGE_CAMEL]);
      this.model.currentPage = pageIndex;
    }
  }
  /**
   * Handle when we should go to the parent page of an elem.
   */
  selectParentPage() {
    // Find parent element where the attribute is either parent or a stepped
    // page.
    const parentPageIndex = this.controlsPages.getCurrentPageParentIndex();
    this.model.currentPage = parentPageIndex;
  }
  /**
   * Get a child element from a parent of a specified type.
   * @param parent The element to look in.
   * @param type The type of node to get e.g. 'UL'
   * @return The first child of that type or undefined if not found.
   */
  getChildOfNodeType(parent, type) {
    return Array.from(parent.children).find((el) => el.nodeName === type);
  }
  destroy() {
    if (this.menuPages) this.menuPages.destroy();
    if (this.controlsPages) this.controlsPages.destroy();
    this.observer.unlisten(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.CURRENT_PAGE, this.updateHandler);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeyPress);
    for (const node of this.pagesContainer.childNodes) {
      this.pagesContainer.removeChild(node);
    }
    for (const node of this.steppedControlsContainer.childNodes) {
      this.steppedControlsContainer.removeChild(node);
    }
    this.steppedControls.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleClick);
    this.steppedControls.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeyPress);
  }
}



/***/ }),

/***/ "./_glue/lib/header/steppednav/pages.js":
/*!**********************************************!*\
  !*** ./_glue/lib/header/steppednav/pages.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pages: () => (/* binding */ Pages)
/* harmony export */ });
/* harmony import */ var _base___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base/ */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _constants_classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants/classes */ "./_glue/lib/constants/classes.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./_glue/lib/header/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./_glue/lib/header/steppednav/constants.js");







/**
 * Glue Page component
 */
class Pages extends _base___WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root Root element that contains options object
   * @param model A shared model for paginating.
   */
  constructor(root, observer) {
    super(root);
    this.observer = observer;
    this.pageEls = Array.from(this.root.children);
    this.elementIds = [];
    this.selectableElements = [];
    this.handleUpdate = () => {
      this.update();
    };
    this.initialize();
  }
  /**
   * Initialize the component.
   */
  initialize() {
    this.observer.listen(_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CURRENT_PAGE, this.handleUpdate);
    this.model = this.observer.data;
    this.initPageElementIDs();
    this.update();
  }
  /**
   * Set IDs for all elements.
   */
  initPageElementIDs() {
    let pageElementId;
    for (const [index, pageEl] of this.pageEls.entries()) {
      pageElementId =
          `${_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.STEPPED_PAGE}-${Math.round(Math.random() * 99999999)}`;
      pageEl.id = pageElementId;
      pageEl.classList.add(`${_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.STEPPED_PAGE}-${index + 1}`);
      if (!this.elementIds[index + 1]) {
        this.elementIds[index + 1] = pageElementId;
      }
    }
  }
  /**
   * Updates CSS classes, ARIA properties and event handlers on page elements.
   */
  update() {
    // Recursively positions page elements based on parent page indexes.
    const positionPage = (elem) => {
      // A page will either have a parent index or page index attr that points
      // to the page that ought to be in the parent position in the UI.
      const parentPageIndex = elem.hasAttribute(_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.STEPPED_PAGE) ?
          Number(elem.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.STEPPED_PAGE_CAMEL]) :
          Number(elem.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.PARENT_INDEX_CAMEL]);
      if (isNaN(parentPageIndex)) return;
      const parentElem = this.pageEls[parentPageIndex - 1];
      parentElem === null || parentElem === void 0 ?
          void 0 :
          parentElem.classList.add(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.PARENT_POSITION);
      positionPage(parentElem);
    };
    const currentElem = this.pageEls[this.model.currentPage - 1];
    for (const pageElem of this.pageEls) {
      const selected = pageElem === currentElem;
      if (selected) {
        pageElem.classList.add(_constants_classes__WEBPACK_IMPORTED_MODULE_2__.CssClasses.SHOW);
        pageElem.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
      } else {
        pageElem.classList.remove(
            _constants_classes__WEBPACK_IMPORTED_MODULE_2__.CssClasses.SHOW, _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.PARENT_POSITION);
        pageElem.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
      }
      this.updatePageElements(pageElem);
    }
    // Get all the page elements that might be selectable for key-based nav.
    if (currentElem.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.CONTROLS)) {
      this.selectableElements =
          currentElem.hasAttribute(_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.PARENT_INDEX) ? [currentElem] :
                                                              [];
    } else {
      this.selectableElements = Array.from(
          currentElem.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.LINK_ITEM}`));
    }
    // Set the positions of the pages that are parents of the current page.
    positionPage(currentElem);
  }
  /**
   * Updates the DOM attributes.
   */
  updatePageElements(pageElem) {
    const children = Array.from(pageElem.children);
    // Set attributes of the links or submenu elements in the page.
    for (const elem of children) {
      if (!elem.hasAttribute(_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.STEPPED_PAGE)) continue;
      // The 'haspopup' aria attribute marks an item that has a sub-menu to
      // to differentiate it from the simple link elements.
      elem.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HASPOPUP, 'true');
      // The 'selected' aria attribute indicates it's the active page.
      elem.setAttribute(
          _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_SELECTED,
          String(elem.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.ACTIVE_MENU)));
      // Connect the aria controls attr with the controls index.
      if (elem instanceof HTMLElement) {
        const pageId = Number(elem.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.STEPPED_PAGE_CAMEL]);
        elem.setAttribute(
            _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.elementIds[pageId]);
      }
    }
  }
  /**
   * Gets current page parent page index.
   */
  getCurrentPageParentIndex() {
    const pageElem = this.pageEls[this.model.currentPage - 1];
    const index = Number(pageElem.dataset[_constants__WEBPACK_IMPORTED_MODULE_4__.Attributes.PARENT_INDEX_CAMEL]);
    return isNaN(index) ? 1 : index;
  }
  destroy() {
    for (const pageElem of this.pageEls) {
      pageElem.classList.remove(
          _constants_classes__WEBPACK_IMPORTED_MODULE_2__.CssClasses.SHOW, _constants__WEBPACK_IMPORTED_MODULE_4__.CssClasses.PARENT_POSITION);
      pageElem.id = '';
    }
    this.observer.unlisten(_constants__WEBPACK_IMPORTED_MODULE_4__.Strings.CURRENT_PAGE, this.handleUpdate);
  }
}



/***/ }),

/***/ "./_glue/lib/jumplinks/constants.js":
/*!******************************************!*\
  !*** ./_glue/lib/jumplinks/constants.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   DataAttr: () => (/* binding */ DataAttr),
/* harmony export */   Numbers: () => (/* binding */ Numbers),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Jumplinks component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['BUTTON'] = 'glue-jumplinks__button';
CssClasses['BUTTON_LEFT'] = 'glue-jumplinks__button--prev';
CssClasses['BUTTON_RIGHT'] = 'glue-jumplinks__button--next';
CssClasses['BUTTON_ACTIVE'] = 'glue-jumplinks__button--active';
CssClasses['LIST'] = 'glue-jumplinks__list';
CssClasses['ITEMS'] = 'glue-jumplinks__list-item';
CssClasses['LINK'] = 'glue-jumplinks__link';
CssClasses['LINK_ACTIVE'] = 'glue-jumplinks__link--active';
CssClasses['VIEWPORT'] = 'glue-jumplinks__viewport';
CssClasses['REWIND'] = 'glue-jumplinks--rewind';
CssClasses['ROOT'] = 'glue-jumplinks';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['LI_WIDTH'] = 'liWidth';
Strings['VIEWPORT'] = 'viewport';
Strings['PAGE_X'] = 'pageX';
Strings['SLIDES'] = 'slides';
Strings['ACTIVE_LINK'] = 'activeLink';
Strings['RTL'] = 'rtl';
Strings['TRANSFORM'] = 'transform';
Strings['BLOCK'] = 'block';
Strings['FIXED'] = 'fixed';
Strings['JUMPLINK_DEFAULT_LABEL'] = 'Jump to section within page';
Strings['NOT_FIXED'] = 'absolute';
Strings['NO_ANIMATION'] = 'none';
})(Strings || (Strings = {}));
var Numbers;
(function(Numbers) {
Numbers[Numbers['DEFAULT_OFFSET'] = 144] = 'DEFAULT_OFFSET';
Numbers[Numbers['JUMPLINKS_MARGIN'] = 16] = 'JUMPLINKS_MARGIN';
Numbers[Numbers['JUMPLINKS_HEIGHT'] = 48] = 'JUMPLINKS_HEIGHT';
Numbers[Numbers['SCROLL_THRESHOLD'] = 130] = 'SCROLL_THRESHOLD';
})(Numbers || (Numbers = {}));
var DataAttr;
(function(DataAttr) {
DataAttr['JUMPLINK_LABEL'] = 'glueJumplinkLabel';
})(DataAttr || (DataAttr = {}));



/***/ }),

/***/ "./_glue/lib/jumplinks/index.js":
/*!**************************************!*\
  !*** ./_glue/lib/jumplinks/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Jumplinks: () => (/* binding */ Jumplinks)
/* harmony export */ });
/* harmony import */ var _base_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/index */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _easing___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing/ */ "./_glue/lib/easing/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _focus___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../focus/ */ "./_glue/lib/focus/index.js");
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../observer */ "./_glue/lib/observer/index.js");
/* harmony import */ var _smoothscroll_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../smoothscroll/constants */ "./_glue/lib/smoothscroll/constants.js");
/* harmony import */ var _smoothscroll_scrollmanager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../smoothscroll/scrollmanager */ "./_glue/lib/smoothscroll/scrollmanager.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants */ "./_glue/lib/jumplinks/constants.js");











class Jumplinks extends _base_index__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, options) {
    super(root);
    this.linkTargets = [];
    this.lastScrollPosition = 0;
    this.isScrolling = false;
    this.handleClick = (e) => {
      this.clickHandler(e);
    };
    this.handleActiveLinkChange = () => {
      this.activeLinkChangeHandler();
    };
    this.handleScroll = () => {
      this.scrollHandler();
    };
    this.handleResize = () => {
      this.resizeHandler();
    };
    this.handleLinkFocus = (e) => {
      this.focusLinkHandler(e);
    };
    this.handleHorizontalScroll = () => {
      this.updateButtons();
    };
    let element = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.LIST}`);
    if (!element) {
      throw new Error('Jumplinks List element is missing.');
    } else {
      this.list = element;
    }
    element = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_LEFT}`);
    if (!element) {
      throw new Error('Jumplinks left button element is missing.');
    } else {
      this.prevButton = element;
    }
    element = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_RIGHT}`);
    if (!element) {
      throw new Error('Jumplinks right button element is missing.');
    } else {
      this.nextButton = element;
    }
    this.listItems =
        Array.from(this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.ITEMS}`));
    if (this.listItems.length === 0) {
      throw new Error('Jumplinks list item is missing.');
    }
    this.links = Array.from(this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.LINK}`));
    if (this.links.length === 0) {
      throw new Error('Jumplinks link item is missing.');
    }
    this.options = Object.assign(
        {}, {
          offset: _constants__WEBPACK_IMPORTED_MODULE_8__.Numbers.DEFAULT_OFFSET,
          belowHeader: false,
        },
        options);
    this.smoothScroll = new _smoothscroll_scrollmanager__WEBPACK_IMPORTED_MODULE_7__.ScrollManager();
    this.observer = new _observer__WEBPACK_IMPORTED_MODULE_5__.Observer({
      activeLink: '',
    });
    this.leftWatchPoint =
        this.root.getBoundingClientRect().x + this.prevButton.offsetWidth;
    this.rightWatchPoint = this.leftWatchPoint + this.list.offsetWidth;
    this.initialize();
  }
  initialize() {
    this.setAttributes();
    this.updateButtons();
    this.getLinkTargets();
    this.registerListeners();
    this.createIntersectionObserver();
  }
  createIntersectionObserver() {
    const options = {
      root: null,
      rootMargin: `-${Math.floor(window.innerHeight / 2)}px 0px`,
      threshold: 0,
    };
    const observer = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting) {
          this.setActiveLink(entry.target.id);
        } else {
          if (entry.target.id === this.getActiveLink()) {
            this.reset();
          }
        }
      }
    }, options);
    for (const element of this.linkTargets) {
      observer.observe(element);
    }
  }
  /**
   */
  destroy() {
    this.deregisterListeners();
  }
  setAttributes() {
    /**
     * Gets localized text to be appended to jump links 'aria label'
     * if it exists or else uses default string.
     */
    const jumplinkList = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.LIST}`);
    const labelText = jumplinkList.dataset[_constants__WEBPACK_IMPORTED_MODULE_8__.DataAttr.JUMPLINK_LABEL] ||
        _constants__WEBPACK_IMPORTED_MODULE_8__.Strings.JUMPLINK_DEFAULT_LABEL;
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, 'navigation');
    for (const link of this.links) {
      link.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABEL, `${link.text} - ${labelText}`);
    }
    for (const button of [this.prevButton, this.nextButton]) {
      button.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      button.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN, 'true');
    }
  }
  setActiveLink(id) {
    this.observer.data['activeLink'] = id;
  }
  getActiveLink() {
    return this.observer.data['activeLink'];
  }
  getLinkTargets() {
    for (const link of this.links) {
      const hash = link.hash.substring(1);
      const target = document.querySelector(`#${hash}`);
      if (!target) {
        throw new Error(`Element with id "${hash}" does not exist.`);
      }
      this.linkTargets.push(target);
    }
  }
  registerListeners() {
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.CLICK, this.handleClick);
    const throttle = (func, limit) => {
      let inThrottle;
      return (...args) => {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => (inThrottle = false), limit);
        }
      };
    };
    this.list.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.SCROLL, this.handleHorizontalScroll);
    document.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.SCROLL, throttle(this.handleScroll, 16));
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.RESIZE, this.handleResize);
    this.observer.listen(_constants__WEBPACK_IMPORTED_MODULE_8__.Strings.ACTIVE_LINK, this.handleActiveLinkChange);
    document.addEventListener(_smoothscroll_constants__WEBPACK_IMPORTED_MODULE_6__.ScrollEventType.ENDSCROLL, () => {
      this.isScrolling = false;
      this.updateTopOffset();
    });
    for (const link of this.links) {
      link.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.FOCUS, this.handleLinkFocus);
    }
  }
  deregisterListeners() {
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.CLICK, this.handleClick);
    this.list.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.SCROLL, this.handleHorizontalScroll);
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.SCROLL, this.handleScroll);
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.RESIZE, this.handleResize);
    this.observer.unlisten(_constants__WEBPACK_IMPORTED_MODULE_8__.Strings.ACTIVE_LINK, this.handleActiveLinkChange);
    for (const link of this.links) {
      link.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.FOCUS, this.handleLinkFocus);
    }
  }
  focusLinkHandler(e) {
    if (e.target && e.target instanceof Element) {
      this.updateButtons();
    }
  }
  /**
   * Click handler for all component buttons, via event delegation
   */
  clickHandler(e) {
    e.preventDefault();
    const clickTarget = e.target;
    let target;
    if (clickTarget === this.prevButton) {
      target = this.isRTL() ? this.getPartialLink('next') :
                              this.getPartialLink('prev');
      target.scrollIntoView({
        behavior: 'auto',
        block: 'nearest',
        inline: 'end',
      });
    } else if (clickTarget === this.nextButton) {
      target = this.isRTL() ? this.getPartialLink('prev') :
                              this.getPartialLink('next');
      target.scrollIntoView({
        behavior: 'auto',
        block: 'nearest',
        inline: 'start',
      });
    } else if (
        clickTarget instanceof HTMLAnchorElement &&
        this.links.includes(clickTarget)) {
      target = clickTarget;
      const hash = target.hash.substring(1);
      const defaultScrollY = this.options.offset + _constants__WEBPACK_IMPORTED_MODULE_8__.Numbers.JUMPLINKS_HEIGHT +
          _constants__WEBPACK_IMPORTED_MODULE_8__.Numbers.JUMPLINKS_MARGIN;
      const midHeight = Math.floor(window.innerHeight / 2);
      const scrollY = defaultScrollY > midHeight ? midHeight : defaultScrollY;
      const targetElement = document.querySelector(`#${hash}`);
      this.smoothScroll.startScroll(targetElement, {
        'duration': 600,
        'easing': _easing___WEBPACK_IMPORTED_MODULE_2__.easeInOutQuart,
        'direction': 'both',
        'hash': true,
        'offset': {
          'x': 0,
          'y': scrollY,
        },
      });
      this.isScrolling = true;
      const isFocusable = _focus___WEBPACK_IMPORTED_MODULE_4__.isElementFocusable(targetElement);
      // Set tabindex = -1 to non-focusable element, so focus() is able to
      // move focus to the element.
      if (!isFocusable) {
        targetElement.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      }
      targetElement.focus();
    }
    this.updateButtons();
  }
  /*
   * Return the link element that is partially visible.
   */
  getPartialLink(direction) {
    let watchPoint;
    direction === 'prev' ? (watchPoint = this.leftWatchPoint) :
                           (watchPoint = this.rightWatchPoint);
    for (const link of this.links) {
      const bounding = link.getBoundingClientRect();
      if (bounding.x < watchPoint && bounding.x + bounding.width > watchPoint) {
        return link;
      }
    }
    return this.links[0];
  }
  reset() {
    this.setActiveLink('');
  }
  activeLinkChangeHandler() {
    this.renderActiveLink();
    const hash = this.getActiveLink();
    if (hash !== '') {
      const activeEl = this.links.find((link) => link.hash === `#${hash}`);
      // Scroll the link element into view
      activeEl === null || activeEl === void 0 ? void 0 :
                                                 activeEl.scrollIntoView({
                                                   behavior: 'auto',
                                                   block: 'nearest',
                                                   inline: 'center',
                                                 });
    }
    this.updateButtons();
  }
  scrollHandler() {
    if (this.isScrolling === true) {
      return;
    }
    this.updateTopOffset();
  }
  resizeHandler() {
    /**
     * TODO: add test case to verify whether the active class is applied to the
     * prev or next button on resize.
     */
    this.leftWatchPoint =
        this.root.getBoundingClientRect().x + this.prevButton.offsetWidth;
    this.rightWatchPoint = this.leftWatchPoint + this.list.offsetWidth;
    this.updateButtons();
  }
  // Show and hide prev/next buttons
  updateButtons() {
    this.prevButton.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_ACTIVE);
    this.nextButton.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_ACTIVE);
    if (this.isRTL()) {
      if (this.list.scrollLeft < 0) {
        this.prevButton.classList.add(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_ACTIVE);
      }
      if (this.list.scrollWidth + this.list.scrollLeft - this.list.clientWidth >
          10) {
        this.nextButton.classList.add(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_ACTIVE);
      }
    } else {
      if (this.list.scrollLeft > 0) {
        this.prevButton.classList.add(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_ACTIVE);
      }
      if (this.list.scrollWidth - this.list.scrollLeft - this.list.clientWidth >
          10) {
        this.nextButton.classList.add(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.BUTTON_ACTIVE);
      }
    }
  }
  /**
   * Set active link via hash
   */
  renderActiveLink() {
    const id = this.getActiveLink();
    const currentActiveLink = this.links.find((link) => link.hash === `#${id}`);
    const prevActiveLink =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.LINK_ACTIVE}`);
    prevActiveLink === null || prevActiveLink === void 0 ?
        void 0 :
        prevActiveLink.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.LINK_ACTIVE);
    prevActiveLink === null || prevActiveLink === void 0 ?
        void 0 :
        prevActiveLink.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CURRENT);
    currentActiveLink === null || currentActiveLink === void 0 ?
        void 0 :
        currentActiveLink.classList.add(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.LINK_ACTIVE);
    currentActiveLink === null || currentActiveLink === void 0 ?
        void 0 :
        currentActiveLink.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CURRENT, 'true');
  }
  /**
   * Updates vertical offset of the Jumplinks.
   */
  updateTopOffset() {
    if (this.lastScrollPosition === window.scrollY) {
      return;
    }
    // Remove rewind if it is near the page buttom, resolves the bouncing issue
    // on mobile.
    const nearBottom =
        document.body.clientHeight - window.scrollY - window.innerHeight <=
        _constants__WEBPACK_IMPORTED_MODULE_8__.Numbers.SCROLL_THRESHOLD;
    if (nearBottom) {
      this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.REWIND);
      this.unsetOffset();
      return;
    }
    // It is 128px by default
    const headerHeight = this.options.offset - _constants__WEBPACK_IMPORTED_MODULE_8__.Numbers.JUMPLINKS_MARGIN;
    // Remove rewind if it scrolls to top
    if (window.scrollY <= headerHeight) {
      this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.REWIND);
      this.unsetOffset();
      return;
    }
    // Rewind if it scrolls up
    if (window.scrollY > headerHeight) {
      if (window.scrollY < this.lastScrollPosition) {
        this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.REWIND);
        if (this.options.belowHeader) {
          const header = document.querySelector('header');
          this.setOffset(
              ((header === null || header === void 0 ? void 0 :
                                                       header.clientHeight) ||
               0) +
              _constants__WEBPACK_IMPORTED_MODULE_8__.Numbers.JUMPLINKS_MARGIN);
        } else {
          this.setOffset(this.options.offset);
        }
      } else {
        this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_8__.CssClasses.REWIND);
        this.unsetOffset();
      }
    }
    this.lastScrollPosition = window.scrollY;
  }
  setOffset(top) {
    this.root.style.top = `${top}px`;
  }
  unsetOffset() {
    this.root.style.top = '';
  }
  isRTL() {
    return document.documentElement.dir === _constants__WEBPACK_IMPORTED_MODULE_8__.Strings.RTL;
  }
}



/***/ }),

/***/ "./_glue/lib/math/coordinate.js":
/*!**************************************!*\
  !*** ./_glue/lib/math/coordinate.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Coordinate: () => (/* binding */ Coordinate)
/* harmony export */ });
/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */
/**
 * Class for representing coordinates and positions.
 */
class Coordinate {
  constructor(leftCoordinate = 0, topCoordinate = 0) {
    this.x = leftCoordinate;
    this.y = topCoordinate;
  }
  /**
   * Returns the difference between two coordinates as a new
   * Coordinate.
   */
  static difference(dimOne, dimTwo) {
    return new Coordinate(dimOne.x - dimTwo.x, dimOne.y - dimTwo.y);
  }
}



/***/ }),

/***/ "./_glue/lib/modal/constants.js":
/*!**************************************!*\
  !*** ./_glue/lib/modal/constants.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-modal';
CssClasses['CLOSE_BTN'] = 'glue-modal__close-btn';
CssClasses['CLOSING'] = 'glue-modal-closing';
CssClasses['OPEN'] = 'glue-modal-open';
CssClasses['NO_SCROLL'] = 'glue-no-scroll';
CssClasses['DARK'] = 'glue-modal--dark';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['OPENED_EVENT'] = 'GlueModal:opened';
Strings['CLOSED_EVENT'] = 'GlueModal:closed';
Strings['CLOSE_MODAL_LABEL'] = 'Close the modal';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/modal/index.js":
/*!**********************************!*\
  !*** ./_glue/lib/modal/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Modal: () => (/* binding */ Modal)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _focus___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../focus/ */ "./_glue/lib/focus/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./_glue/lib/modal/constants.js");








class Modal extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * Modal object providing focus management.
   * The element is present in the DOM and hidden.
   * The modal has role='dialog'.
   * @param el the element serving as the modal dialog.
   * @param focusAfterClosed The element to focus when the modal closes.
   * @param focusFirst The first element will receive focus after modal opens.
   */
  constructor(el, focusAfterClosed, focusFirst = null) {
    super(el);
    this.lastFocus = document.activeElement;
    this.ignoreFocusChange = false;
    this.ariaHiddenElements = [];
    /** Handle modal transition ends. */
    this.handleTransitionEnds = () => {
      this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.CLOSING);
      this.focusAfterClosed.focus();
      this.root.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnds);
    };
    this.closeBtn = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.CLOSE_BTN}`);
    this.focusAfterClosed = focusAfterClosed;
    this.focusFirst = focusFirst;
    this.handleCloseBtnClick = (e) => {
      e.stopPropagation();
      this.close();
    };
    this.handleKeyDown = (e) => {
      e.stopPropagation();
      const isEscape = e.code === _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ESC;
      if (isEscape) {
        this.close();
      }
    };
    this.handleFocus = (e) => {
      this.trapFocus(e);
    };
    this.init();
  }
  /**
   * Throw an error if close button does not exist.
   */
  init() {
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.DIALOG);
    this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_MODAL, 'true');
  }
  /**
   * Set focus on descendant nodes until the first focusable element is
   * found.
   * @param element DOM node for which to find the first focusable descendant.
   * @return true if a focusable element is found and focus is set.
   */
  focusFirstDescendant(element) {
    for (let i = 0; i < element.children.length; i++) {
      const child = element.children[i];
      if (this.attemptFocus(child) || this.focusFirstDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Find the last descendant node that is focusable.
   * @param element DOM node for which to find the last focusable descendant.
   * @return true if a focusable element is found and focus is set.
   */
  focusLastDescendant(element) {
    for (let i = element.children.length - 1; i >= 0; i--) {
      const child = element.children[i];
      if (this.attemptFocus(child) || this.focusLastDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Attempt to set focus on the current node.
   * @param element The node to attempt to focus on.
   * @return true if element is focused.
   */
  attemptFocus(element) {
    if (!(0,_focus___WEBPACK_IMPORTED_MODULE_4__.isElementFocusable)(element)) {
      return false;
    }
    this.ignoreFocusChange = true;
    try {
      element.focus();
    } catch (e) {
      throw new Error(`${e}`);
    }
    this.ignoreFocusChange = false;
    return element === document.activeElement;
  }
  /**
   * Trap focus inside the modal dialog.
   * @param e focus event.
   */
  trapFocus(e) {
    // Ignore the focus change so lastFocus does not get updated.
    if (this.ignoreFocusChange) {
      return;
    }
    // Move the focus to the element if it is inside of the Modal dialog,
    // otherwise, it moves to the first or last focusable element.
    if (this.root.contains(e.target)) {
      this.lastFocus = e.target;
    } else {
      this.focusFirstDescendant(this.root);
      if (this.lastFocus === document.activeElement) {
        this.focusLastDescendant(this.root);
      }
      this.lastFocus = document.activeElement;
    }
  }
  /**
   * Open the modal dialog.
   */
  open() {
    var _a;
    this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.OPEN);
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.OPENED_EVENT, {});
    (_a = this.closeBtn) === null || _a === void 0 ?
        void 0 :
        _a.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleCloseBtnClick);
    // Disable background scrolling
    document.body.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.NO_SCROLL);
    // Close modal on escape key
    document.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeyDown);
    // Trap focus in the modal when it catches a focus event.
    document.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus, true);
    // Focus on the first focusable element if it is not specified.
    if (this.focusFirst) {
      this.focusFirst.focus();
    } else {
      this.focusFirstDescendant(this.root);
    }
    this.ariaHideElements();
  }
  /**
   * Close the modal dialog and deregister event listeners.
   */
  close() {
    var _a;
    this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.OPEN);
    this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.CLOSING);
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.CLOSED_EVENT, {});
    // Deregister event listeners and add end modal
    document.body.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.NO_SCROLL);
    document.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.FOCUS, this.handleFocus, true);
    (_a = this.closeBtn) === null || _a === void 0 ?
        void 0 :
        _a.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.handleCloseBtnClick);
    document.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.handleKeyDown);
    this.root.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.TRANSITIONEND, this.handleTransitionEnds);
    this.ariaUnhideElements();
  }
  /**
   * Set aria hidden to true for all other elements.
   * This method provides complementary A11y support before aria-modal
   * The code is referenced from
   * https://source.corp.google.com/piper///depot/google3/googledata/html/external_content/scs_corp/ariablueprints/dialog/dialog-modal-1.0.html;l=81-101
   * gets broader browser support.
   */
  ariaHideElements() {
    let current = this.root;
    while (current && current.parentNode) {
      [...current.parentNode.children].forEach((child) => {
        if (child !== current && child.getAttribute('aria-hidden') !== 'true') {
          this.ariaHiddenElements.push(child);
          child.setAttribute('aria-hidden', 'true');
        }
      });
      current = current.parentNode;
    }
  }
  /**
   * Remove aria hidden to false for all other elements.
   */
  ariaUnhideElements() {
    this.ariaHiddenElements.forEach((el) => {
      el.removeAttribute('aria-hidden');
    });
    this.ariaHiddenElements = [];
  }
  setFocusAfterClosed(el) {
    this.focusAfterClosed = el;
  }
  destroy() {
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    this.root.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_MODAL);
  }
}



/***/ }),

/***/ "./_glue/lib/observer/index.js":
/*!*************************************!*\
  !*** ./_glue/lib/observer/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Observer: () => (/* binding */ Observer)
/* harmony export */ });
/**
 * @fileoverview An Observer class to create observables.
 */
/**
 * Observer generates observables for data tracking.
 */
class Observer {
  constructor(data) {
    this.data = data;
    // Create a map for keys and callbacks.
    this.watchers = new Map();
    // Generate an observable.
    this.walk(this.data);
  }
  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      this.defineReactive(obj, keys[i]);
    }
  }
  /**
   * Define a reactive property on an object.
   */
  defineReactive(obj, key, val) {
    const property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }
    // Use pre-defined getter/setters if they exist.
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () => {
        const value = getter ? getter.call(obj) : val;
        if (!this.watchers.has(key)) {
          this.watchers.set(key, []);
        }
        return value;
      },
      set: (newVal) => {
        const value = getter ? getter.call(obj) : val;
        if (newVal === value) {
          return;
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        this.notify(key);
      },
    });
  }
  /**
   * Add callback to the watchers list.
   * @param key The key or object that the model listens to
   *     changes on.
   */
  listen(key, callback) {
    if (typeof key === 'object') {
      Object.keys(key).forEach((prop) => {
        if (!this.watchers.has(prop)) {
          this.watchers.set(prop, []);
        }
        const callbacks = this.watchers.get(prop);
        if (callbacks) callbacks.push(callback);
      });
    } else {
      if (!this.watchers.has(key)) {
        this.watchers.set(key, []);
      }
      const callbacks = this.watchers.get(key);
      if (callbacks) callbacks.push(callback);
    }
  }
  /**
   * Remove callback from the watchers list.
   * @param key The key or object that the model listens to
   *     changes on.
   */
  unlisten(key, callback) {
    if (typeof key === 'object') {
      Object.keys(key).forEach((prop) => {
        if (this.watchers.has(prop)) {
          this.watchers.set(
              prop, this.watchers.get(prop).filter((val) => val !== callback));
        }
      });
    } else if (this.watchers.get(key)) {
      this.watchers.set(
          key, this.watchers.get(key).filter((val) => val !== callback));
    }
  }
  /**
   * Notify subscribers.
   */
  notify(key) {
    if (this.watchers.get(key)) {
      this.watchers.get(key).forEach((subscriber) => {
        subscriber.call(null);
      });
    }
  }
}



/***/ }),

/***/ "./_glue/lib/popover/constants.js":
/*!****************************************!*\
  !*** ./_glue/lib/popover/constants.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   CustomEvent: () => (/* binding */ CustomEvent),
/* harmony export */   DataAttr: () => (/* binding */ DataAttr),
/* harmony export */   PlacementOptions: () => (/* binding */ PlacementOptions),
/* harmony export */   RESIZE_DEBOUNCE_TIMING: () => (/* binding */ RESIZE_DEBOUNCE_TIMING),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * Custom popover placements
 */
var PlacementOptions;
(function(PlacementOptions) {
PlacementOptions['LEFT'] = 'left';
PlacementOptions['RIGHT'] = 'right';
PlacementOptions['TOP'] = 'top';
PlacementOptions['BOTTOM'] = 'bottom';
})(PlacementOptions || (PlacementOptions = {}));
var CssClasses;
(function(CssClasses) {
CssClasses['PREFIX'] = 'data-glue-popover';
CssClasses['ROOT'] = 'glue-popover';
CssClasses['TRIGGER'] = 'glue-popover__trigger';
CssClasses['DIALOG'] = 'glue-popover__dialog';
CssClasses['CLOSE_BTN'] = 'glue-popover__close-btn';
CssClasses['IS_SHOWN'] = 'glue-is-shown';
CssClasses['COPY'] = 'glue-copy';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['TRIGGER'] = 'trigger';
Strings['PLACEMENT'] = 'placement';
Strings['FOCUS'] = 'takeFocus';
Strings['ROOT'] = 'root';
Strings['MISSING_ID'] = 'Missing or invalid ID. Popover requires a unique ID';
Strings['MISSING_TRIGGER'] = 'Popover trigger element is missing';
Strings['MISSING_DIALOG'] = 'Popover dialog element is missing';
Strings['INCORRECT_PLACEMENT'] =
    'Placement value needs to be one of these: left, right, top, bottom.';
})(Strings || (Strings = {}));
var DataAttr;
(function(DataAttr) {
DataAttr['TRIGGER'] = 'gluePopoverTrigger';
})(DataAttr || (DataAttr = {}));
/**
 * Custom popover events
 */
var CustomEvent;
(function(CustomEvent) {
CustomEvent['OPEN_EVENT'] = 'gluepopovershow';
CustomEvent['CLOSE_EVENT'] = 'gluepopoverclose';
})(CustomEvent || (CustomEvent = {}));
/** Debounce timing for resize events */
const RESIZE_DEBOUNCE_TIMING = 250;



/***/ }),

/***/ "./_glue/lib/popover/index.js":
/*!************************************!*\
  !*** ./_glue/lib/popover/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlacementOptions: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_6__.PlacementOptions),
/* harmony export */   Popover: () => (/* binding */ Popover)
/* harmony export */ });
/* harmony import */ var _base___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ */ "./_glue/lib/base/index.js");
/* harmony import */ var _base_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/utils */ "./_glue/lib/base/utils.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../debounce */ "./_glue/lib/debounce/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./_glue/lib/popover/constants.js");









/**
 * A components that shows a popover component by toggling a button.
 *
 * Responsibilities:
 *  - Attach component instance to root element
 *  - Initialize options object
 *  - Provide public methods for open, close and destroy
 *  - Set attributes and aria tags to elements.
 *  - Access all DOM api needs directly
 *  - Set and remove all event listeners
 *  - Controls and sets focus to elements
 *
 * Design doc: https://goto.google.com/glue-popover-mdc-dd
 *
 */
class Popover extends _base___WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param rootElement The element that contains the popover.
   * @param options Popover options object.
   * @param buttonEl The element that opens the popover.
   * @param dialogEl The element for the popover dialog.
   */
  constructor(rootElement, options = {}, buttonEl, dialogEl) {
    super(rootElement);
    /**
     * Resize handler for the Popover.
     * Recalculate the position of the Popover when the window resizes.
     */
    this.handleResize = () => {
      this.setPopoverPosition();
    };
    /**
     * Resize debounce handler for the Popover.
     */
    this.handleResizeDebounce = () => {
      this.resizeDebounce.debounce();
    };
    // Compile the final set of options.
    this.options = Object.assign(
        {}, Popover.defaults, options, this.getAttributeOptions());
    if (!['top', 'bottom', 'left', 'right'].includes(this.options.placement)) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.INCORRECT_PLACEMENT);
    }
    this.clickOutsideDialogHandler = (evt) => {
      this.handleClickOutsideDialog(evt);
    };
    this.initInteractiveElements(buttonEl, dialogEl);
    this.resizeDebounce =
        new _debounce__WEBPACK_IMPORTED_MODULE_3__.Debounce(this.handleResize, _constants__WEBPACK_IMPORTED_MODULE_6__.RESIZE_DEBOUNCE_TIMING);
  }
  /**
   * Set up the button interactive elements.
   */
  initInteractiveElements(buttonEl, dialogEl) {
    // Get Button and Dialog elements if not already provided.
    if (buttonEl) {
      this.buttonEl = buttonEl;
    } else {
      this.buttonEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TRIGGER}`);
    }
    if (!this.buttonEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_TRIGGER);
    }
    if (dialogEl) {
      this.dialogEl = dialogEl;
    } else {
      this.dialogEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.DIALOG}`);
      if (!this.dialogEl) {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_DIALOG);
      }
    }
    this.closeEl = this.dialogEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.CLOSE_BTN}`);
    // Bind to event handlers.
    this.buttonClickHandler = (evt) => {
      this.handleButtonClick(evt);
    };
    this.keyDownHandler = (evt) => {
      this.handleKeyDown(evt);
    };
    // Add events to trigger element for key and trigger events (set in opts).
    this.buttonEl.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.buttonClickHandler);
    this.buttonEl.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.KEYDOWN, this.keyDownHandler);
    // Set listeners to handle an ESC key press or close btn when dialog open.
    this.dialogEl.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.KEYDOWN, this.keyDownHandler);
    this.dialogEl.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.buttonClickHandler);
    // Automatically resize the Popover when the window resizes.
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.RESIZE, this.handleResizeDebounce);
    // Sets element attrs mainly for a11y.
    this.setDefaultElAttr();
  }
  /**
   * Destroys the popover instance.
   */
  destroy() {
    this.close();
    // Remove event listeners
    this.buttonEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.buttonClickHandler);
    document.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.clickOutsideDialogHandler);
    this.dialogEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.KEYDOWN, this.keyDownHandler);
    this.buttonEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.KEYDOWN, this.keyDownHandler);
    this.dialogEl.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.buttonClickHandler);
    if (this.mouseLeaveHandler) {
      this.buttonEl.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.MOUSELEAVE, this.mouseLeaveHandler);
      this.dialogEl.removeEventListener(
          _events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.MOUSELEAVE, this.mouseLeaveHandler);
    }
    if (this.blurHandler) {
      window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.BLUR, this.blurHandler);
    }
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.RESIZE, this.handleResizeDebounce);
  }
  /**
   * If an event is from the specified element.
   */
  checkEventFromChild(element, event) {
    return event.target instanceof Node && element.contains(event.target);
  }
  /**
   * Get attributes from target element and constructor an options object.
   */
  getAttributeOptions() {
    const {PREFIX} = _constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses;
    const {PLACEMENT, FOCUS} = _constants__WEBPACK_IMPORTED_MODULE_6__.Strings;
    const options = {};
    const placement = this.root.getAttribute(`${PREFIX}-${PLACEMENT}`);
    const focus = this.root.getAttribute(`${PREFIX}-${FOCUS}`);
    if (placement) options[PLACEMENT] = placement;
    if (focus) options[FOCUS] = placement;
    return options;
  }
  /**
   *  Adds default attributes to the corresponding elements
   */
  setDefaultElAttr() {
    this.dialogEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Role.DIALOG);
    this.dialogEl.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.TabIndex.NOT_TABBABLE;
    this.dialogEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN, 'true');
    this.buttonEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Role.BUTTON);
    this.buttonEl.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.TabIndex.TABBABLE;
    this.buttonEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_EXPANDED, 'false');
    if (!this.dialogEl.id || this.dialogEl.id.length === 0) {
      this.dialogEl.id = `glue-popover-${Math.round(Math.random() * 99999999)}`;
    }
    // Set aria-controls (extend value if it already exists)
    const ariaControlsElements = [
      this.dialogEl.id,
      this.buttonEl.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_CONTROLS),
    ];
    this.buttonEl.setAttribute(
        _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_CONTROLS, ariaControlsElements.join(' ').trim());
    if (this.closeEl) {
      this.closeEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Role.BUTTON);
      this.closeEl.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.TabIndex.TABBABLE;
    }
  }
  /**
   * Set focus to element based on status
   */
  setElementFocus() {
    var _a;
    if (!this.options.takeFocus) return;
    (_a = this.buttonEl) === null || _a === void 0 ? void 0 : _a.focus();
  }
  /**
   * Shows popover and sets the pending flag.
   */
  open() {
    if (this.isOpen()) return;
    this.setPopoverPosition();
    this.dialogEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN, 'false');
    this.buttonEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_EXPANDED, 'true');
    this.root.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_SHOWN);
    document.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.clickOutsideDialogHandler);
    this.setElementFocus();
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_6__.CustomEvent.OPEN_EVENT, {}, true);
  }
  /**
   * Close popover and sets the pending flag
   */
  close() {
    if (!this.isOpen()) return;
    this.dialogEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN, 'true');
    this.buttonEl.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_EXPANDED, 'false');
    this.root.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_SHOWN);
    if (this.closeEl) this.closeEl.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_SHOWN);
    this.setElementFocus();
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_6__.CustomEvent.CLOSE_EVENT, {}, true);
    document.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK, this.clickOutsideDialogHandler);
  }
  /**
   * If the Dialog is currently open.
   */
  isOpen() {
    return this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_SHOWN);
  }
  /**
   * The handler is attached to the root element and handles a few cases
   * 1. Opens and closes the dialog via clicking trigger button.
   * 1. Closes the dialog via clicking close button.
   */
  handleButtonClick(event) {
    if (!this.isOpen()) {
      this.open();
    } else if (this.checkEventFromChild(this.buttonEl, event)) {
      this.close();
    } else if (
        this.closeEl && this.checkEventFromChild(this.closeEl, event) &&
        (!event.key || event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.ENTER || event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.SPACE)) {
      this.close();
    }
  }
  /**
   * Event handler for Escape key and Enter key.
   */
  handleKeyDown(event) {
    var _a, _b;
    event.stopPropagation();
    if (event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.ESC) {
      this.close();
    } else if (this.closeEl && this.checkEventFromChild(this.closeEl, event)) {
      // To prevent the mouseclick when pressing return key
      event.preventDefault();
      this.close();
    } else if (
        this.isOpen() && this.checkEventFromChild(this.buttonEl, event) &&
        event.shiftKey && event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.TAB) {
      event.preventDefault();
      this.close();
    } else if (
        !this.isOpen() && this.checkEventFromChild(this.buttonEl, event) &&
        (event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.ENTER || event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.SPACE)) {
      event.preventDefault();
      (_a = this.closeEl) === null || _a === void 0 ?
          void 0 :
          _a.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_SHOWN);
      this.open();
    }
    // Show close button when press TAB key.
    if (event.key === _events_key__WEBPACK_IMPORTED_MODULE_5__.Key.TAB &&
        this.checkEventFromChild(this.dialogEl, event)) {
      (_b = this.closeEl) === null || _b === void 0 ?
          void 0 :
          _b.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.IS_SHOWN);
    }
  }
  /**
   * Click handler for closing window if user clicks outside the open
   * dialog window.
   */
  handleClickOutsideDialog(event) {
    const containsTarget =
        event.target instanceof Node && this.root.contains(event.target);
    if (!this.checkEventFromChild(this.dialogEl, event) &&
        !this.checkEventFromChild(this.buttonEl, event) && !containsTarget &&
        event.type === _events_eventtype__WEBPACK_IMPORTED_MODULE_4__.EventType.CLICK) {
      this.close();
    }
  }
  /**
   * Calculate the position of the Popover.
   */
  setPopoverPosition() {
    const pos = (0,_base_utils__WEBPACK_IMPORTED_MODULE_1__.getOverlayAutoPosition)(
        this.root, this.dialogEl, this.buttonEl, this.options.placement);
    if (pos) {
      const [left, top] = pos;
      this.dialogEl.style.left = `${left}px`;
      this.dialogEl.style.top = `${top}px`;
    }
  }
  /**
   * Default popover options
   */
  static get defaults() {
    return {
      placement: _constants__WEBPACK_IMPORTED_MODULE_6__.PlacementOptions.BOTTOM,
      takeFocus: true,
    };
  }
}



/***/ }),

/***/ "./_glue/lib/responsivemonitor/index.js":
/*!**********************************************!*\
  !*** ./_glue/lib/responsivemonitor/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResponsiveMonitor: () => (/* binding */ ResponsiveMonitor)
/* harmony export */ });
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");

/**
 * Calls handler functions when the document object matches a media query, or
 * when a CSS-injected named breakpoint is included in a list of strings. Can
 * also call another handler when one of the condition above does not apply
 * anymore.
 *
 * This typically can be used to enable or disable a UI component based on the
 * viewport size.
 *
 * Example:
 *
 * new ResponsiveMonitor({
 *   breakpoint: ['medium', 'large'],
 *   enter: (size) => component.start(),
 *   leave: (size) => component.stop(),
 * });
 *
 * new ResponsiveMonitor({
 *   media: '(min-width: 600px)',
 *   transform: (mql) => component.start(),
 *   revert: (mql) => component.stop(),
 * });
 *
 * new ResponsiveMonitor([{
 *   media: '(max-width: 400px)',
 *   transform: (mql) => component1.start(),
 * }, {
 *   media: '(min-width: 501px) and (max-width: 800px)',
 *   transform: component2.start(),
 * }]);
 *
 * For simpler use cases, it is also possible to have a function called every
 * time the current breakpoint changes.
 *
 * const rm = new ResponsiveMonitor();
 * rm.listen((size) => {
 *   if (size == 'medium') {
 *     component.start();
 *   }
 * });
 */
class ResponsiveMonitor {
  /**
   * Returns unique monitor instance.
   */
  static getInstance() {
    if (!ResponsiveMonitor.instance) {
      ResponsiveMonitor.instance = new ResponsiveMonitor();
    }
    return ResponsiveMonitor.instance;
  }
  /**
   * @param configRules One or several media queries associated with callbacks
   *     to trigger when their result changes.
   */
  constructor(configRules = []) {
    this.vpUpdateHandler = () => {
      this.handleViewportUpdate();
    };
    /**
     * Registered media query rules;
     */
    this.mqRuleHandlerMaps = [];
    /**
     * Callback functions used to listen to breakpoint changes.
     */
    this.bpChangeHandlers = [];
    /**
     * Registered breakpoint rules.
     */
    this.bpRuleHandlerMaps = [];
    /**
     * The current named breakpoint.
     */
    this.currentBreakpoint = this.readBreakpoint();
    /**
     * The previous named breakpoint.
     */
    this.previousBreakpoint = '';
    // Setup media query rules
    if (!Array.isArray(configRules)) {
      configRules = [configRules];
    }
    configRules.forEach(this.addRule.bind(this));
    // Setup named breakpoints listening
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.DOM_CONTENT_READY, this.vpUpdateHandler);
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.RESIZE, this.vpUpdateHandler);
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.ORIENTATION_CHANGE, this.vpUpdateHandler);
  }
  /**
   * Listens to media query or breakpoint changes.
   */
  listen(handler) {
    if (typeof handler === 'function') {
      this.bpChangeHandlers.push(handler);
    } else {
      this.addRule(handler);
    }
  }
  /**
   * Stops listening to media query or breakpoint changes.
   */
  unlisten(handler) {
    if (typeof handler === 'function') {
      let handler;
      for (let i = 0; (handler = this.bpChangeHandlers[i]); i++) {
        if (handler === handler) {
          this.bpChangeHandlers.splice(i, 1);
          return;
        }
      }
    } else {
      this.removeRule(handler);
    }
  }
  /**
   * Stops listening to all media query and breakpoint rules.
   */
  destroy() {
    this.currentBreakpoint = '';
    for (const mq of this.mqRuleHandlerMaps) {
      // tslint:disable-next-line:deprecation
      mq.mql.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.CHANGE, mq.handler);
    }
    this.mqRuleHandlerMaps = [];
    this.bpRuleHandlerMaps = [];
    this.bpChangeHandlers = [];
    window.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.DOM_CONTENT_READY, this.vpUpdateHandler);
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.RESIZE, this.vpUpdateHandler);
    window.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.ORIENTATION_CHANGE, this.vpUpdateHandler);
  }
  /**
   * Returns the last known named breakpoint.
   */
  getCurrentBreakpoint() {
    return this.currentBreakpoint;
  }
  isBreakpointRule(rule) {
    return rule.breakpoint !== undefined;
  }
  isMediaQueryRuleRule(rule) {
    return rule.media !== undefined;
  }
  /**
   * Setup callback functions on a media query or a set of named breakpoints.
   * @param rule Configuration properties.
   */
  addRule(rule) {
    if (this.isBreakpointRule(rule)) {
      this.addBreakpointRule(rule);
      return;
    } else if (this.isMediaQueryRuleRule(rule)) {
      this.addMediaQueryRule(rule);
      return;
    }
  }
  /**
   * Disable callback functions on a media query or a set of named breakpoints.
   * @param rule Configuration properties.
   */
  removeRule(rule) {
    if (this.isBreakpointRule(rule)) {
      this.removeBreakpointRule(rule);
      return;
    } else if (this.isMediaQueryRuleRule(rule)) {
      this.removeMediaQueryRule(rule);
      return;
    }
  }
  /**
   * Setup callback functions on a set of named breakpoints.
   */
  addBreakpointRule(rule) {
    const checkBreakpoint = (size) => {
      const bps = rule.breakpoint;
      if (bps.indexOf(this.previousBreakpoint) === -1 &&
          bps.indexOf(this.currentBreakpoint) !== -1) {
        rule.enter(size);
        return;
      }
      if (rule.leave && bps.indexOf(this.previousBreakpoint) !== -1 &&
          bps.indexOf(this.currentBreakpoint) === -1) {
        rule.leave(size);
      }
    };
    // Keeps references for later unregistration purposes
    this.bpRuleHandlerMaps.push({
      rule,
      handler: checkBreakpoint,
    });
    checkBreakpoint(this.getCurrentBreakpoint());
    this.listen(checkBreakpoint);
  }
  /**
   * Disable callback functions on a set of named breakpoints.
   */
  removeBreakpointRule(rule) {
    let bpMap;
    for (let i = 0; (bpMap = this.bpRuleHandlerMaps[i]); i++) {
      if (bpMap.rule === rule) {
        this.unlisten(bpMap.handler);
      }
    }
  }
  /**
   * Setup callback functions on a media query.
   */
  addMediaQueryRule(rule) {
    const callback = this.handleMediaQueryChange(rule.transform, rule.revert);
    const mql = window.matchMedia(rule.media);
    // tslint:disable-next-line:no-any.
    const handler = () => {
      callback(mql);
    };
    // tslint:disable-next-line:deprecation
    mql.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.CHANGE, handler);
    // Keeps references for later unregistration purposes
    this.mqRuleHandlerMaps.push({
      rule,
      mql,
      handler,
    });
    // Triggers callback at once if the media query result is true.
    if (mql.matches) {
      callback(mql);
    }
  }
  /**
   * Disable callback functions on a media query.
   */
  removeMediaQueryRule(rule) {
    for (const mqMap of this.mqRuleHandlerMaps) {
      if (mqMap.rule === rule) {
        // tslint:disable-next-line:deprecation
        mqMap.mql.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_0__.EventType.CHANGE, mqMap.handler);
      }
    }
  }
  /**
   * Creates a function that will trigger callbacks based on the media
   * query's result.
   * @param transformFunc Function to call if the media query result is true.
   * @param revertFunc Function to call if the media query result reverts to
   *     false.
   * @return A function used as handler of a media query list.
   */
  handleMediaQueryChange(transformFunc, revertFunc) {
    return (mql) => {
      if (mql.matches) {
        transformFunc(mql);
      } else if (revertFunc) {
        revertFunc(mql);
      }
    };
  }
  /**
   * Fires breakpoint callbacks if the current named breakpoint parsed from the
   * DOM has changed since the previous call.
   */
  handleViewportUpdate() {
    const breakpoint = this.readBreakpoint();
    if (this.currentBreakpoint === breakpoint) {
      return;
    }
    this.previousBreakpoint = this.currentBreakpoint;
    this.currentBreakpoint = breakpoint;
    for (const handler of this.bpChangeHandlers) {
      handler(this.currentBreakpoint);
    }
  }
  /**
   * Retrieves the named breakpoint currently injected in DOM.
   */
  readBreakpoint() {
    const styles = window.getComputedStyle(document.body, ':after');
    const content = styles.getPropertyValue('content');
    const breakpoint = content.replace(/["']/g, '');
    return breakpoint;
  }
}



/***/ }),

/***/ "./_glue/lib/smoothscroll/constants.js":
/*!*********************************************!*\
  !*** ./_glue/lib/smoothscroll/constants.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScrollEventType: () => (/* binding */ ScrollEventType),
/* harmony export */   Strings: () => (/* binding */ Strings),
/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions)
/* harmony export */ });
/* harmony import */ var _easing___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing/ */ "./_glue/lib/easing/index.js");
/**
 * @fileoverview Config typedef and event enum for SmoothScroll.
 */

var ScrollEventType;
(function(ScrollEventType) {
ScrollEventType['STARTSCROLL'] = 'glue.smoothScroll.start';
ScrollEventType['ENDSCROLL'] = 'glue.smoothScroll.end';
})(ScrollEventType || (ScrollEventType = {}));
var Strings;
(function(Strings) {
Strings['MISSING_PAGE_ELEMENT'] =
    'Smooth Scrolling requires a valid page element.';
Strings['DIRECTION_MALFORMED'] =
    'Scroll direction value only accepts "x", "y" or "both"';
})(Strings || (Strings = {}));
const defaultOptions = {
  'duration': 600,
  'offset': {
    'x': 0,
    'y': 0,
  },
  'easing': _easing___WEBPACK_IMPORTED_MODULE_0__.easeInOutQuart,
  'hash': true,
  'direction': 'both',
};



/***/ }),

/***/ "./_glue/lib/smoothscroll/index.js":
/*!*****************************************!*\
  !*** ./_glue/lib/smoothscroll/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SmoothScroll: () => (/* binding */ SmoothScroll),
/* harmony export */   defaultOptions: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.defaultOptions)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./_glue/lib/smoothscroll/constants.js");
/* harmony import */ var _scrollmanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scrollmanager */ "./_glue/lib/smoothscroll/scrollmanager.js");
/**
 * @fileoverview The SmoothScroll module allows an animated smooth scroll from
 * one location within the document to another. It broadcasts events when
 * scrolling starts and ends. Configurable parameters include duration of the
 * scroll, offset of the target element, the easing function and URL hash.
 *
 * For documentation and demo see
 * https://glue-docs.appspot.com/docs/components/raw/smoothscroll
 */


class SmoothScroll {
  constructor(config) {
    this.currentScrollElementId = '';
    this.scrollManager = new _scrollmanager__WEBPACK_IMPORTED_MODULE_1__.ScrollManager();
    this.globalConfig = Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_0__.defaultOptions, config);
  }
  /**
   * Allows an animated smooth scroll from one location within the
   * document to another.
   * @param id Element id.
   * @param elementConfig The config object to use for the scroll.
   */
  scrollToId(id = '', elementConfig) {
    let element;
    // If asked to scroll to a non-fragment, just scroll to the first page
    // element, which is typically the top of the page. Otherwise, scroll to
    // a real element in the page.
    if (id === '' || id === '#') {
      element = document.body.firstElementChild;
    } else {
      element = document.getElementById(id);
      if (!element) {
        throw new Error(`The target element for id "${id}" does not exist.`);
      }
    }
    this.currentScrollElementId = id;
    this.currentScrollElement = element;
    // Build the config out of the element config and global config.
    elementConfig = Object.assign({}, this.globalConfig, elementConfig);
    // Ask the scroll manager to start the scroll.
    this.scrollManager.startScroll(this.currentScrollElement, elementConfig);
    const temp = window.scrollY;
    if (elementConfig['hash'] &&
        window.location.hash !== `#${this.currentScrollElementId}`) {
      window.location.hash = `#${this.currentScrollElementId}`;
    }
    document.documentElement.scrollTop = temp;
  }
  /**
   * Destroy the component. Removes listeners.
   */
  destroy() {
    this.scrollManager.destroy();
  }
}



/***/ }),

/***/ "./_glue/lib/smoothscroll/scrollmanager.js":
/*!*************************************************!*\
  !*** ./_glue/lib/smoothscroll/scrollmanager.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScrollManager: () => (/* binding */ ScrollManager)
/* harmony export */ });
/* harmony import */ var _easing___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing/ */ "./_glue/lib/easing/index.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./_glue/lib/smoothscroll/constants.js");
/**
 * @fileoverview Manages the scrolling animation operations for SmoothScroll.
 * Can be used independently of the SmoothScroll component to actuate scrolling.
 */





class ScrollManager {
  constructor() {
    this.elapsedTime = 0;
    this.startTime = 0;
    this.animationFrame = 0;
    this.position = {'x': 0, 'y': 0};
    this.distance = this.position;
    this.startPosition = this.position;
    this.endPosition = this.position;
    this.config = _constants__WEBPACK_IMPORTED_MODULE_2__.defaultOptions;
    this.mousewheelHandlerFunc = () => {
      this.mousewheelHandler();
    };
  }
  /**
   * Starts scroll, broadcasts 'start scroll' event and attaches mousewheel
   * event listener to window object.
   * @param element The element to scroll to.
   * @param config The config object for this scroll.
   */
  startScroll(element, config) {
    var _a;
    // Bail out if the scroll is in progress.
    if (this.animationFrame !== 0) return;
    if (!(element instanceof Element)) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_2__.Strings.MISSING_PAGE_ELEMENT);
    }
    // Broadcasts start scroll event globally.
    document.dispatchEvent(new Event(_constants__WEBPACK_IMPORTED_MODULE_2__.ScrollEventType.STARTSCROLL, {
      bubbles: true,
      cancelable: false,
    }));
    if (config) this.config = config;
    this.scrollElement = element;
    // Figure out the animation settings.
    this.startPosition = this.getScrollPosition();
    this.endPosition = this.getEndPosition(this.scrollElement);
    this.distance = {
      'x': this.endPosition.x - this.startPosition.x - this.config.offset.x,
      'y': this.endPosition.y - this.startPosition.y - this.config.offset.y,
    };
    this.easingFunction = typeof this.config.easing === 'string' ?
        _easing___WEBPACK_IMPORTED_MODULE_0__.easingFunctions[this.config.easing] :
        (_a = this.config.easing) !== null && _a !== void 0 ?
        _a :
        _easing___WEBPACK_IMPORTED_MODULE_0__.easingFunctions.linear;
    this.elapsedTime = 0;
    this.position = {'x': 0, 'y': 0};
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.MOUSEWHEEL, this.mousewheelHandlerFunc);
    this.animateScroll();
  }
  /**
   * Stops smooth scroll.
   */
  stopScroll() {
    // Broadcasts ENDSCROLL event globally.
    document.dispatchEvent(new Event(_constants__WEBPACK_IMPORTED_MODULE_2__.ScrollEventType.ENDSCROLL, {
      bubbles: true,
      cancelable: false,
    }));
    window.cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    this.startTime = 0;
    this.removeMousewheelListener();
    this.config = _constants__WEBPACK_IMPORTED_MODULE_2__.defaultOptions;
  }
  /**
   * Recursively scrolls the page until it reaches the element.
   */
  animateScroll() {
    // If there is no config, then quit. Fixes an issue where this
    // would be called one last time when cancelling mid-scroll.
    if (!this.startTime) {
      this.startTime = Date.now();
    }
    const now = Date.now();
    this.elapsedTime = now - this.startTime;
    this.calculatePosition();
    this.updatePosition();
    // Continues the animation until the timer reaches the end.
    if (this.elapsedTime < this.config.duration) {
      this.animationFrame = window.requestAnimationFrame(() => {
        this.animateScroll();
      });
    } else {
      this.stopScroll();
    }
  }
  /**
   * Calculates the position based on elapsed time.
   */
  calculatePosition() {
    var _a, _b;
    if (this.config.duration > 0) {
      const percentage = Math.min(this.elapsedTime / this.config.duration, 1);
      const value = this.easingFunction(percentage);
      this.position.x = this.startPosition.x +
          ((_a = this.distance) === null || _a === void 0 ? void 0 : _a.x) *
              value;
      this.position.y = this.startPosition.y +
          ((_b = this.distance) === null || _b === void 0 ? void 0 : _b.y) *
              value;
    } else {
      this.position = this.endPosition;
    }
  }
  /**
   * Gets the page scroll position.
   * @return Page scroll position.
   */
  getScrollPosition() {
    if (window.pageYOffset) {
      return {
        'x': window.pageXOffset,
        'y': window.pageYOffset,
      };
    } else {
      return {
        'x': document.documentElement.scrollLeft,
        'y': document.documentElement.scrollTop,
      };
    }
  }
  /**
   * Gets the scroll position of the element.
   * @return The scroll position of the element.
   */
  getEndPosition(el) {
    let rect = {left: 0, top: 0};
    if (el && 'getBoundingClientRect' in el) {
      rect = el.getBoundingClientRect();
    }
    return {
      'x': rect.left + this.getScrollPosition().x,
      'y': rect.top + this.getScrollPosition().y,
    };
  }
  /**
   * Updates scroll position.
   */
  updatePosition() {
    switch (this.config.direction) {
      case 'x':
        this.updateScrollLeft();
        break;
      case 'y':
        this.updateScrollTop();
        break;
      case 'both':
        this.updateScrollLeft();
        this.updateScrollTop();
        break;
      default:
        throw new Error();
    }
  }
  /**
   * Updates scroll left position.
   */
  updateScrollLeft() {
    // Scrolls to the element if requestAnimationFrame is not supported.
    const position = this.position.x;
    document.body.scrollLeft = position;
    document.documentElement.scrollLeft = position;
  }
  /**
   * Updates scroll top position.
   */
  updateScrollTop() {
    // Scrolls to the element if requestAnimationFrame is not supported.
    const position = this.position.y;
    document.body.scrollTop = position;
    document.documentElement.scrollTop = position;
  }
  /**
   * Handler function for mousewheel event.
   */
  mousewheelHandler() {
    if (this.animationFrame) {
      this.stopScroll();
    }
  }
  /**
   * Remove the moisewheel event listener.
   */
  removeMousewheelListener() {
    window.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_1__.EventType.MOUSEWHEEL, this.mousewheelHandlerFunc);
  }
  /**
   * Stopp the scrolling action and Destroy the component.
   */
  destroy() {
    this.stopScroll();
  }
}



/***/ }),

/***/ "./_glue/lib/social/constants.js":
/*!***************************************!*\
  !*** ./_glue/lib/social/constants.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses)
/* harmony export */ });
/**
 * @fileoverview Constants used by the Social component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['SOCIAL_ROOT'] = 'glue-social';
CssClasses['PERSISTENT_VARIANT'] = 'glue-social--persistent';
CssClasses['COLOR_VARIANT'] = 'glue-social--color';
CssClasses['MONOCHROME_VARIANT'] = 'glue-social--monochrome';
CssClasses['PARTIAL_MONOCHROME_VARIANT'] = 'glue-social--partialmonochrome';
CssClasses['PANELS_VARIANT'] = 'glue-social--zippy';
CssClasses['PANELS_OPPOSITE_VARIANT'] = 'glue-social--zippy-opposite';
CssClasses['SOCIAL_GROUP'] = 'glue-social__group';
CssClasses['SOCIAL_LIST'] = 'glue-social__list';
CssClasses['SOCIAL_TITLE'] = 'glue-social__title';
CssClasses['SOCIAL_TITLE_INLINE'] = 'glue-social__title--inline';
CssClasses['SOCIAL_TITLE_ZIPPY'] = 'glue-social__title--zippy';
CssClasses['SOCIAL_ITEM'] = 'glue-social__item';
CssClasses['COPY_ROOT'] = 'glue-social__copy';
CssClasses['COPY_BUTTON'] = 'glue-social__copy-btn';
CssClasses['COPY_INPUT'] = 'glue-social__copy-input';
CssClasses['PANELS_SHARE_ICON'] = 'glue-social__share-icon';
CssClasses['LINK_ROOT'] = 'glue-social__link';
CssClasses['ICON_CLASSES'] = 'glue-icon glue-icon--social glue-icon--24px';
CssClasses['POPOVER_ROOT'] = 'glue-social__popover';
CssClasses['POPOVER_CLOSE'] = 'glue-social__close-btn';
CssClasses['POPOVER_DIALOG'] = 'glue-social__dialog';
CssClasses['POPOVER_TRIGGER'] = 'glue-social__icon-trigger';
CssClasses['TOOLTIP_ROOT'] = 'glue-social__tooltip';
CssClasses['TOOLTIP_TRIGGER'] = 'glue-social__tooltip-trigger';
CssClasses['TOOLTIP_CONTENT'] = 'glue-social__tooltip-content';
CssClasses['VISUALLY_HIDDEN'] = 'glue-visually-hidden';
})(CssClasses || (CssClasses = {}));



/***/ }),

/***/ "./_glue/lib/social/index.js":
/*!***********************************!*\
  !*** ./_glue/lib/social/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Social: () => (/* binding */ Social)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _copy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../copy */ "./_glue/lib/copy/index.js");
/* harmony import */ var _copy_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../copy/constants */ "./_glue/lib/copy/constants.js");
/* harmony import */ var _expansionpanels__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../expansionpanels */ "./_glue/lib/expansionpanels/index.js");
/* harmony import */ var _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../expansionpanels/constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _popover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../popover */ "./_glue/lib/popover/index.js");
/* harmony import */ var _popover_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../popover/constants */ "./_glue/lib/popover/constants.js");
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tooltip */ "./_glue/lib/tooltip/index.js");
/* harmony import */ var _tooltip_constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tooltip/constants */ "./_glue/lib/tooltip/constants.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constants */ "./_glue/lib/social/constants.js");
/**
 * @fileoverview Glue Social component
 * Initializes available subcomponents (popover, copy, expansion panels)
 */













class Social extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @param root The social element container.
   */
  constructor(root) {
    super(root);
    this.tooltipComponents = [];
    // Grabs subcomponent elements if they exist
    this.copyEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.COPY_ROOT}`);
    this.popoverEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_ROOT}`);
    this.panelsEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.SOCIAL_GROUP}`);
    this.panelTitleEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.SOCIAL_TITLE}`);
    this.socialListEl = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.SOCIAL_LIST}`);
    this.tooltipEls =
        Array.from(this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.TOOLTIP_ROOT}`));
    this.initialize();
  }
  /** Initializes the component. */
  initialize() {
    this.addCopy();
    this.addPopover();
    this.addPanels();
    this.addTooltips();
  }
  /**
   * Destroys the social instance and any subcomponents.
   */
  destroy() {
    this.removeCopy();
    this.removePopover();
    this.removePanels();
    this.removeTooltips();
  }
  /**
   * Sets up copy component if elements are present
   */
  addCopy() {
    var _a, _b;
    const copyInput = (_a = this.copyEl) === null || _a === void 0 ?
        void 0 :
        _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.COPY_INPUT}`);
    const copyButton = (_b = this.copyEl) === null || _b === void 0 ?
        void 0 :
        _b.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.COPY_BUTTON}`);
    if (!this.copyEl || !copyInput || !copyButton) {
      return;
    }
    // Add classes and attributes to the various sub elements
    this.copyEl.classList.add(_copy_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.ROOT);
    copyInput.classList.add(_copy_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.VALUE);
    copyButton.classList.add(_copy_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.BUTTON);
    copyButton.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LIVE, 'polite');
    // Initialize the component
    this.copyComponent = new _copy__WEBPACK_IMPORTED_MODULE_2__.Copy(this.copyEl);
  }
  /**
   * Removes copy component if present
   */
  removeCopy() {
    var _a, _b, _c;
    const copyInput = (_a = this.copyEl) === null || _a === void 0 ?
        void 0 :
        _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.COPY_INPUT}`);
    const copyButton = (_b = this.copyEl) === null || _b === void 0 ?
        void 0 :
        _b.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.COPY_BUTTON}`);
    if (!this.copyEl || !copyInput || !copyButton) {
      return;
    }
    // Destroy the component
    (_c = this.copyComponent) === null || _c === void 0 ? void 0 : _c.destroy();
    // Remove classes and attributes
    this.copyEl.classList.remove(_copy_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.ROOT);
    copyInput.classList.remove(_copy_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.VALUE);
    copyButton.classList.remove(_copy_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.BUTTON);
    copyButton.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LIVE);
  }
  /**
   * Sets up popover component if elements are present
   */
  addPopover() {
    var _a, _b, _c;
    const popoverTrigger = (_a = this.popoverEl) === null || _a === void 0 ?
        void 0 :
        _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_TRIGGER}`);
    const popoverDialog = (_b = this.popoverEl) === null || _b === void 0 ?
        void 0 :
        _b.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_DIALOG}`);
    const popoverClose = (_c = this.popoverEl) === null || _c === void 0 ?
        void 0 :
        _c.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_CLOSE}`);
    if (!this.popoverEl || !popoverTrigger || !popoverDialog || !popoverClose) {
      return;
    }
    // Add classes and attributes to the various sub elements
    this.popoverEl.classList.add(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.ROOT);
    this.popoverEl.dataset[_popover_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttr.TRIGGER] = 'click';
    popoverTrigger.classList.add(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.TRIGGER);
    popoverDialog.classList.add(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.DIALOG);
    popoverClose.classList.add(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CLOSE_BTN);
    // Initialize the component
    this.popoverComponent = new _popover__WEBPACK_IMPORTED_MODULE_6__.Popover(this.popoverEl, {placement: 'right'});
  }
  /**
   * Removes popover component if present
   */
  removePopover() {
    var _a, _b, _c, _d;
    const popoverTrigger = (_a = this.popoverEl) === null || _a === void 0 ?
        void 0 :
        _a.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_TRIGGER}`);
    const popoverDialog = (_b = this.popoverEl) === null || _b === void 0 ?
        void 0 :
        _b.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_DIALOG}`);
    const popoverClose = (_c = this.popoverEl) === null || _c === void 0 ?
        void 0 :
        _c.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.POPOVER_CLOSE}`);
    if (!this.popoverEl || !popoverTrigger || !popoverDialog || !popoverClose) {
      return;
    }
    // Destroy the component
    (_d = this.popoverComponent) === null || _d === void 0 ? void 0 :
                                                             _d.destroy();
    // Remove classes and attributes
    this.popoverEl.classList.remove(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.ROOT);
    delete this.popoverEl.dataset[_popover_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttr.TRIGGER];
    popoverTrigger.classList.remove(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.TRIGGER);
    popoverDialog.classList.remove(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.DIALOG);
    popoverClose.classList.remove(_popover_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.CLOSE_BTN);
  }
  /**
   * Sets up expansion panels component if elements are present
   */
  addPanels() {
    if (!this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.PANELS_VARIANT) ||
        !this.panelsEl || !this.panelTitleEl || !this.socialListEl) {
      return;
    }
    // Add classes and attributes to the various sub elements
    const panelsId = this.root.id ? this.root.id : 'social-panels';
    this.root.classList.add(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.GROUP}`);
    this.root.dataset[_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.DataAttr.KEY] = panelsId;
    this.panelsEl.classList.add(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.PANEL}`);
    // Set up panel title/button
    const panelsButtonEl = document.createElement('button');
    panelsButtonEl.className = this.panelTitleEl.className;
    panelsButtonEl.classList.add(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.BUTTON}`);
    panelsButtonEl.id = panelsId + '-toggle';
    panelsButtonEl.dataset[_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.DataAttr.TOGGLEFOR] = panelsId + '-content';
    panelsButtonEl.replaceChildren(...this.panelTitleEl.childNodes);
    this.panelTitleEl.replaceChildren();
    this.panelTitleEl.className = '';
    this.panelTitleEl.appendChild(panelsButtonEl);
    this.panelTitleEl.classList.add(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.TOGGLE}`);
    // Set up panel content
    const panelContentEl = document.createElement('div');
    panelContentEl.classList.add(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.CONTENT}`);
    this.panelsEl.appendChild(panelContentEl);
    panelContentEl.appendChild(this.socialListEl);
    panelContentEl.id = panelsId + '-content';
    // Initialize the component
    this.expanelsComponent = new _expansionpanels__WEBPACK_IMPORTED_MODULE_4__.ExpansionPanels(this.root);
  }
  /**
   * Removes expansion panels component if present
   */
  removePanels() {
    var _a;
    if (!this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.PANELS_VARIANT) ||
        !this.panelsEl || !this.panelTitleEl || !this.socialListEl) {
      return;
    }
    // Destroy the component
    (_a = this.expanelsComponent) === null || _a === void 0 ? void 0 :
                                                              _a.destroy();
    // Remove panel content
    const panelContentEl =
        this.panelsEl.querySelector(`.${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.CONTENT}`);
    this.panelsEl.appendChild(this.socialListEl);
    panelContentEl === null || panelContentEl === void 0 ?
        void 0 :
        panelContentEl.remove();
    const panelsButtonEl =
        this.panelTitleEl.querySelector(`.${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.BUTTON}`);
    if (panelsButtonEl) {
      panelsButtonEl.classList.remove(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.BUTTON}`);
      this.panelTitleEl.className = panelsButtonEl.className;
      this.panelTitleEl.replaceChildren(...panelsButtonEl.childNodes);
      panelsButtonEl.remove();
    }
    // remove panels classes/attributes
    this.root.classList.remove(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.GROUP}`);
    delete this.root.dataset[_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.DataAttr.KEY];
    this.panelsEl.classList.remove(`${_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.PANEL}`);
  }
  /**
   * Sets up tooltip components if elements are present
   */
  addTooltips() {
    for (const tooltipEl of this.tooltipEls) {
      const tooltipTrigger =
          tooltipEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.TOOLTIP_TRIGGER}`);
      const tooltipContent =
          tooltipEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.TOOLTIP_CONTENT}`);
      if (tooltipTrigger && tooltipContent) {
        tooltipEl.classList.add(`${_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.CssClasses.ROOT}`);
        if (this.root.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.PERSISTENT_VARIANT)) {
          // Use manual positioning for persistent variant tooltips
          tooltipEl.dataset[_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.DataAttrs.AUTO_POSITION] = 'false';
        }
        tooltipTrigger.classList.add(`${_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.CssClasses.TRIGGER}`);
        tooltipContent.classList.add(`${_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.CssClasses.CONTENT}`);
        tooltipContent.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TOOLTIP);
        // Initialize tooltip Component
        this.tooltipComponents.push(new _tooltip__WEBPACK_IMPORTED_MODULE_8__.Tooltip(tooltipEl));
      }
    }
  }
  /**
   * Removes tooltip components if present
   */
  removeTooltips() {
    while (this.tooltipComponents.length > 0) {
      const tooltipComponent = this.tooltipComponents.pop();
      tooltipComponent === null || tooltipComponent === void 0 ?
          void 0 :
          tooltipComponent.destroy();
    }
    for (const tooltipEl of this.tooltipEls) {
      const tooltipTrigger =
          tooltipEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.TOOLTIP_TRIGGER}`);
      const tooltipContent =
          tooltipEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_10__.CssClasses.TOOLTIP_CONTENT}`);
      tooltipEl.classList.remove(`${_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.CssClasses.ROOT}`);
      delete tooltipEl.dataset[_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.DataAttrs.AUTO_POSITION];
      tooltipTrigger === null || tooltipTrigger === void 0 ?
          void 0 :
          tooltipTrigger.classList.remove(`${_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.CssClasses.TRIGGER}`);
      tooltipContent === null || tooltipContent === void 0 ?
          void 0 :
          tooltipContent.classList.remove(`${_tooltip_constants__WEBPACK_IMPORTED_MODULE_9__.CssClasses.CONTENT}`);
      tooltipContent === null || tooltipContent === void 0 ?
          void 0 :
          tooltipContent.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    }
  }
}



/***/ }),

/***/ "./_glue/lib/tabpanels/constants.js":
/*!******************************************!*\
  !*** ./_glue/lib/tabpanels/constants.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   DataAttr: () => (/* binding */ DataAttr),
/* harmony export */   Strings: () => (/* binding */ Strings)
/* harmony export */ });
/**
 * @fileoverview Constants used in Tab panels component.
 */
var CssClasses;
(function(CssClasses) {
CssClasses['TABPANEL_CONTAINER'] = 'glue-tabpanels';
CssClasses['TABPANEL_CENTERED'] = 'glue-tabpanels--centeredtabs';
CssClasses['TABPANEL_ICON'] = 'glue-tabpanels__heading-icon';
CssClasses['TABPANEL_PAGE_LIST'] = 'glue-tabpanels__page-list';
CssClasses['TABPANEL_PANEL_LIST'] = 'glue-tabpanels__panel-list';
CssClasses['TABPANEL_PANEL_TOGGLE'] = 'glue-tabpanels__panel-toggle';
CssClasses['TABPANEL_PANEL_BUTTON'] = 'glue-tabpanels__panel-button';
CssClasses['TABPANEL_PANEL_TITLE'] = 'glue-tabpanels__panel-title';
CssClasses['TABPANEL_PANEL_CONTENT'] = 'glue-tabpanels__panel-content';
CssClasses['TABPANEL_ELEMENT_SCOPE'] = 'glue-tabpanels__scope';
CssClasses['PANELS_TOGGLE_HEADER'] = 'glue-expansion-panel__button-header';
CssClasses['TABSET_ROOT'] = 'glue-tabs';
CssClasses['TABSET_TABLIST'] = 'glue-tabs__tablist';
CssClasses['TABSET_TAB'] = 'glue-tab';
CssClasses['TABSET_BUTTON'] = 'glue-tabs__button';
CssClasses['TABSET_PANELCONTAINER'] = 'glue-tabs__panelgroup';
CssClasses['TABSET_PAGE'] = 'glue-tabs__panel';
})(CssClasses || (CssClasses = {}));
var DataAttr;
(function(DataAttr) {
DataAttr['PANELS_KEY'] = 'glueExpansionPanelsKey';
DataAttr['TOGGLEFOR'] = 'glueExpansionPanelToggleFor';
DataAttr['INITIAL'] = 'glueExpansionPanelInitial';
})(DataAttr || (DataAttr = {}));
var Strings;
(function(Strings) {
Strings['MISSING_PAGE_LIST'] =
    'No element with glue-tabpanels__page-list class was found. TabPanels requires a Panels Page List';
Strings['MISSING_PANEL_LIST'] =
    'No element with glue-tabpanels__panel-list class was found. TabPanels requires a Panel List';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/tabpanels/index.js":
/*!**************************************!*\
  !*** ./_glue/lib/tabpanels/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabPanels: () => (/* binding */ TabPanels)
/* harmony export */ });
/* harmony import */ var _base_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/index */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _expansionpanels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expansionpanels */ "./_glue/lib/expansionpanels/index.js");
/* harmony import */ var _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../expansionpanels/constants */ "./_glue/lib/expansionpanels/constants.js");
/* harmony import */ var _responsivemonitor___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../responsivemonitor/ */ "./_glue/lib/responsivemonitor/index.js");
/* harmony import */ var _tabs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tabs */ "./_glue/lib/tabs/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./_glue/lib/tabpanels/constants.js");









class TabPanels extends _base_index__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, options) {
    super(root);
    this.options = Object.assign({}, TabPanels.defaults, options);
    // Set up expansion panel options
    this.panelsoptions = {
      isAnimated: this.options.isPanelsAnimated,
      panelsCount: this.options.panelsCount,
    };
    this.tablistEl =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_PAGE_LIST}`);
    this.panelsEl =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_PANEL_LIST}`);
    this.initialize();
  }
  /** Init the component. */
  initialize() {
    // Bail out if there are no elements for the panel and tabs.
    if (!this.tablistEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_PAGE_LIST);
    }
    if (!this.panelsEl) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_PANEL_LIST);
    }
    // Initially set up as tabs
    this.configureTabs(true);
    this.tabsComponent = new _tabs__WEBPACK_IMPORTED_MODULE_5__.Tabs(this.root);
    this.currentTab = this.tabsComponent.observer.data['currentTab'];
    if (this.options.isResponsive) {
      // Set up rules for Responsive Monitor
      this.responsiveTabsMonitor = new _responsivemonitor___WEBPACK_IMPORTED_MODULE_4__.ResponsiveMonitor({
        breakpoint: this.options.panelsBreakpoints,
        enter: () => {
          // Entering x-small/mobile breakpoint. Use expansion panels
          if (this.tabsComponent) {
            this.currentTab = this.tabsComponent.observer.data['currentTab'];
            this.tabsComponent.destroy();
            this.tabsComponent = undefined;
          }
          this.configureTabs(false);
          this.configureExpansionPanels(true, this.currentTab);
          this.panelsComponent =
              new _expansionpanels__WEBPACK_IMPORTED_MODULE_2__.ExpansionPanels(this.panelsEl, this.panelsoptions);
        },
        leave: () => {
          // Leaving x-small/mobile breakpoint. Use tabs
          if (this.panelsComponent) {
            this.panelsComponent.destroy();
            this.panelsComponent = undefined;
          }
          this.configureExpansionPanels(false, 0);
          this.configureTabs(true);
          this.tabsComponent = new _tabs__WEBPACK_IMPORTED_MODULE_5__.Tabs(this.root);
          this.tabsComponent.observer.data['currentTab'] = this.currentTab;
        },
      });
    }
  }
  /**
   * Default responsive tabs options.
   */
  static get defaults() {
    return {
      panelsBreakpoints: ['sm'],
      isPanelsAnimated: true,
      isResponsive: true,
      panelsCount: 2,
    };
  }
  /**
   * Set up the Tabs Component.
   */
  configureTabs(isTabs) {
    // Group settings
    this.root.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABSET_ROOT, isTabs);
    // Tab list
    this.tablistEl.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABSET_TABLIST, isTabs);
    // Temporarily set scope class for query selector scoping
    // This approximates :scope in the query selector
    this.tablistEl.classList.add(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
    const tabsEls = Array.from(this.tablistEl.querySelectorAll(
        `.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} > div`));
    for (const el of tabsEls) {
      el.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABSET_TAB, isTabs);
    }
    // Remove scope class
    this.tablistEl.classList.remove(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
    // Tabs (shared with Panels group element)
    this.panelsEl.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABSET_PANELCONTAINER, isTabs);
    // Temporarily set scope class for query selector scoping
    this.panelsEl.classList.add(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
    const panelsEls = Array.from(this.panelsEl.querySelectorAll(
        `.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} > div`));
    for (const panelEl of panelsEls) {
      panelEl.classList.toggle(_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABSET_PAGE, isTabs);
    }
    // Remove scope class
    this.panelsEl.classList.remove(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
  }
  /**
   * Set up the Expansion Panels Component.
   */
  configureExpansionPanels(isPanels, currentTab) {
    // Group settings
    this.panelsEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.GROUP, isPanels);
    // Individual panel settings
    let panelCount = 1;
    // Temporarily set scope class for query selector scoping
    // This approximates :scope in the query selector
    this.panelsEl.classList.add(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
    const panelsEls = Array.from(this.panelsEl.querySelectorAll(
        `.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} > div`));
    for (const panelEl of panelsEls) {
      // Temporarily set scope class for query selector scoping
      panelEl.classList.add(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
      panelEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.PANEL, isPanels);
      panelEl.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_HIDDEN);
      const panelToggleEl =
          panelEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} > .${
              _constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_PANEL_TOGGLE}`);
      panelToggleEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.TOGGLE, isPanels);
      const panelButtonEl = panelToggleEl.querySelector(
          `.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} > .${
              _constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_PANEL_TOGGLE} > :first-child`);
      panelButtonEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.BUTTON, isPanels);
      const panelTitleEl =
          panelToggleEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} .${
              _constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_PANEL_TITLE}`);
      panelTitleEl.classList.toggle(
          _expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.HEADER_TEXT, isPanels);
      const panelContentEl =
          panelEl.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE} > .${
              _constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_PANEL_CONTENT}`);
      panelContentEl.classList.toggle(_expansionpanels_constants__WEBPACK_IMPORTED_MODULE_3__.CssClasses.CONTENT, isPanels);
      if (isPanels) {
        panelButtonEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.DataAttr.TOGGLEFOR] = panelContentEl.id;
        if (panelCount === currentTab) {
          // Set current tab to render as expanded
          panelContentEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.DataAttr.INITIAL] = 'expanded';
        }
        panelCount++;
      } else {
        delete panelButtonEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.DataAttr.TOGGLEFOR];
        delete panelContentEl.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.DataAttr.INITIAL];
      }
      // Remove scope class
      panelEl.classList.remove(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
    }
    // Remove scope class
    this.panelsEl.classList.remove(`${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABPANEL_ELEMENT_SCOPE}`);
  }
  /**
   * @see {Component.destroy}
   */
  destroy() {
    // Destroy subcomponents if set
    if (this.panelsComponent) {
      this.panelsComponent.destroy();
      this.panelsComponent = undefined;
      this.configureExpansionPanels(false, 0);
    }
    if (this.tabsComponent) {
      this.tabsComponent.destroy();
      this.tabsComponent = undefined;
      this.configureTabs(false);
    }
    // Destroy responsive monitor instance if set
    if (this.responsiveTabsMonitor) {
      this.responsiveTabsMonitor.destroy();
    }
  }
}



/***/ }),

/***/ "./_glue/lib/tabs/constants.js":
/*!*************************************!*\
  !*** ./_glue/lib/tabs/constants.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   Strings: () => (/* binding */ Strings),
/* harmony export */   TabsAttrs: () => (/* binding */ TabsAttrs)
/* harmony export */ });
/**
 * Data attribute used for query selecting a specific tab.
 */
var TabsAttrs;
(function(TabsAttrs) {
TabsAttrs['CURRENT'] = 'glueTabsCurrent';
})(TabsAttrs || (TabsAttrs = {}));
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-tabs';
CssClasses['TABLIST'] = 'glue-tabs__tablist';
CssClasses['TAB'] = 'glue-tab';
CssClasses['PANEL'] = 'glue-tabs__panel';
CssClasses['PANELGROUP'] = 'glue-tabs__panelgroup';
CssClasses['IS_SHOWN'] = 'glue-is-shown';
})(CssClasses || (CssClasses = {}));
var Strings;
(function(Strings) {
Strings['TRIGGER'] = 'trigger';
Strings['PLACEMENT'] = 'placement';
Strings['FOCUS'] = 'takeFocus';
Strings['ROOT'] = 'root';
Strings['MISSING_TABLIST'] = 'Tablist element is missing.';
Strings['MISSING_TABS'] = 'Tabs element is missing.';
Strings['MISSING_TABPANELS'] = 'Tab panels element is missing.';
Strings['DATA_CURRENT'] = 'currentTab';
})(Strings || (Strings = {}));



/***/ }),

/***/ "./_glue/lib/tabs/index.js":
/*!*********************************!*\
  !*** ./_glue/lib/tabs/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tabs: () => (/* binding */ Tabs)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _constants_classes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/classes */ "./_glue/lib/constants/classes.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../observer */ "./_glue/lib/observer/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./_glue/lib/tabs/constants.js");









/**
 * Static Tabs creates tabs of content in a progressive, enhanced way and
 * is accessible through keyboard and screen reader.
 */
class Tabs extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  /**
   * @see {Compoment.constructor}
   */
  constructor(root, options = {currentTab: 1}) {
    super(root);
    /**
     * Handles a click.
     * @param e The event from the click.
     */
    this.handleClick = (e) => {
      // Ignore clicks on elements that aren't tabs.
      if (e.target instanceof Element) {
        const tabEl = e.target.closest(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TAB}`);
        if (tabEl === null) {
          return;
        }
        this.setActiveTab([...this.tabs].indexOf(tabEl) + 1);
      }
    };
    /**
     * Handles key press events to trigger changing the selected page. When the
     * user uses arrow left/right, it changes the active tab in the component.
     */
    this.handleKeydown = (e) => {
      if (e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.RIGHT || e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.LEFT) {
        if (e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.RIGHT) {
          this.setActiveTab(this.getActiveTab() + 1);
        } else if (e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.LEFT) {
          this.setActiveTab(this.getActiveTab() - 1);
        }
        if (this.getActiveTab() === 0) {
          this.setActiveTab(this.totalTabs);
        } else if (this.getActiveTab() === this.totalTabs + 1) {
          this.setActiveTab(1);
        }
      }
      if (e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.HOME) {
        this.setActiveTab(1);
      }
      if (e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.END) {
        this.setActiveTab(this.totalTabs);
      }
      if (e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.RIGHT || e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.LEFT || e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.HOME ||
          e.code === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.END) {
        this.tabs[this.getActiveTab() - 1].focus();
      }
    };
    /** Tablist element */
    this.tablist = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TABLIST}`);
    /** A list of tabs elements. */
    this.tabs = Array.from(this.tablist.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.TAB}`));
    /** A list of tab panels elements. */
    this.tabPanels =
        Array.from(this.root.querySelectorAll(`.${_constants__WEBPACK_IMPORTED_MODULE_6__.CssClasses.PANEL}`));
    /** Total number of tabs. */
    this.totalTabs = this.tabs.length;
    this.currentTabChangeHandler = () => {
      this.render();
    };
    this.validateElements();
    this.setAriaRoles();
    // Add observer instance and attach listener to the currentTab data
    const val = this.getDataAttribute();
    let currentTab = 1;
    if (this.isValidTab(val)) {
      currentTab = val;
    } else if (this.isValidTab(options.currentTab)) {
      currentTab = options.currentTab;
    }
    this.observer = new _observer__WEBPACK_IMPORTED_MODULE_5__.Observer({
      'currentTab': currentTab,
    });
    this.observer.listen('currentTab', this.currentTabChangeHandler);
    this.tablist.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.CLICK, this.handleClick);
    this.tablist.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.KEYDOWN, this.handleKeydown);
    this.render();
  }
  validateElements() {
    if (!this.tablist) throw new Error(`${_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_TABLIST}`);
    if (this.tabs.length === 0) {
      throw new Error(`${_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_TABS}`);
    }
    if (this.tabPanels.length === 0) {
      throw new Error(`${_constants__WEBPACK_IMPORTED_MODULE_6__.Strings.MISSING_TABPANELS}`);
    }
  }
  /** Get the current Tab value from data attributes. */
  getDataAttribute() {
    return Number(this.root.dataset[_constants__WEBPACK_IMPORTED_MODULE_6__.TabsAttrs.CURRENT]);
  }
  /** Render the Tabs component. */
  render() {
    const currentPage = this.getActiveTab();
    if (currentPage < 1 || currentPage > this.totalTabs) {
      return;
    }
    for (const [index, el] of this.tabs.entries()) {
      const isSelected = index === currentPage - 1;
      el.tabIndex = isSelected ? _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.TABBABLE : _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.TabIndex.NOT_TABBABLE;
      el.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_SELECTED, isSelected.toString());
    }
    for (const el of this.tabPanels) {
      el.classList.remove(_constants_classes__WEBPACK_IMPORTED_MODULE_2__.CssClasses.SHOW);
    }
    this.tabPanels[currentPage - 1].classList.add(_constants_classes__WEBPACK_IMPORTED_MODULE_2__.CssClasses.SHOW);
  }
  /**
   * Provide spoken feedback to describe this component as tabs. If you've
   * added new dom, you'll want to call this method.
   */
  setAriaRoles() {
    this.tablist.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TABLIST);
    this.tabs.forEach((el, index) => {
      el.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TAB);
      el.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS, this.tabPanels[index].id);
    });
    this.tabPanels.forEach((el, index) => {
      el.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY, this.tabs[index].id);
      el.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.TABPANEL);
    });
  }
  /** Remove all aria roles. */
  removeAriaRoles() {
    this.tablist.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    for (const el of this.tabs) {
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_CONTROLS);
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.TAB_INDEX);
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_SELECTED);
    }
    for (const el of this.tabPanels) {
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ARIA_LABELLEDBY);
      el.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE);
    }
  }
  setActiveTab(idx) {
    this.observer.data.currentTab = idx;
  }
  getActiveTab() {
    return this.observer.data.currentTab;
  }
  /**
   * Return true if the tab index value is between 1 and the total tabs count.
   */
  isValidTab(val) {
    return Number.isInteger(val) && val >= 1 && val <= this.totalTabs;
  }
  /** Restores DOM back to previous state and removes event listeners. */
  destroy() {
    this.observer.unlisten('currentTab', this.currentTabChangeHandler);
    this.tablist.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.CLICK, this.handleClick);
    this.tablist.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.KEYDOWN, this.handleKeydown);
    this.removeAriaRoles();
    this.observer = new _observer__WEBPACK_IMPORTED_MODULE_5__.Observer({
      'currentTab': 1,
    });
  }
}



/***/ }),

/***/ "./_glue/lib/tooltip/constants.js":
/*!****************************************!*\
  !*** ./_glue/lib/tooltip/constants.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   CustomEvent: () => (/* binding */ CustomEvent),
/* harmony export */   DataAttrs: () => (/* binding */ DataAttrs),
/* harmony export */   ErrorMessage: () => (/* binding */ ErrorMessage)
/* harmony export */ });
var CssClasses;
(function(CssClasses) {
CssClasses['ROOT'] = 'glue-tooltip';
CssClasses['ANIMATION'] = 'glue-tooltip__content--animation';
CssClasses['BODY'] = 'glue-tooltip__body';
CssClasses['CONTENT'] = 'glue-tooltip__content';
CssClasses['HEADER'] = 'glue-tooltip__header';
CssClasses['LINK'] = 'glue-tooltip__link';
CssClasses['RICH'] = 'glue-tooltip--rich';
CssClasses['SHOW_TOOLTIP'] = 'glue-tooltip__content--shown';
CssClasses['TRIGGER'] = 'glue-tooltip__trigger';
CssClasses['TRIGGER_LINK'] = 'glue-tooltip__trigger--link';
CssClasses['TRIGGER_ICON'] = 'glue-tooltip__trigger--icon';
CssClasses['TRIGGER_ICONAFTER'] = 'glue-tooltip__trigger--icon-after';
CssClasses['TONAL_LINK'] = 'glue-inline-tonal-link';
})(CssClasses || (CssClasses = {}));
/**
 * Custom tooltip events
 */
var CustomEvent;
(function(CustomEvent) {
CustomEvent['CLOSE_EVENT'] = 'gluetooltipclose';
CustomEvent['SHOW_EVENT'] = 'gluetooltipshow';
})(CustomEvent || (CustomEvent = {}));
var ErrorMessage;
(function(ErrorMessage) {
ErrorMessage['MISSING_CONTENT'] = 'The tooltip content element is missing';
ErrorMessage['MISSING_TRIGGER'] = 'The tooltip trigger element is missing';
ErrorMessage['INCORRECT_POSITION'] =
    'data-glue-tooltip-auto-position attribute only accepts true or false value.';
})(ErrorMessage || (ErrorMessage = {}));
var DataAttrs;
(function(DataAttrs) {
DataAttrs['AUTO_POSITION'] = 'glueTooltipAutoPosition';
})(DataAttrs || (DataAttrs = {}));



/***/ }),

/***/ "./_glue/lib/tooltip/index.js":
/*!************************************!*\
  !*** ./_glue/lib/tooltip/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: () => (/* binding */ Tooltip),
/* harmony export */   initMultiTooltip: () => (/* binding */ initMultiTooltip)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./_glue/lib/base/index.js");
/* harmony import */ var _base_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/utils */ "./_glue/lib/base/utils.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./_glue/lib/tooltip/constants.js");








/**
 * A component that pops up when you hover over an interactive object.
 *
 * Responsibilities:
 *  - Provide public methods for open, close and destroy
 *  - Add ARIA labels for a11y
 *  - Reposition tooltip when it is on the edge of the page
 *  - Customize Tooltip by turning on/off auto position
 *  - Expose Tooltip show and hide events
 */
class Tooltip extends _base__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, options) {
    super(root);
    /**
     * Checks target element and calls method for tooltip display.
     */
    this.handleOpen = (event) => {
      const targetEl = event.target;
      if (targetEl instanceof HTMLElement && this.isTooltipChild(targetEl)) {
        this.open();
      }
    };
    /**
     * Checks target element and calls method for tooltip hide.
     */
    this.handleClose = (event) => {
      const targetEl = event.target;
      if (targetEl instanceof HTMLElement && this.isTooltipChild(targetEl)) {
        this.close();
      }
    };
    /**
     * Event handler for Escape key.
     */
    this.handleKeyup = (event) => {
      const targetEl = event.target;
      if (event.key === _events_key__WEBPACK_IMPORTED_MODULE_4__.Key.ESC) {
        if (targetEl instanceof HTMLElement &&
            this.content.contains(targetEl)) {
          this.trigger.focus();
        }
        this.close();
      }
    };
    /**
     * Checks click on document and calls method for tooltip display.
     */
    this.handleClick = (event) => {
      const targetEl = event.target;
      if (targetEl instanceof HTMLElement && !this.isTooltipChild(targetEl)) {
        this.close();
      }
    };
    /**
     * Adds animation class on tooltip transition start.
     */
    this.handleTransitionStart = () => {
      if (this.content.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.SHOW_TOOLTIP)) {
        this.content.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ANIMATION);
      }
    };
    /**
     * Removes animation class on tooltip transition end.
     */
    this.handleTransitionEnd = () => {
      if (this.content.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.SHOW_TOOLTIP)) return;
      this.content.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ANIMATION);
    };
    /**
     * Recalculates the tooltip position and displays it properly as per updated
     * screen size.
     */
    this.handleResize = () => {
      this.setTooltipPosition();
    };
    let element = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.TRIGGER}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.ErrorMessage.MISSING_TRIGGER);
    } else {
      this.trigger = element;
    }
    element = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.CONTENT}`);
    if (!element) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.ErrorMessage.MISSING_CONTENT);
    } else {
      this.content = element;
      this.content.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN, 'true');
      // Set aria-controls (extend value if it already exists)
      const ariaControlsElements = [
        this.content.id,
        this.trigger.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_CONTROLS),
      ];
      this.trigger.setAttribute(
          _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_CONTROLS, ariaControlsElements.join(' ').trim());
      if (this.content.getAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ROLE) === _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Role.DIALOG) {
        this.content.tabIndex = _constants_attribute__WEBPACK_IMPORTED_MODULE_2__.TabIndex.TABBABLE;
      }
    }
    // Compile the final set of options.
    this.options = this.getAttributeOptions(options);
    this.registerEvents();
  }
  /**
   * Checks if the element is present inside the tooltip.
   * @param targetEl DOM node which is to be checked
   * @return true if DOM node is present in tooltip
   */
  isTooltipChild(targetEl) {
    return this.trigger.contains(targetEl) || this.content.contains(targetEl) ?
        true :
        false;
  }
  /**
   * Get attributes from target element and construct an options object.
   */
  getAttributeOptions(passedOptions) {
    const attrOptions = {};
    const attrData = this.root.dataset;
    if (_constants__WEBPACK_IMPORTED_MODULE_5__.DataAttrs.AUTO_POSITION in attrData) {
      let setPosition;
      if (attrData[_constants__WEBPACK_IMPORTED_MODULE_5__.DataAttrs.AUTO_POSITION] === 'false') {
        setPosition = false;
      } else if (attrData[_constants__WEBPACK_IMPORTED_MODULE_5__.DataAttrs.AUTO_POSITION] === 'true') {
        setPosition = true;
      } else {
        throw new Error(_constants__WEBPACK_IMPORTED_MODULE_5__.ErrorMessage.INCORRECT_POSITION);
      }
      attrOptions.autoPosition = setPosition;
    }
    const fullOptions =
        Object.assign({}, Tooltip.defaultOptions, passedOptions, attrOptions);
    return fullOptions;
  }
  /**
   * Default Tooltip options
   */
  static get defaultOptions() {
    return {
      autoPosition: true,
    };
  }
  /**
   * Adds events for the tooltip.
   */
  registerEvents() {
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.MOUSEENTER, this.handleOpen, true);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.FOCUS, this.handleOpen, true);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.MOUSELEAVE, this.handleClose, true);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.BLUR, this.handleClose, true);
    document.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.KEYUP, this.handleKeyup);
    document.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.CLICK, this.handleClick);
    window.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.RESIZE, this.handleResize);
    this.content.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.TRANSITIONSTART, this.handleTransitionStart);
    this.content.addEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.TRANSITIONEND, this.handleTransitionEnd);
  }
  /**
   * Calculates the position of the Tooltip.
   */
  setTooltipPosition() {
    if (this.options.autoPosition === true) {
      const pos = (0,_base_utils__WEBPACK_IMPORTED_MODULE_1__.getOverlayAutoPosition)(
          this.root, this.content, this.trigger, this.options.placement);
      if (pos) {
        const [left, top] = pos;
        this.content.style.left = `${left}px`;
        this.content.style.top = `${top}px`;
      }
    }
  }
  /**
   * Displays the tooltip.
   */
  open() {
    if (this.content.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.SHOW_TOOLTIP)) return;
    this.setTooltipPosition();
    this.content.classList.add(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.SHOW_TOOLTIP);
    this.content.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN, 'false');
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_5__.CustomEvent.SHOW_EVENT, {}, true);
  }
  /**
   * Hides the tooltip.
   */
  close() {
    if (!this.content.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.SHOW_TOOLTIP)) return;
    this.content.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.SHOW_TOOLTIP);
    this.content.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN, 'true');
    this.emit(_constants__WEBPACK_IMPORTED_MODULE_5__.CustomEvent.CLOSE_EVENT, {}, true);
  }
  /** Resets component and removes event listeners. */
  destroy() {
    this.close();
    this.content.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_HIDDEN);
    this.trigger.removeAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_2__.Attribute.ARIA_CONTROLS);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.MOUSEENTER, this.handleOpen, true);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.FOCUS, this.handleOpen, true);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.MOUSELEAVE, this.handleClose, true);
    this.root.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.BLUR, this.handleClose, true);
    document.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.KEYUP, this.handleKeyup);
    document.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.CLICK, this.handleClick);
    window.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.RESIZE, this.handleResize);
    this.content.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.TRANSITIONSTART, this.handleTransitionStart);
    this.content.removeEventListener(
        _events_eventtype__WEBPACK_IMPORTED_MODULE_3__.EventType.TRANSITIONEND, this.handleTransitionEnd);
  }
}
/**
 * Initializes multiple tooltips with single call.
 */
function initMultiTooltip(tooltipElems) {
  [...tooltipElems].forEach((tooltipElem) => {
    // tslint:disable-next-line:no-unused-expression
    new Tooltip(tooltipElem);
  });
}



/***/ }),

/***/ "./_glue/lib/ytvideo/constants.js":
/*!****************************************!*\
  !*** ./_glue/lib/ytvideo/constants.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssClasses: () => (/* binding */ CssClasses),
/* harmony export */   DataAttrs: () => (/* binding */ DataAttrs),
/* harmony export */   ErrorMessages: () => (/* binding */ ErrorMessages)
/* harmony export */ });
/**
 * Component element data attribute names used as player options.
 */
var DataAttrs;
(function(DataAttrs) {
DataAttrs['VIDEO_ID'] = 'glueYtVideoVid';
DataAttrs['PLAYER_ID'] = 'glueYtPlayerId';
DataAttrs['HEIGHT'] = 'glueYtVideoHeight';
DataAttrs['WIDTH'] = 'glueYtVideoWidth';
DataAttrs['PLAYER_VARS'] = 'glueYtVideoPlayerVars';
})(DataAttrs || (DataAttrs = {}));
var CssClasses;
(function(CssClasses) {
CssClasses['BASE'] = 'glue-video';
CssClasses['PREVIEW_CONTAINER'] = 'glue-video__preview-container';
CssClasses['DURATION'] = 'glue-video__timestamp-duration';
CssClasses['HIDE_ELEMENT'] = 'glue-video--hidden';
CssClasses['IMAGE_CONTAINER'] = 'glue-video__preview-image';
CssClasses['TIMESTAMP'] = 'glue-video__timestamp';
CssClasses['TIMESTAMP_SHOW'] = 'glue-video__timestamp--visible';
CssClasses['VIDEO_CONTAINER'] = 'glue-video__container';
CssClasses['INLINE_VIDEO'] = 'glue-video__preview-container--inline';
CssClasses['LABEL'] = 'glue-video__label';
})(CssClasses || (CssClasses = {}));
var ErrorMessages;
(function(ErrorMessages) {
ErrorMessages['MISSING_VIDEO'] = 'The video element is missing';
})(ErrorMessages || (ErrorMessages = {}));



/***/ }),

/***/ "./_glue/lib/ytvideo/index.js":
/*!************************************!*\
  !*** ./_glue/lib/ytvideo/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YoutubeVideo: () => (/* binding */ YoutubeVideo)
/* harmony export */ });
/* harmony import */ var _base_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/index */ "./_glue/lib/base/index.js");
/* harmony import */ var _constants_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/attribute */ "./_glue/lib/constants/attribute.js");
/* harmony import */ var _events_eventtype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/eventtype */ "./_glue/lib/events/eventtype.js");
/* harmony import */ var _events_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/key */ "./_glue/lib/events/key.js");
/* harmony import */ var _focus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../focus */ "./_glue/lib/focus/index.js");
/* harmony import */ var _modal_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modal/constants */ "./_glue/lib/modal/constants.js");
/* harmony import */ var _modal_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../modal/index */ "./_glue/lib/modal/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "./_glue/lib/ytvideo/constants.js");
/* harmony import */ var _videomanager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./videomanager */ "./_glue/lib/ytvideo/videomanager.js");
// taze: youtube from //third_party/javascript/typings/youtube











/**
 * Creates a YouTube Video component with access to the controls API.
 */
class YoutubeVideo extends _base_index__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(root, options) {
    var _a, _b;
    super(root);
    // Unique element id for the player.
    this.id = '';
    /**
     * Hides image overlay and plays video.
     */
    this.hidePosterAndPlay = (e) => {
      var _a, _b;
      if (this.videoElement.contains(e.target)) return;
      // Return if it is a keyboard event, but not Enter key or Space key.
      if (e instanceof KeyboardEvent && e.key !== _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.ENTER &&
          e.key !== _events_key__WEBPACK_IMPORTED_MODULE_3__.Key.SPACE) {
        return;
      }
      if (this.modal) {
        e.preventDefault();
        this.modal.open();
      } else {
        (_a = this.previewElement) === null || _a === void 0 ?
            void 0 :
            _a.classList.add(_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.HIDE_ELEMENT);
        this.videoElement.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.HIDE_ELEMENT);
        this.root.blur();  // Allows iframe to be clicked
      }
      (_b = this.getPlayer()) === null || _b === void 0 ? void 0 :
                                                          _b.playVideo();
    };
    this.previewElement =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.PREVIEW_CONTAINER}`);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.hidePosterAndPlay);
    this.root.addEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.hidePosterAndPlay);
    if (!(0,_focus__WEBPACK_IMPORTED_MODULE_4__.isElementFocusable)(root)) {
      this.root.tabIndex = 0;
    }
    if (this.root.tagName !== 'A') {
      this.root.setAttribute(_constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Attribute.ROLE, _constants_attribute__WEBPACK_IMPORTED_MODULE_1__.Role.BUTTON);
    }
    const video =
        (options === null || options === void 0 ? void 0 :
                                                  options.modalElement) ?
        options === null || options === void 0 ?
        void 0 :
        options.modalElement.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.VIDEO_CONTAINER}`) :
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.VIDEO_CONTAINER}`);
    if (!video) {
      throw new Error(_constants__WEBPACK_IMPORTED_MODULE_7__.ErrorMessages.MISSING_VIDEO);
    }
    this.videoElement = video;
    if ((_a = this.previewElement) === null || _a === void 0 ?
            void 0 :
            _a.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.INLINE_VIDEO)) {
      this.videoElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.HIDE_ELEMENT);
    }
    // Create a modal component if there is modal markup.
    this.modalCloseHandler = () => {
      var _a;
      (_a = this.getPlayer()) === null || _a === void 0 ? void 0 :
                                                          _a.pauseVideo();
    };
    this.options = this.setPlayerOptions(options);
    this.modalElement =
        (options === null || options === void 0 ? void 0 :
                                                  options.modalElement) ?
        options === null || options === void 0 ? void 0 : options.modalElement :
        this.root.querySelector(`.${_modal_constants__WEBPACK_IMPORTED_MODULE_5__.CssClasses.ROOT}`);
    if (this.modalElement) {
      this.modal = new _modal_index__WEBPACK_IMPORTED_MODULE_6__.Modal(this.modalElement, this.root);
      // Needs to listen for the modal closing so the video can be paused.
      this.modalElement.addEventListener(
          _modal_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.CLOSED_EVENT, this.modalCloseHandler);
    }
    // The manager of YT API and videos.
    this.manager = _videomanager__WEBPACK_IMPORTED_MODULE_8__.YoutubeVideoManager.getManager();
    YT.ready(() => {
      this.initializeVideo();
    });
    this.posterImageElement =
        this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.IMAGE_CONTAINER}`);
    const posterSrc = (_b = this.posterImageElement) === null || _b === void 0 ?
        void 0 :
        _b.getAttribute('src');
    if (this.posterImageElement &&
        (posterSrc === null || posterSrc === void 0 ? void 0 :
                                                      posterSrc.length) === 0) {
      this.posterImageElement.src = `https://i.ytimg.com/vi_webp/${
          this.options.videoId}/maxresdefault.webp`;
    }
  }
  destroy() {
    var _a, _b, _c, _d, _e;
    super.destroy();
    (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();
    (_b = this.modal) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.modalElement) === null || _c === void 0 ?
        void 0 :
        _c.removeEventListener(
            _modal_constants__WEBPACK_IMPORTED_MODULE_5__.Strings.CLOSED_EVENT, this.modalCloseHandler);
    (_d = this.root) === null || _d === void 0 ?
        void 0 :
        _d.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.CLICK, this.hidePosterAndPlay);
    (_e = this.root) === null || _e === void 0 ?
        void 0 :
        _e.removeEventListener(_events_eventtype__WEBPACK_IMPORTED_MODULE_2__.EventType.KEYDOWN, this.hidePosterAndPlay);
    this.destroyPlayer();
  }
  /**
   * Default YtVideo options
   */
  static get defaultOptions() {
    return {
      playerId: '',
      width: '',
      height: '',
      videoId: '',
      playerVars: {},
      events: {},
    };
  }
  /**
   * Sets or creates the unique identifier for the player element to be
   * used as the unique key.
   */
  initId() {
    var _a;
    // Get IDs in order of precedence.
    //   1. element id attribute
    //   2. playerId from options passed-in
    //   3. a random unique id
    let id = (_a = this.videoElement.id) !== null && _a !== void 0 ? _a : '';
    // Make ID unique and random if unprovided.
    if (this.isValidPlayerId(id)) {
      id = this.options.playerId ||
          `youtube-player-${Math.round(Math.random() * Math.pow(10, 6))}`;
      // There must be an element id.
      this.videoElement.id = id;
    }
    this.id = id;
  }
  /**
   * Re-initialize the video player with new options.
   * @param passedOptions The new options package.
   */
  refreshPlayerOptions(passedOptions) {
    this.destroyPlayer();
    this.options =
        Object.assign({}, YoutubeVideo.defaultOptions, passedOptions);
    if (this.options.playerId) this.id = this.options.playerId;
    this.initializeVideo();
  }
  /**
   * Sets the options and id of the video.
   * Uses data-attributes, if present, otherwise use passed-in option
   * If neither exist, use the default
   * @param passedOptions Options passed in by the user.
   */
  setPlayerOptions(passedOptions) {
    const attrOptions = {};
    const attrData = this.videoElement.dataset;
    if (_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.VIDEO_ID in attrData) {
      attrOptions.videoId = attrData[_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.VIDEO_ID];
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.PLAYER_ID in attrData) {
      attrOptions.playerId = attrData[_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.PLAYER_ID];
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.HEIGHT in attrData) {
      attrOptions.height = attrData[_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.HEIGHT];
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.WIDTH in attrData) {
      attrOptions.width = attrData[_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.WIDTH];
    }
    if (_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.PLAYER_VARS in attrData) {
      attrOptions.playerVars = attrData[_constants__WEBPACK_IMPORTED_MODULE_7__.DataAttrs.PLAYER_VARS];
    }
    const fullOptions = Object.assign(
        {}, YoutubeVideo.defaultOptions, passedOptions, attrOptions);
    if (fullOptions.playerId) {
      this.id = fullOptions.playerId;
    }
    return fullOptions;
  }
  /**
   * Initialize the video player.
   */
  initializeVideo() {
    // The video can't be stored without an ID.
    if (this.isValidPlayerId(this.id)) {
      this.initId();
    }
    // Make sure the playerId is set.
    this.options.playerId = this.id;
    // makeVideoContainerElem will make a new sub-element that the
    // YT Player will replace with an iframe. This step prevents
    // replacing the root element with the iframe.
    const el = this.videoElement.appendChild(document.createElement('div'));
    if (this.options.events) {
      if (this.options.events.onReady === undefined) {
        this.options.events.onReady = () => {
          this.setVideoTimestamp();
        };
      } else {
        const userFunction = this.options.events.onReady;
        this.options.events.onReady = (event) => {
          this.setVideoTimestamp();
          userFunction(event);
        };
      }
    }
    const player = new window.YT.Player(el, this.options);
    this.manager.registerYtPlayer(this.id, player);
  }
  /**
   * Gets the video duration and sets timestamp.
   */
  setVideoTimestamp() {
    var _a, _b, _c, _d;
    const timestamp = this.root.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.DURATION}`);
    if (timestamp) {
      const duration = (_b = (_a = this.getPlayer()) === null || _a === void 0 ?
                            void 0 :
                            _a.getDuration()) !== null &&
              _b !== void 0 ?
          _b :
          0;
      const mills = new Date(duration * 1000).toISOString();
      const time = mills.substring(11, 13) === '00' ? mills.substring(14, 19) :
                                                      mills.substring(11, 19);
      timestamp.textContent = time;
      (_d = (_c = this.root) === null || _c === void 0 ?
           void 0 :
           _c.querySelector(`.${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.TIMESTAMP}`)) === null ||
              _d === void 0 ?
          void 0 :
          _d.classList.add(`${_constants__WEBPACK_IMPORTED_MODULE_7__.CssClasses.TIMESTAMP_SHOW}`);
    }
  }
  /**
   * Gets video player object.
   */
  getPlayer() {
    return this.manager.getYtPlayer(this.id);
  }
  /**
   * Destroys the video player and iframe.
   */
  destroyPlayer() {
    this.manager.unregisterYtPlayer(this.id);
  }
  /**
   * Gets video player ID.
   */
  getPlayerId() {
    if (this.isValidPlayerId(this.id)) {
      this.initId();
    }
    return this.id;
  }
  /**
   * If the player ID is a valid one.
   * This is lifted from closure goog.string.isEmptyOrWhitespace function.
   */
  isValidPlayerId(id) {
    return /^[\s\xa0]*$/.test(id);
  }
}



/***/ }),

/***/ "./_glue/lib/ytvideo/videomanager.js":
/*!*******************************************!*\
  !*** ./_glue/lib/ytvideo/videomanager.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YoutubeVideoManager: () => (/* binding */ YoutubeVideoManager)
/* harmony export */ });
/**
 * Manages a collection of YouTube videos. Also manages the YouTibe Video API.
 */
class YoutubeVideoManager {
  constructor() {
    this.videoObjects = new Map();
  }
  static getManager() {
    if (!YoutubeVideoManager.instance) {
      YoutubeVideoManager.instance = new YoutubeVideoManager();
    }
    return YoutubeVideoManager.instance;
  }
  static destroyManager() {
    YoutubeVideoManager.instance = undefined;
  }
  /**
   * Stores the YouTube player object
   * @param id The id of a player.
   * @param player The player instance.
   */
  registerYtPlayer(id, player) {
    this.videoObjects.set(id, player);
  }
  /**
   * Destroy a player.
   * @param id The id of a player.
   */
  unregisterYtPlayer(id) {
    const player = this.videoObjects.get(id);
    player === null || player === void 0 ? void 0 : player.destroy();
    this.videoObjects.delete(id);
    // If we just destroyed the last video, then the manager
    // should destroy iteself since it now manages nothing.
    if (this.videoObjects.size === 0) {
      YoutubeVideoManager.destroyManager();
    }
  }
  /**
   * Get YouTube player object.
   * @param id The id of a player.
   */
  getYtPlayer(id) {
    return this.videoObjects.get(id);
  }
}
YoutubeVideoManager.instance = undefined;



/***/ }),

/***/ "./src/layout/header/components/callToActions.tsx":
/*!********************************************************!*\
  !*** ./src/layout/header/components/callToActions.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var typed_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-html */ "./node_modules/typed-html/dist/src/elements.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(isDesktop) {
    const classCalculated = "glue-header__container" + isDesktop ? "glue-header__container--cta" : 0;
    return (typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: classCalculated },
        typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__cta" },
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { class: "glue-button glue-button--medium-emphasis" }, "Secondary"),
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { class: "glue-button glue-button--high-emphasis" }, "Primary"))));
}


/***/ }),

/***/ "./src/layout/header/components/linkbar.tsx":
/*!**************************************************!*\
  !*** ./src/layout/header/components/linkbar.tsx ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var typed_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-html */ "./node_modules/typed-html/dist/src/elements.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    const links = [
        {
            label: "Homepage",
            href: "/",
        },
        {
            label: "About Us",
            href: "/about-us",
        },
    ];
    return (typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__container glue-header__container--linkbar" },
        typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("nav", { class: "glue-header__link-bar" },
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", { class: "glue-header__list" }, links.map((i) => (
            // glue-header__item--active
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("li", { class: "glue-header__item" },
                typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { class: "glue-header__link", href: i.href, onclick: "navigate(event)", "aria-current": "page" }, i.label))))))));
}


/***/ }),

/***/ "./src/layout/header/components/lockup.tsx":
/*!*************************************************!*\
  !*** ./src/layout/header/components/lockup.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var typed_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-html */ "./node_modules/typed-html/dist/src/elements.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(includeHamburger) {
    return (typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__container" },
        typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__lock-up" },
            includeHamburger ? (typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__hamburger" },
                typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("button", { class: "glue-header__drawer-toggle-btn", "aria-label": "Open the navigation drawer" },
                    typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { class: "glue-icon glue-icon--24px", role: "presentation", "aria-hidden": "true" },
                        typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("use", { href: "/assets/img/glue-icons.svg#menu" }))))) : '',
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__logo" },
                typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { class: "glue-header__logo-link", href: "#", title: "Google" },
                    typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__logo-container" },
                        typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", { class: "glue-header__logo-svg", role: "presentation", "aria-hidden": "true" },
                            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("use", { href: "/assets/img/glue-icons.svg#google-color-logo" }))),
                    typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("span", { class: "glue-header__logo--product" }, "Product"))))));
}


/***/ }),

/***/ "./src/layout/header/components/skipToContent.tsx":
/*!********************************************************!*\
  !*** ./src/layout/header/components/skipToContent.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var typed_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-html */ "./node_modules/typed-html/dist/src/elements.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    return (typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("a", { href: "#content", class: "glue-header__link glue-header__skip-content" }, "Jump to Content"));
}


/***/ }),

/***/ "./src/layout/header/index.tsx":
/*!*************************************!*\
  !*** ./src/layout/header/index.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var typed_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typed-html */ "./node_modules/typed-html/dist/src/elements.js");
/* harmony import */ var _components_skipToContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/skipToContent */ "./src/layout/header/components/skipToContent.tsx");
/* harmony import */ var _components_lockup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/lockup */ "./src/layout/header/components/lockup.tsx");
/* harmony import */ var _components_callToActions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/callToActions */ "./src/layout/header/components/callToActions.tsx");
/* harmony import */ var _components_linkbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/linkbar */ "./src/layout/header/components/linkbar.tsx");
/* harmony import */ var _google_glue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @google/glue */ "./_glue/index.js");

// Components




// UI Components

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    setTimeout(() => {
        const headerEl = document.querySelector(".glue-header");
        if (headerEl)
            new _google_glue__WEBPACK_IMPORTED_MODULE_5__.Header(headerEl);
    }, 200);
    return (typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("header", null,
        typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("header", { class: "glue-header glue-header--single" },
            (0,_components_skipToContent__WEBPACK_IMPORTED_MODULE_1__["default"])(),
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__bar glue-header__bar--mobile" },
                typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__tier" },
                    (0,_components_lockup__WEBPACK_IMPORTED_MODULE_2__["default"])(true),
                    (0,_components_callToActions__WEBPACK_IMPORTED_MODULE_3__["default"])(false))),
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__bar glue-header__bar--desktop glue-header__drawer" },
                typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__tier" },
                    (0,_components_lockup__WEBPACK_IMPORTED_MODULE_2__["default"])(false),
                    (0,_components_linkbar__WEBPACK_IMPORTED_MODULE_4__["default"])(),
                    (0,_components_callToActions__WEBPACK_IMPORTED_MODULE_3__["default"])(true))),
            typed_html__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { class: "glue-header__drawer-backdrop", role: "button", "aria-label": "Close menu" }))));
}


/***/ })

}]);
//# sourceMappingURL=src_layout_header_index_tsx.js.map