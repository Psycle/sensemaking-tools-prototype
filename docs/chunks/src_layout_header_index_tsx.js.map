{"version":3,"file":"chunks/src_layout_header_index_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACgD;AACZ;AACK;AACT;AACS;AACc;AACE;AACrB;AACA;AACO;AACT;AAC0B;AACX;AACc;AAC3B;AACM;AACV;AACM;AACK;;AAuBzC;;;;;;;;;;;;;;;;AC7CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACH;;;;;;;;;;;;;;;;;;;;;AC1BF;;AAEE;AAC+B;AACnB;AACZ;;AAEmB;;AAErD;AACA;AACA;AACA,2BAA2B,4CAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4CAAG;AAC7D,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,iBAAiB;AAC/D;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA;AACA,8CAA8C,kDAAU,QAAQ;AAChE;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA;AACA,4CAA4C,kDAAU,aAAa;AACnE;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA;AACA,4CAA4C,kDAAU,cAAc;AACpE;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA;AACA,4CAA4C,kDAAU,eAAe;AACrE;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAS,OAAO,sDAAI;AACjD,2BAA2B,0DAAQ;AACnC,yBAAyB,0DAAQ;AACjC;AACA,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC;AACA;AACA,6BAA6B,kDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAS;AACpB;AACA;AACA,kCAAkC,kDAAU;AAC5C;AACA,YAAY,2DAAS;AACrB,QAAQ;AACR,qCAAqC,kDAAU;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAU;AAC3C,6BAA6B,2DAAS;AACtC;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAS;AACzC,gCAAgC,2DAAS;AACzC,gCAAgC,2DAAS;AACzC,8BAA8B,2DAAS;AACvC,oCAAoC,wDAAS;AAC7C,oCAAoC,wDAAS;AAC7C;AACA;AACsB;;;;;;;;;;;;;;;;;ACxHtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACW;;;;;;;;;;;;;;;;;;ACnBJ;AACY;;AAEE;;AAEhD;AACA;AACA;AACA;AACA,qBAAqB,4CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,qBAAqB;AACnE;AACA;AACA,4BAA4B,wDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC;AACA;AACA,KAAK,EAAE,+CAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACgB;;;;;;;;;;;;;;;AC1ChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACmB;;;;;;;;;;;;;;;;ACzBnB;AACA;AACA;AACiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2DAAS;AACpD,uCAAuC,2DAAS;AAChD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACsB;;;;;;;;;;;;;;;;;;;;;;AC3EzB;AAC+B;AACnB;AACZ;AACK;AACF;;AAEoB;;AAEzD;AACA,uBAAuB,4CAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+CAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAU,aAAa;AACtD;AACA,UAAU;AACV,+BAA+B,kDAAU,aAAa;AACtD;AACA,UAAU;AACV;AACA,6CAA6C,+CAAO;AACpD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAAG;AACvC,qCAAqC,4CAAG;AACxC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,YAAY,wDAAS;AACrB;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,YAAY,wDAAS;AACrB;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,gDAAgD,kDAAU;AAC1D,gDAAgD,kDAAU,UAAU;AACpE,uDAAuD,kDAAU,MAAM;AACvE;AACA,kDAAkD,kDAAU,MAAM;AAClE;AACA,kDAAkD,kDAAU,YAAY;AACxE,+CAA+C,kDAAU,aAAa;AACtE,+CAA+C,kDAAU,aAAa;AACtE;AACA,sCAAsC;AACtC;AACA,wBAAwB,+CAAQ,EAAE,wCAAwC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAS;AAC/C,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC;AACA,QAAQ,wDAAS;AACjB,4BAA4B,wDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAS;AACrC,4BAA4B,2DAAS;AACrC,4BAA4B,2DAAS;AACrC;AACA;AACA,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA,QAAQ,wDAAS;AACjB;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+CAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,QAAQ;AACR,2BAA2B,2DAAS;AACpC;AACA,2CAA2C,2DAAS,OAAO,sDAAI;AAC/D,8CAA8C,2DAAS;AACvD;AACA,qCAAqC,0DAAQ,YAAY,0DAAQ;AACjE;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAA8B;AAC9D;AACA;AACA,2CAA2C,2DAAS;AACpD,UAAU;AACV,sCAAsC,0DAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAU;AACnD;AACA,MAAM;AACN;AACA,4CAA4C,kDAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAU;AAC3C;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC;AACA,qCAAqC,2DAAS,OAAO,sDAAI;AACzD,wCAAwC,2DAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAU;AACrC,iCAAiC,0DAAQ,YAAY,0DAAQ;AAC7D;AACA,yBAAyB,2DAAS,mBAAmB,UAAU;AAC/D,QAAQ;AACR,yBAAyB,2DAAS,kBAAkB,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAU;AAC5C,kCAAkC,kDAAU;AAC5C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA,wBAAwB,kDAAU;AAClC,kBAAkB,+CAAO,gBAAgB,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS,OAAO,sDAAI;AAC7C,QAAQ;AACR;AACA,oCAAoC,+CAAO;AAC3C,YAAY,+CAAO;AACnB;AACA;AACA,yBAAyB,+CAAO,sCAAsC,MAAM;AAC5E;AACA,oBAAoB,+CAAO;AAC3B,uBAAuB,gBAAgB;AACvC,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B,uBAAuB,2DAAS;AAChC,qBAAqB,0DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB,MAAM;AACN;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA;AACA,UAAU,wDAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB,MAAM;AACN;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA;AACA,UAAU,wDAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+CAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC,EAAE,gBAAgB;AAC5E;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;;;;;;;ACpwBlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC4B;;;;;;;;;;;;;;;ACtDzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACb;;;;;;;;;;;;;;;;;;ACRpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACkB;;;;;;;;;;;;;;;;;;;;;ACrDb;;AAEE;AACY;AACZ;AACgC;;AAET;;AAEzD;AACA;AACA;AACA,mBAAmB,4CAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA,mBAAmB,+CAAO;AAC1B;AACA;AACA,kDAAkD,kDAAU,OAAO;AACnE,qDAAqD,kDAAU,QAAQ;AACvE;AACA,oCAAoC,kDAAU,cAAc;AAC5D;AACA;AACA,8BAA8B,kDAAU,qBAAqB;AAC7D;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAAO;AAClD,wCAAwC,+CAAO;AAC/C;AACA;AACA;AACA;AACA,uCAAuC,wDAAS;AAChD,uCAAuC,wDAAS;AAChD;AACA;AACA;AACA,4BAA4B,2DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAS;AACnD;AACA,QAAQ,wDAAS;AACjB;AACA;AACA,+BAA+B,2DAAa;AAC5C;AACA;AACA;AACA,WAAW,gDAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kDAAU;AAC1D;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACc;;;;;;;;;;;;;;;AClId;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;;;AC/DrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACZ;;;;;;;;;;;;;;;;ACtDnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACL;;;;;;;;;;;;;;;;;;;AClCtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAC2B;;;;;;;;;;;;;;;;;;;;;ACzD7B;AAC+B;AACnB;AACP;AAC6C;AACpC;AACnD;AACA;AACA;AACA,qCAAqC,4CAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAU,OAAO;AAC1D,yCAAyC,kDAAU,OAAO;AAC1D;AACA;AACA;AACA,kCAAkC,kDAAU,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,OAAO;AACrD;AACA;AACA,mBAAmB,gDAAQ;AAC3B,iBAAiB,6DAAY;AAC7B;AACA,sBAAsB,qDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAQ;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAU;AAChC,sBAAsB,kDAAU;AAChC,sBAAsB,kDAAU;AAChC;AACA;AACA,UAAU,wDAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU,eAAe,kDAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAU;AAClC,wBAAwB,kDAAU;AAClC,wBAAwB,kDAAU;AAClC;AACA;AACA,UAAU,wDAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU,gBAAgB,kDAAU;AAChE,+BAA+B,kDAAU,eAAe,kDAAU;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAQ;AAChC;AACA;AACA,QAAQ,+CAAO;AACf;AACA;AACA,wBAAwB,gDAAQ;AAChC;AACA;AACA,QAAQ,+CAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAS;AACnB;AACA;AACA,6BAA6B,2DAAS;AACtC,MAAM;AACN,gCAAgC,2DAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAA8B;AACvD;AACA;AACA,sBAAsB,0DAAQ;AAC9B;AACA,MAAM;AACN,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC;AACA;AACgC;;;;;;;;;;;;;;;;;;;;;;AC7SE;;AAEoC;AACrB;AACJ;AACK;AACH;AACM;;AAErD;AACA;AACA;AACA,8BAA8B,4CAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE,wDAAoB;AACzD;AACA;AACA;AACA;AACA,0BAA0B,gDAAQ,SAAS,+CAAO;AAClD,iBAAiB,6DAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAU;AACnD;AACA;AACA;AACA;AACA,iBAAiB,kDAAU,YAAY;AACvC,wCAAwC,gEAAwB;AAChE;AACA;AACA,iBAAiB,kDAAU,SAAS;AACpC;AACA,cAAc,4DAAsB;AACpC;AACA;AACA,iBAAiB,kDAAU,QAAQ;AACnC,0CAA0C,0DAAqB;AAC/D;AACA;AACA;AACA,QAAQ,kDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAU;AAClB;AACA,IAAI,6DAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAU,eAAe,kDAAU,WAAW,kDAAU;AAChE;AACA,yCAAyC,wBAAwB;AACjE;AACA;AACA;AACyB;;;;;;;;;;;;;;;;;AC9F4B;AACJ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAO;AAC/B;AACA;AACA;AACA;AACA,2BAA2B,4DAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,0BAA0B,+CAAO;AACjC,MAAM;AACN,0BAA0B,+CAAO;AACjC,MAAM;AACN,0BAA0B,+CAAO;AACjC;AACA;AACA,uBAAuB,kDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;;;;;ACtF9B;AACA;AACA;AACqC;;AAEQ;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+CAAO;AAClB,gBAAgB,wDAAoB;AACpC;AACA;AACA,qBAAqB,wDAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;;;;;;;;;AC3Ce;AAC+B;AACnB;AACZ;AACwC;AAC1B;AACnD;AACA;AACA;AACA,oCAAoC,4CAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,OAAO;AACrD;AACA;AACA,mBAAmB,gDAAQ;AAC3B,iBAAiB,6DAAY;AAC7B,wCAAwC,gDAAQ;AAChD;AACA;AACA,sBAAsB,qDAAa;AACnC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAU,OAAO;AAC3D;AACA;AACA;AACA;AACA,sBAAsB,qDAAa;AACnC;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAU;AACvC;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAG,wBAAwB,4CAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C,yBAAyB,0DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC;AACA;AAC+B;;;;;;;;;;;;;;;;;;;;;AChGM;AACe;AACH;AACZ;AACkC;AACpB;AACnD;AACA;AACA;AACA,uCAAuC,4CAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAY;AAC7B,oCAAoC,kDAAU,OAAO;AACrD;AACA;AACA,uBAAuB,gDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC;AACA;AACA,QAAQ,kDAAU;AAClB;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA,QAAQ,kDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAO;AAC3C;AACA,+BAA+B,kDAAU;AACzC,MAAM;AACN;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAG,wBAAwB,4CAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAS;AACjB,oCAAoC,+CAAO;AAC3C;AACA,uCAAuC,kDAAU,iBAAiB;AAClE;AACA,wBAAwB,2DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC;AACA,uCAAuC,kDAAU,iBAAiB;AAClE;AACA,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAO;AAC3C,6BAA6B,2DAAS;AACtC,MAAM;AACN,6BAA6B,2DAAS;AACtC;AACA;AACA;AACkC;;;;;;;;;;;;;;;;;;;;;;;;ACjIlC;AAC2D;AACT;AACgB;AACI;;AAEjC;AACY;AACT;AAC2B;AACf;;AAEpD;AACA;AACA;AACA,6BAA6B,4CAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAU,eAAe;AACtE;AACA;AACA;AACA,gBAAgB,kDAAU,eAAe,QAAQ,uDAAe,WAAW;AAC3E;AACA;AACA,oCAAoC,uDAAe,QAAQ;AAC3D;AACA,oCAAoC,uDAAe,cAAc;AACjE,sCAAsC,+CAAO;AAC7C;AACA;AACA,YAAY,+CAAO,mBAAmB,GAAG,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA,YAAY,+CAAQ,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA,YAAY,+CAAO;AACnB;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAU,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR,wBAAwB,+CAAO;AAC/B;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uDAAe,WAAW;AAC3E;AACA;AACA;AACA,sCAAsC,+CAAO;AAC7C;AACA,+BAA+B,uDAAe,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,wBAAwB,+CAAO;AAC/B;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAe,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,4BAA4B,+CAAO;AACnC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY;AACZ,4BAA4B,+CAAO;AACnC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY;AACZ,4BAA4B,+CAAO;AACnC;AACA,UAAU;AACV,0BAA0B,+CAAO;AACjC;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAgB,kBAAkB,8EAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8DAAO;AAC/D,sBAAsB,uEAAU;AAChC;AACA,wBAAwB,8DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAO,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;;;;;;;;;;;;;;;;;;;;;AC1ba;AAC+B;AACnB;AACZ;AACY;AACG;AACpD;AACA;AACA;AACA,0BAA0B,4CAAS;AACnC;AACA;AACA;AACA;AACA,4BAA4B,8DAAkB;AAC9C,kDAAkD,+CAAO;AACzD;AACA;AACA;AACA;AACA,uBAAuB,4CAAG,sBAAsB,4CAAG;AACnD,uBAAuB,4CAAG,sBAAsB,4CAAG;AACnD,oCAAoC,4CAAG;AACvC,qCAAqC,4CAAG;AACxC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU,sBAAsB,4CAAG;AACnC;AACA;AACA,UAAU,sBAAsB,4CAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAU;AAC7C;AACA,0CAA0C,kDAAU,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG,uBAAuB,4CAAG;AACrD;AACA,mCAAmC,kDAAU;AAC7C;AACA,0CAA0C,kDAAU,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAU;AACvD,uCAAuC,+CAAO;AAC9C,qBAAqB,+CAAO;AAC5B,QAAQ,+CAAO;AACf,0CAA0C,+CAAO;AACjD,qBAAqB,+CAAO;AAC5B,QAAQ,+CAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAQ,YAAY,0DAAQ;AACrD;AACA,uBAAuB,2DAAS,OAAO,sDAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAS;AAC/C;AACA,cAAc,wDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAS,OAAO,sDAAI;AACrD;AACA,yBAAyB,kDAAU;AACnC,sBAAsB,0DAAQ;AAC9B,wBAAwB,2DAAS,OAAO,sDAAI;AAC5C,mBAAmB,+CAAO;AAC1B,mBAAmB,+CAAO;AAC1B;AACA;AACA;AACA,QAAQ,2DAAS;AACjB,WAAW,qBAAqB,EAAE,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC,aAAa;AACnE;AACA,2CAA2C;AAC3C;AACA,gCAAgC,kDAAU;AAC1C;AACA,0BAA0B,uBAAuB,OAAO,oBAAoB;AAC5E;AACA,YAAY,2DAAS,gBAAgB,WAAW,EAAE,mBAAmB;AACrE;AACA,MAAM;AACN;AACA;AACA;AACA,oDAAoD,sDAAI,KAAK;AAC7D;AACA;AACA,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAS;AAC5C,mCAAmC,wDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAS;AAC/C;AACA,cAAc,wDAAS;AACvB;AACA,mCAAmC,kDAAU;AAC7C;AACA,cAAc,2DAAS;AACvB,iBAAiB,wBAAwB,EAAE,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA,gDAAgD,sDAAI,KAAK;AACzD,mCAAmC,0DAAQ,YAAY,0DAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS,OAAO,sDAAI;AACnD,+BAA+B,2DAAS;AACxC,gCAAgC,kDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+CAAO;AACjD,8CAA8C,+CAAO;AACrD,+CAA+C,kDAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAO,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAQ;AACjC,kCAAkC,wDAAS;AAC3C;AACA,6BAA6B,wDAAS;AACtC,6BAA6B,wDAAS;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;;;;;ACzTrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACmB;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFZ;AACY;AACK;AACpB;AACwB;;AAEb;AACP;AACa;AACV;AACa;;AAEnD;AACA,qBAAqB,4CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU,WAAW;AAC7D;AACA;AACA,+CAA+C,kDAAU,OAAO;AAChE,qDAAqD,kDAAU,cAAc;AAC7E,oDAAoD,kDAAU,cAAc;AAC5E;AACA,oCAAoC,kDAAU,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,kDAAkD,kDAAU,SAAS;AACrE;AACA;AACA;AACA,uBAAuB,iDAAY;AACnC;AACA;AACA;AACA;AACA,gDAAgD,kDAAU,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA,uBAAuB,8CAAW;AAClC;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU,WAAW;AAC7D;AACA;AACA;AACA,4BAA4B,wDAAS;AACrC;AACA;AACA,UAAU,+CAAO;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAiB;AAClD;AACA;AACA;AACA;AACA,2BAA2B,yCAAK;AAChC;AACA;AACA,kCAAkC,wDAAS;AAC3C;AACA;AACA,kCAAkC,wDAAS;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAS;AAC9C;AACA;AACA,qCAAqC,wDAAS;AAC9C,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,8DAAkB;AACtB;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA,UAAU,+CAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAU;AACnC,QAAQ;AACR,4BAA4B,kDAAU;AACtC;AACA;AACA;AACA;AACoC;;;;;;;;;;;;;;;;;;;;ACtOC;AACe;AACH;AACG;AACjB;AACnC;AACA;AACA;AACA,2BAA2B,4CAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+CAAO;AACxD;AACA,+CAA+C,+CAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,kDAAU,QAAQ;AAC1D;AACA;AACA;AACA,qBAAqB,+CAAO;AAC5B,8BAA8B,+CAAO;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,+CAAO;AACjD;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAkB;AACtC;AACA;AACA;AACA;AACA,sCAAsC;AACtC,WAAW,iDAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAU;AACpC,0CAA0C,2DAAS;AACnD,uCAAuC,2DAAS;AAChD;AACA;AACA,wCAAwC,kDAAU,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kDAAU,MAAM;AAC/D,8BAA8B,kDAAU,MAAM;AAC9C;AACA;AACA,0CAA0C,kDAAU,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;;;ACpItB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;;;ACxC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;AC7GF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+E;;;;;;;;;;;;;;;;ACpG/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACC;;;;;;;;;;;;;;;;;;;;ACjCI;AACiB;AAC+B;AAC1B;;AAEP;;AAEjD;AACA;AACA;AACA,qBAAqB,4CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,qBAAqB;AACnE;AACA;AACA,qCAAqC,kEAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAe;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAsB;AAC7D;AACA,gCAAgC,gDAAQ,QAAQ,gDAAQ;AACxD,MAAM;AACN,uCAAuC,gDAAQ;AAC/C;AACA;AACA;AACA,iBAAiB,kDAAU,qBAAqB;AAChD;AACA,oCAAoC,kDAAU,sBAAsB;AACpE;AACA,oCAAoC,kDAAU,sBAAsB;AACpE;AACA,oCAAoC,kDAAU,uBAAuB;AACrE;AACA;AACA,mCAAmC,kEAAsB;AACzD;AACA;AACA;AACA,cAAc,kEAAsB;AACpC;AACA;AACA;AACA,cAAc,kEAAsB;AACpC;AACA;AACA;AACA,cAAc,kEAAsB;AACpC;AACA;AACA,8BAA8B,gDAAQ;AACtC,QAAQ;AACR;AACA;AACA,0CAA0C,gDAAQ;AAClD;AACA;AACA;AACA;AACgB;;;;;;;;;;;;;;;;;;AC3HhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACsB;;;;;;;;;;;;;;;ACvF7C;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACV;;;;;;;;;;;;;;;;;;;;ACLoB;AACqB;AAClB;;AAEJ;AACM;;AAE1C;AACA;AACA;AACA;AACA,sBAAsB,4CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAO,gBAAgB,+CAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kDAAU,WAAW;AACrE,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C;AACA,4BAA4B,2DAAS,OAAO,sDAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;;;;;;;;;;;;;;;;;;;;AC/JoB;AACqB;AACT;AACZ;AACE;AACvC;AACA;AACA;AACA,0BAA0B,4CAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS;AACxC,QAAQ;AACR,+BAA+B,2DAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C;AACA;AACA,2BAA2B,iDAAS;AACpC,6BAA6B,2DAAS;AACtC,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACqB;;;;;;;;;;;;;;;;AC1KrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACE;;;;;;;;;;;;;;;;;;;;;;ACvBS;AACwB;AACb;AACZ;AACY;AACA;;AAED;;AAEhD,qBAAqB,6CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,YAAY,wDAAS;AACrB;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,YAAY,wDAAS;AACrB;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAU;AAChD,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA,6BAA6B,kDAAU,UAAU;AACjD;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAG;AAC5B;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAG;AAC5B;AACA;AACA;AACA;AACA,kCAAkC,kDAAU;AAC5C,6CAA6C,kDAAU;AACvD,qCAAqC,wDAAS;AAC9C;AACA;AACA,qCAAqC,kDAAU;AAC/C,gDAAgD,kDAAU;AAC1D,wCAAwC,wDAAS;AACjD;AACA;AACA;AACA,QAAQ,wDAAS;AACjB;AACA,mCAAmC,+CAAO;AAC1C,mCAAmC,+CAAO;AAC1C;AACA;AACA;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB,MAAM;AACN;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA;AACA,UAAU,wDAAS;AACnB;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB,MAAM;AACN;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAS;AACjB,sCAAsC,+CAAO;AAC7C,sCAAsC,+CAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAU;AAClB;AACA;AACA;AACA,MAAM;AACN,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAU;AAChC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAO,SAAS;AAChC,8BAA8B,kDAAU;AACxC,8BAA8B,kDAAU;AACxC;AACA;AACA,iCAAiC,2DAAS;AAC1C,iCAAiC,2DAAS;AAC1C,+BAA+B,0DAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAO,UAAU;AACjC,8BAA8B,kDAAU;AACxC;AACA;AACA,iCAAiC,2DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAS;AAC/C,sCAAsC,2DAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA,+BAA+B,2DAAS;AACxC,+BAA+B,2DAAS;AACxC,+BAA+B,2DAAS;AACxC;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAU;AAC3C;AACA;AACA,QAAQ;AACR,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC,yBAAyB,0DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC;AACA;AACA;AACA;AACA;AACA,gJAAgJ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS;AACxC;AACA,6BAA6B,2DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAS;AAClC,KAAK;AACL;AACA;AACA;AACgB;;;;;;;;;;;;;;;;;;;;;;;;;;;AChamB;AACc;AACH;AACZ;AACsB;;AAEC;AACtB;AACF;AAC2B;AACf;AACiC;AACrC;;AAEzC;AACA;AACA;AACA,qBAAqB,6CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kDAAU;AAC9D,qCAAqC,kDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAU;AAC1C,QAAQ;AACR,kDAAkD,kDAAU;AAC5D,uCAAuC,kDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAU;AAChD,sBAAsB,+CAAO;AAC7B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kDAAU,WAAW;AACxE;AACA;AACA,+BAA+B,kDAAU,UAAU;AACnD;AACA;AACA,wBAAwB,+CAAO;AAC/B,QAAQ;AACR,wBAAwB,+CAAO;AAC/B;AACA,qDAAqD,kDAAU,YAAY;AAC3E;AACA;AACA,wBAAwB,+CAAO;AAC/B;AACA,wBAAwB,4CAAM;AAC9B,MAAM;AACN,8BAA8B,kDAAU;AACxC;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC;AACA;AACA,mCAAmC,sDAAa;AAChD;AACA,mCAAmC,sDAAa;AAChD,4BAA4B,wDAAS;AACrC;AACA,QAAQ,wDAAS;AACjB;AACA,QAAQ,wDAAS;AACjB,qCAAqC,kDAAU;AAC/C;AACA,mCAAmC,kDAAU;AAC7C,6CAA6C,kDAAU,cAAc;AACrE;AACA;AACA;AACA;AACA,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAsB,WAAW;AACrE;AACA,8BAA8B,wDAAY;AAC1C;AACA,gDAAgD,kDAAU,UAAU;AACpE;AACA,yBAAyB,8CAAO;AAChC;AACA;AACA;AACA,6BAA6B,qDAAU;AACvC;AACA,gCAAgC,kDAAU;AAC1C;AACA;AACA;AACA,gCAAgC,qDAAU;AAC1C,UAAU;AACV,qCAAqC,kDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA,QAAQ,wDAAS;AACjB;AACA,QAAQ,wDAAS;AACjB,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,sDAAa;AACjD,oCAAoC,sDAAa;AACjD;AACA;AACA;AACA;AACA;AACA,qCAAqC,kDAAU;AAC/C,oCAAoC,wDAAS;AAC7C;AACA,UAAU,wDAAS;AACnB,oCAAoC,wDAAS;AAC7C,oCAAoC,wDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC,EAAE,gBAAgB;AAC1E;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kDAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAO;AACf,wCAAwC,+CAAO;AAC/C,sCAAsC,+CAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+CAAO;AACrD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAU;AACxC,MAAM;AACN;AACA,qCAAqC,kDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,+BAA+B,sBAAsB;AACrD,MAAM;AACN;AACA;AACA,OAAO,EAAE,+CAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAU,cAAc,kDAAU;AACrD;AACA,kDAAkD,kDAAU,KAAK;AACjE;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kDAAkD,+CAAO;AACzD,kDAAkD,+CAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAU,kBAAkB,kDAAU;AAC9C;AACA,cAAc,+CAAO,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA,2CAA2C,kDAAU;AACrD,cAAc,+CAAO,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAU;AACvD,MAAM;AACN;AACA;AACA;AACA,4CAA4C,kDAAU;AACtD;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACgB;;;;;;;;;;;;;;;;ACvkBhB;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACE;;;;;;;;;;;;;;;;;;;;;;ACTQ;AACqB;AACT;AACA;AACW;;AAEZ;AACZ;;AAEpC;AACA;AACA;AACA;AACA,wBAAwB,4CAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAU;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAU;AACxC,wCAAwC,2DAAS;AACjD;AACA;AACA;AACA,yBAAyB,+CAAO,aAAa;AAC7C;AACA;AACA,uCAAuC,kDAAgB,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC;AACA,wBAAwB,2DAAS,OAAO,sDAAI;AAC5C;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC;AACA,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAU;AAC3C;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;;;;;;;ACnQkB;AACqB;AACT;AACZ;AACrC;AACA;AACA;AACA;AACA,uBAAuB,4CAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAS;AACzC,6BAA6B,2DAAS,OAAO,sDAAI;AACjD;AACA,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAS;AACtC,MAAM;AACN,6BAA6B,2DAAS;AACtC;AACA;AACA;AACkB;;;;;;;;;;;;;;;;AClKlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACE;;;;;;;;;;;;;;;;;;;;;;;AChBS;AACoB;AACT;AACZ;AACuB;AACiC;AACtD;;AAEH;;AAEpC;AACA;AACA;AACA;AACA,2BAA2B,6CAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA,aAAa,4CAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAS;AAC1C;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,gCAAgC,2DAAS;AACzC,sBAAsB,+CAAO;AAC7B;AACA,uCAAuC,kDAAgB,aAAa;AACpE;AACA,sDAAsD,2DAAS;AAC/D;AACA,sBAAsB,+CAAO;AAC7B;AACA,yBAAyB,iDAAS;AAClC;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C;AACA,yCAAyC,yDAAe,MAAM;AAC9D;AACA;AACA,gCAAgC,sDAAa;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,sDAAa;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA,2BAA2B,2DAAS;AACpC;AACA;AACsB;;;;;;;;;;;;;;;;;ACvJtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACc;;;;;;;;;;;;;;;;;;;;;;;ACvCH;AAC2D;AAChD;AACZ;AACG;AACoB;;AAEA;AAC9B;;AAE9B,yBAAyB,6CAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAU,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAQ,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAa,OAAO,sDAAI;AACnD,gCAAgC,0DAAQ;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,yBAAyB,+CAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,gBAAgB;AAC9D,8CAA8C,+CAAO;AACrD,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,oBAAoB;AAClE,uDAAuD,kDAAU,UAAU;AAC3E;AACA,oCAAoC,kDAAU,gBAAgB;AAC9D;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA,+CAA+C,kDAAU,aAAa;AACtE;AACA,uCAAuC,kDAAU;AACjD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAgB,UAAU;AACvD,kCAAkC,+CAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAK;AAC9B;AACA,YAAY,yCAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAU;AACxC;AACA;AACA;AACA;AACA,+BAA+B,kDAAgB;AAC/C,uCAAuC,kDAAU;AACjD,iCAAiC,kDAAU;AAC3C;AACA;AACA;AACA,2BAA2B,kDAAU;AACrC;AACA,0BAA0B,kDAAU;AACpC;AACA;AACA,mCAAmC,0DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAgB;AACtD,kCAAkC,kDAAU;AAC5C,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA,iDAAiD,kDAAU;AAC3D,UAAU,+CAAO;AACjB;AACA,UAAU,+CAAO;AACjB,gCAAgC,2DAAS;AACzC,gCAAgC,2DAAS,OAAO,sDAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAgB;AAC3D;AACA;AACA;AACA;AACA,oCAAoC,0DAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAG;AACd,WAAW,4CAAG;AACd;AACA;AACA,WAAW,4CAAG;AACd;AACA;AACA,WAAW,4CAAG;AACd;AACA;AACA,WAAW,4CAAG;AACd;AACA;AACA;AACA;AACA,WAAW,4CAAG;AACd;AACA;AACA;AACA;AACA,WAAW,4CAAG;AACd;AACA;AACA,WAAW,4CAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAU,cAAc;AAC9D;AACA;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAO;AAClC,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wDAAS;AACtD;AACA,QAAQ,wDAAS;AACjB;AACA;AACoB;;;;;;;;;;;;;;;;;;;;AC5TkB;AACgC;AACD;AACT;;AAEA;;AAE5D;AACA;AACA;AACA,oBAAoB,6CAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAO,cAAc,GAAG,qCAAqC;AAC1E;AACA,8BAA8B,+CAAO,cAAc,GAAG,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kDAAU;AAC1D,8BAA8B,kDAAU;AACxC,8BAA8B,kDAAU;AACxC;AACA;AACA;AACA;AACA,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAc;AAC7C,iCAAiC,2DAAc;AAC/C,QAAQ;AACR;AACA,YAAY,0DAAc,OAAO,kDAAU;AAC3C,8BAA8B,2DAAc;AAC5C;AACA;AACA;AACA;AACA,uCAAuC,kDAAU;AACjD;AACA,mCAAmC,kDAAU;AAC7C;AACA,MAAM;AACN;AACA,2CAA2C,kDAAgB,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAU;AACvC;AACA;AACA,wBAAwB,2DAAc;AACtC;AACA;AACA,UAAU,2DAAc;AACxB,yCAAyC,kDAAgB;AACzD;AACA;AACA,2CAA2C,kDAAU;AACrD;AACA,YAAY,2DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAU;AACpD;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAc,OAAO,kDAAU;AACzC;AACA;AACA,2BAA2B,+CAAO;AAClC;AACA;AACe;;;;;;;;;;;;;;;;;;ACrIf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA,CAAC,4BAA4B;AACmB;;;;;;;;;;;;;;;;;;;;;;;;AC3CR;AACmB;AACjB;AACI;AACP;AACF;AACqB;AACE;;AAEO;;AAEnE,wBAAwB,kDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kDAAU,MAAM;AAC9D;AACA;AACA,MAAM;AACN;AACA;AACA,0CAA0C,kDAAU,aAAa;AACjE;AACA;AACA,MAAM;AACN;AACA;AACA,0CAA0C,kDAAU,cAAc;AAClE;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kDAAkD,kDAAU,OAAO;AACnE;AACA;AACA;AACA,2DAA2D,kDAAU,MAAM;AAC3E;AACA;AACA;AACA;AACA,UAAU;AACV,kBAAkB,+CAAO;AACzB;AACA,SAAS;AACT;AACA,4BAA4B,sEAAa;AACzC,wBAAwB,+CAAQ;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kDAAU,MAAM;AACrE,2CAA2C,gDAAQ;AACnD,QAAQ,+CAAO;AACf,2BAA2B,2DAAS;AACpC;AACA,wBAAwB,2DAAS,gBAAgB,WAAW,IAAI,UAAU;AAC1E;AACA;AACA,wBAAwB,0DAAQ;AAChC,0BAA0B,2DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA,QAAQ,wDAAS;AACjB,4BAA4B,wDAAS;AACrC,yBAAyB,+CAAO;AAChC,8BAA8B,oEAAe;AAC7C;AACA;AACA,KAAK;AACL;AACA,4BAA4B,wDAAS;AACrC;AACA;AACA;AACA,kCAAkC,wDAAS;AAC3C;AACA,QAAQ,wDAAS;AACjB,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,2BAA2B,+CAAO;AAClC;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,mDAAmD,+CAAO;AAC1D,UAAU,+CAAO;AACjB;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA,kBAAkB,oDAAc;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,0BAA0B,uDAA4B;AACtD;AACA;AACA;AACA,iCAAiC,0DAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,KAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kDAAU;AAC/C,qCAAqC,kDAAU;AAC/C;AACA;AACA,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA,sCAAsC,kDAAU;AAChD;AACA,MAAM;AACN;AACA,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,GAAG;AAC7E;AACA,oCAAoC,kDAAU,aAAa;AAC3D;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA;AACA,uCAAuC,2DAAS;AAChD;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA;AACA,uCAAuC,2DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAO;AACf;AACA,iCAAiC,kDAAU;AAC3C;AACA;AACA;AACA;AACA,+CAA+C,+CAAO;AACtD;AACA;AACA,iCAAiC,kDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAO;AACrB,UAAU;AACV;AACA;AACA,QAAQ;AACR,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAO;AACnD;AACA;AACmB;;;;;;;;;;;;;;;AClYnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;;;;ACnBpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACE;;;;;;;;;;;;;;;;;;;;;ACfK;AACqB;AACT;AACZ;AACW;;AAEG;;AAEhD,oBAAoB,4CAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAU;AAC3C;AACA;AACA,UAAU,wDAAS;AACnB;AACA,gDAAgD,kDAAU,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4CAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAS,OAAO,sDAAI;AAC/C,2BAA2B,2DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2DAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC,cAAc,+CAAO,iBAAiB;AACtC;AACA;AACA,4BAA4B,wDAAS;AACrC;AACA,gCAAgC,kDAAU;AAC1C;AACA,8BAA8B,wDAAS;AACvC;AACA,8BAA8B,wDAAS;AACvC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC,4BAA4B,kDAAU;AACtC,cAAc,+CAAO,iBAAiB;AACtC;AACA,mCAAmC,kDAAU;AAC7C,iCAAiC,wDAAS;AAC1C;AACA;AACA,+BAA+B,wDAAS;AACxC,iCAAiC,wDAAS;AAC1C;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gJAAgJ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS;AACvC,8BAA8B,2DAAS;AACvC;AACA;AACe;;;;;;;;;;;;;;;AC1Mf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACkB;;;;;;;;;;;;;;;;;;;;AClHlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AAQE;;;;;;;;;;;;;;;;;;;;;;;ACrDiC;AACkB;AACY;AAC5B;AACS;AACZ;;AAEsE;;AAExG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAQ,oBAAoB,8DAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,kDAAkD,kDAAU,SAAS;AACrE;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA,MAAM;AACN,kDAAkD,kDAAU,QAAQ;AACpE;AACA,wBAAwB,+CAAO;AAC/B;AACA;AACA,mDAAmD,kDAAU,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAS;AAC5C,mCAAmC,wDAAS;AAC5C;AACA,mCAAmC,wDAAS;AAC5C,mCAAmC,wDAAS;AAC5C;AACA,4BAA4B,wDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAS;AAC/C;AACA,QAAQ,wDAAS;AACjB,sCAAsC,wDAAS;AAC/C,sCAAsC,wDAAS;AAC/C,sCAAsC,wDAAS;AAC/C;AACA;AACA,UAAU,wDAAS;AACnB;AACA,UAAU,wDAAS;AACnB;AACA;AACA,iCAAiC,wDAAS;AAC1C;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,EAAE,kDAAU;AAC/B,WAAW,kBAAkB,EAAE,+CAAO;AACtC;AACA,gDAAgD,OAAO,GAAG,UAAU;AACpE,4CAA4C,OAAO,GAAG,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS,OAAO,sDAAI;AACnD,6BAA6B,0DAAQ;AACrC,+BAA+B,2DAAS;AACxC,+BAA+B,2DAAS,OAAO,sDAAI;AACnD,6BAA6B,0DAAQ;AACrC,+BAA+B,2DAAS;AACxC;AACA,yCAAyC,qCAAqC;AAC9E;AACA;AACA;AACA;AACA,iCAAiC,2DAAS;AAC1C;AACA;AACA,QAAQ,2DAAS;AACjB;AACA,gCAAgC,2DAAS,OAAO,sDAAI;AACpD,8BAA8B,0DAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS;AACxC,+BAA+B,2DAAS;AACxC,4BAA4B,kDAAU;AACtC,8BAA8B,wDAAS;AACvC;AACA,cAAc,mDAAW,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS;AACxC,+BAA+B,2DAAS;AACxC,+BAA+B,kDAAU;AACzC,oDAAoD,kDAAU;AAC9D;AACA,cAAc,mDAAW,gBAAgB;AACzC;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,qCAAqC,4CAAG,wBAAwB,4CAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAG;AACzB;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,wCAAwC,4CAAG;AAC3C;AACA;AACA,MAAM;AACN;AACA,uBAAuB,4CAAG,wBAAwB,4CAAG;AACrD;AACA;AACA;AACA,2BAA2B,kDAAU;AACrC;AACA;AACA;AACA,sBAAsB,4CAAG;AACzB;AACA;AACA;AACA,2BAA2B,kDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAsB;AACtC;AACA;AACA;AACA,oCAAoC,KAAK;AACzC,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAgB;AACjC;AACA;AACA;AACA;AACmC;;;;;;;;;;;;;;;;ACpSW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAS;AACrC,4BAA4B,wDAAS;AACrC,4BAA4B,wDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sCAAsC;AAC5D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAS;AACjB,+BAA+B,wDAAS;AACxC;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAS;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;;;;;;AC7RF;AACA;AACA;AAC2C;AAC3C;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY,oDAAc;AAC1B;AACA;AACA;AAKE;;;;;;;;;;;;;;;;;;AC9BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACG;AAC9C;AACA;AACA;AACA,6BAA6B,yDAAa;AAC1C,wCAAwC,EAAE,sDAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,qCAAqC,4BAA4B;AACjE,iCAAiC,4BAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;;;;;;;;;;;;;;;;;;ACxDtC;AACA;AACA;AACA;AAC2C;AACG;;AAEwB;;AAEtE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,kBAAkB,sDAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA,qCAAqC,uDAAe;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAe;AACvB;AACA;AACA,QAAQ,qDAAe;AACvB;AACA,qBAAqB;AACrB,4BAA4B,wDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAe;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,sDAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;;;;;;;;;;;;;;;AC7MvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACb;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCpB;AACA;AACA;AACA;AACkC;AACqB;AAC1B;AACkC;AACZ;AAC0D;AAC1E;AACgE;AAChE;AACiE;;AAE7D;;AAEvC,qBAAqB,4CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAU,WAAW;AACnE,iDAAiD,mDAAU,cAAc;AACzE,gDAAgD,mDAAU,cAAc;AACxE,oDAAoD,mDAAU,cAAc;AAC5E,oDAAoD,mDAAU,aAAa;AAC3E;AACA,kDAAkD,mDAAU,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU,YAAY;AACnD;AACA;AACA,6BAA6B,mDAAU,aAAa;AACpD;AACA;AACA;AACA;AACA,8BAA8B,uDAAc;AAC5C,4BAA4B,uDAAc;AAC1C,6BAA6B,uDAAc;AAC3C,4BAA4B,2DAAS;AACrC;AACA,6BAA6B,uCAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU,YAAY;AACnD;AACA;AACA,6BAA6B,mDAAU,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAc;AAC/C,+BAA+B,uDAAc;AAC7C,gCAAgC,uDAAc;AAC9C,+BAA+B,2DAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU,iBAAiB;AACxD;AACA;AACA,6BAA6B,mDAAU,gBAAgB;AACvD;AACA;AACA,6BAA6B,mDAAU,eAAe;AACtD;AACA;AACA;AACA;AACA,iCAAiC,0DAAiB;AAClD,2BAA2B,wDAAe;AAC1C,iCAAiC,0DAAiB;AAClD,gCAAgC,0DAAiB;AACjD,+BAA+B,0DAAiB;AAChD;AACA,gCAAgC,6CAAO,kBAAkB,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAU,iBAAiB;AACxD;AACA;AACA,6BAA6B,mDAAU,gBAAgB;AACvD;AACA;AACA,6BAA6B,mDAAU,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0DAAiB;AACrD,kCAAkC,wDAAe;AACjD,oCAAoC,0DAAiB;AACrD,mCAAmC,0DAAiB;AACpD,kCAAkC,0DAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAU;AAChD;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAkB,OAAO;AACxD,sBAAsB,gEAAgB;AACtC,mCAAmC,kEAAkB,OAAO;AAC5D;AACA;AACA;AACA,oCAAoC,kEAAkB,QAAQ;AAC9D;AACA,2BAA2B,gEAAgB;AAC3C;AACA;AACA;AACA;AACA,uCAAuC,kEAAkB,QAAQ;AACjE;AACA;AACA,oCAAoC,kEAAkB,SAAS;AAC/D;AACA;AACA;AACA;AACA,iCAAiC,6DAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAkB,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA,4CAA4C,kEAAkB,QAAQ;AACtE;AACA,yCAAyC,kEAAkB,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAkB,OAAO;AAC3D,6BAA6B,gEAAgB;AAC7C,sCAAsC,kEAAkB,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAU,iBAAiB;AACjE;AACA,sCAAsC,mDAAU,iBAAiB;AACjE;AACA,mCAAmC,0DAAiB,MAAM;AAC1D,yCAAyC,mDAAU;AACnD;AACA,4BAA4B,yDAAe;AAC3C;AACA,wCAAwC,0DAAiB,SAAS;AAClE,wCAAwC,0DAAiB,SAAS;AAClE,oCAAoC,2DAAS,OAAO,sDAAI;AACxD;AACA,wCAAwC,6CAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAU,iBAAiB;AACjE;AACA,sCAAsC,mDAAU,iBAAiB;AACjE,oCAAoC,0DAAiB,MAAM;AAC3D,+BAA+B,yDAAe;AAC9C;AACA;AACA,6CAA6C,0DAAiB,SAAS;AACvE;AACA;AACA,6CAA6C,0DAAiB,SAAS;AACvE;AACA;AACA,yCAAyC,2DAAS;AAClD;AACA;AACA;AACgB;;;;;;;;;;;;;;;;;ACxQhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACY;;;;;;;;;;;;;;;;;;;;;;ACpCC;AACS;AACE;AAC+B;AAC1B;AAC3B;;AAE6B;;AAE1D,wBAAwB,kDAAS;AACjC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,oBAAoB;AAClE;AACA,oCAAoC,kDAAU,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA,sBAAsB,+CAAO;AAC7B;AACA;AACA;AACA,6BAA6B,uCAAI;AACjC;AACA;AACA;AACA,uCAAuC,kEAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6DAAe;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uCAAI;AACvC;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC;AACA,oCAAoC,kDAAU;AAC9C;AACA;AACA,oCAAoC,kDAAU,wBAAwB;AACtE;AACA,YAAY,kDAAU,yBAAyB;AAC/C;AACA,0BAA0B,kDAAU;AACpC;AACA;AACA,uCAAuC,kDAAU,wBAAwB;AACzE;AACA,mCAAmC,kDAAU;AAC7C;AACA,mCAAmC,kDAAU,wBAAwB;AACrE;AACA,YAAY,kDAAU,yBAAyB;AAC/C;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA,sCAAsC,kDAAU,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAsB;AACzD;AACA;AACA;AACA;AACA,mCAAmC,kDAAU,wBAAwB;AACrE;AACA,YAAY,kDAAU,yBAAyB;AAC/C;AACA;AACA,+BAA+B,kDAAU,wBAAwB;AACjE,+BAA+B,kEAAsB;AACrD,8BAA8B,2DAAS;AACvC;AACA,oCAAoC,kDAAU,yBAAyB;AACvE,cAAc,kDAAU,uBAAuB;AAC/C,qCAAqC,kEAAsB;AAC3D;AACA,cAAc,kDAAU,yBAAyB;AACjD,cAAc,kDAAU,wBAAwB;AAChD,qCAAqC,kEAAsB;AAC3D;AACA,0CAA0C,kDAAU,yBAAyB;AAC7E,cAAc,kDAAU,sBAAsB;AAC9C;AACA,UAAU,kEAAsB;AAChC;AACA,oCAAoC,kDAAU,yBAAyB;AACvE,cAAc,kDAAU,wBAAwB;AAChD,sCAAsC,kEAAsB;AAC5D;AACA,8BAA8B,gDAAQ;AACtC;AACA;AACA,iCAAiC,gDAAQ;AACzC;AACA;AACA,QAAQ;AACR,qCAAqC,gDAAQ;AAC7C,sCAAsC,gDAAQ;AAC9C;AACA;AACA,kCAAkC,kDAAU,wBAAwB;AACpE;AACA;AACA,sCAAsC,kDAAU,wBAAwB;AACxE;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;;;;;ACrLnB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACa;;;;;;;;;;;;;;;;;;;;;;AC3BN;AAC+B;AACC;AACpB;AACZ;AACG;;AAEsB;;AAE3D;AACA;AACA;AACA;AACA,mBAAmB,4CAAS;AAC5B;AACA,WAAW;AACX;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAU,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAG,qBAAqB,4CAAG;AAChD,uBAAuB,4CAAG;AAC1B;AACA,UAAU,oBAAoB,4CAAG;AACjC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,qBAAqB,4CAAG;AACxB;AACA;AACA,qBAAqB,4CAAG;AACxB;AACA;AACA,qBAAqB,4CAAG,qBAAqB,4CAAG,oBAAoB,4CAAG;AACvE,qBAAqB,4CAAG;AACxB;AACA;AACA;AACA;AACA,+CAA+C,kDAAU,SAAS;AAClE;AACA,6DAA6D,kDAAU,KAAK;AAC5E;AACA;AACA,kDAAkD,kDAAU,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,+CAAQ;AAChC;AACA,KAAK;AACL;AACA,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C;AACA;AACA;AACA,0CAA0C,+CAAO,iBAAiB;AAClE;AACA,yBAAyB,+CAAO,cAAc;AAC9C;AACA;AACA,yBAAyB,+CAAO,mBAAmB;AACnD;AACA;AACA;AACA;AACA,oCAAoC,iDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0DAAQ,YAAY,0DAAQ;AAC7D,sBAAsB,2DAAS;AAC/B;AACA;AACA,0BAA0B,0DAAc;AACxC;AACA,kDAAkD,0DAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAS,OAAO,sDAAI;AAClD;AACA,sBAAsB,2DAAS,OAAO,sDAAI;AAC1C,sBAAsB,2DAAS;AAC/B,KAAK;AACL;AACA,sBAAsB,2DAAS;AAC/B,sBAAsB,2DAAS,OAAO,sDAAI;AAC1C,KAAK;AACL;AACA;AACA;AACA,iCAAiC,2DAAS;AAC1C;AACA,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA,yBAAyB,2DAAS;AAClC,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAS;AAC9C,qCAAqC,wDAAS;AAC9C;AACA,wBAAwB,+CAAQ;AAChC;AACA,KAAK;AACL;AACA;AACc;;;;;;;;;;;;;;;;;;AC5Kd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA,CAAC,8BAA8B;AAC2B;;;;;;;;;;;;;;;;;;;;;;ACnCxB;AACmB;AACY;AACnB;AACZ;;AAE2C;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAU;AACpD,mCAAmC,kDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAU;AACpD,oCAAoC,kDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kDAAU,SAAS;AACjE;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA;AACA,0CAA0C,kDAAU,SAAS;AAC7D;AACA,sBAAsB,oDAAY;AAClC,MAAM;AACN;AACA,gCAAgC,2DAAS;AACzC;AACA;AACA;AACA,kCAAkC,2DAAS;AAC3C;AACA;AACA,UAAU,2DAAS;AACnB,oCAAoC,2DAAS,WAAW,sDAAI;AAC5D,gCAAgC,0DAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAS;AACjB;AACA,mBAAmB,iDAAS;AAC5B;AACA,QAAQ,kBAAkB,iDAAS;AACnC;AACA,QAAQ;AACR,wBAAwB,oDAAY;AACpC;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,8BAA8B,wDAAS;AACvC,8BAA8B,wDAAS;AACvC,4BAA4B,wDAAS;AACrC;AACA,QAAQ,wDAAS;AACjB;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mEAAsB;AACxC;AACA;AACA;AACA,qCAAqC,KAAK;AAC1C,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAU;AAClD;AACA,+BAA+B,kDAAU;AACzC,8BAA8B,2DAAS;AACvC,cAAc,mDAAW,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAU;AACnD,kCAAkC,kDAAU;AAC5C,8BAA8B,2DAAS;AACvC,cAAc,mDAAW,gBAAgB;AACzC;AACA;AACA;AACA;AACA,iCAAiC,2DAAS;AAC1C,iCAAiC,2DAAS;AAC1C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,kCAAkC,wDAAS;AAC3C,iCAAiC,wDAAS;AAC1C,iCAAiC,wDAAS;AAC1C,+BAA+B,wDAAS;AACxC;AACA,QAAQ,wDAAS;AACjB;AACA,QAAQ,wDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACmC;;;;;;;;;;;;;;;;;ACjOnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA,CAAC,sCAAsC;AACO;;;;;;;;;;;;;;;;;;;;;;;;AC5B9C;AACwC;AACe;AACT;AACZ;AACU;AAC+C;AACtD;;AAE4B;AACE;;AAEnE;AACA;AACA;AACA,2BAA2B,kDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4CAAG;AACrD,oBAAoB,4CAAG;AACvB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,6BAA6B,kDAAU;AACvC,2CAA2C,kDAAU;AACrD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAU,mBAAmB;AACjE,+BAA+B,wDAAS;AACxC,+BAA+B,wDAAS;AACxC,SAAS,0DAAkB;AAC3B;AACA;AACA;AACA,6BAA6B,2DAAS,OAAO,sDAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kDAAU,iBAAiB;AAC1E,oCAAoC,kDAAU,iBAAiB;AAC/D;AACA,sBAAsB,qDAAa;AACnC;AACA;AACA;AACA;AACA,kCAAkC,kDAAU;AAC5C,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wDAAe,MAAM;AACzD;AACA,uBAAuB,+CAAK;AAC5B;AACA;AACA,UAAU,qDAAY;AACtB;AACA;AACA,mBAAmB,8DAAY;AAC/B;AACA;AACA,KAAK;AACL;AACA,oCAAoC,kDAAU,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAY;AACxB;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA,+BAA+B,wDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAS;AACjB,qCAAqC,iDAAS;AAC9C;AACA,QAAQ,iDAAS;AACjB,sCAAsC,iDAAS;AAC/C;AACA,QAAQ,iDAAS;AACjB,oCAAoC,iDAAS;AAC7C;AACA,QAAQ,iDAAS;AACjB,mCAAmC,iDAAS;AAC5C;AACA,QAAQ,iDAAS;AACjB,wCAAwC,iDAAS;AACjD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kDAAU,UAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAU,WAAW;AACrD;AACA;AACA,8BAA8B,kDAAU,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;;;AC1RtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;;;;;;;;;;;;;;;;AC/CU;AAEvC,6BAAe,oCAAU,SAAmB;IAC1C,MAAM,eAAe,GACnB,wBAAwB,GAAG,SAAS,CAAC,CAAC,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAE,CAAC;IAE5E,OAAO,CACL,+DAAK,KAAK,EAAE,eAAe;QACzB,+DAAK,KAAK,EAAC,kBAAkB;YAC3B,kEAAQ,KAAK,EAAC,0CAA0C,gBAE/C;YACT,kEAAQ,KAAK,EAAC,wCAAwC,cAAiB,CACnE,CACF,CACP,CAAC;AACJ,CAAC;;;;;;;;;;;;;;;;AChBsC;AAEvC,6BAAe,sCAAY;IACzB,MAAM,KAAK,GAAG;QACZ;YACE,KAAK,EAAE,UAAU;YACjB,IAAI,EAAE,GAAG;SACV;QACD;YACE,KAAK,EAAE,UAAU;YACjB,IAAI,EAAE,WAAW;SAClB;KACF,CAAC;IACF,OAAO,CACL,+DAAK,KAAK,EAAC,wDAAwD;QACjE,+DAAK,KAAK,EAAC,uBAAuB;YAChC,8DAAI,KAAK,EAAC,mBAAmB,IAC1B,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAChB,4BAA4B;YAC5B,8DAAI,KAAK,EAAC,mBAAmB;gBAC3B,6DACE,KAAK,EAAC,mBAAmB,EACzB,IAAI,EAAE,CAAC,CAAC,IAAI,EACZ,OAAO,EAAC,iBAAiB,kBACZ,MAAM,IAElB,CAAC,CAAC,KAAK,CACN,CACD,CACN,CAAC,CACC,CACD,CACF,CACP,CAAC;AACJ,CAAC;;;;;;;;;;;;;;;;AClCsC;AAEvC,6BAAe,oCAAU,gBAA0B;IACjD,OAAO,CACL,+DAAK,KAAK,EAAC,wBAAwB;QACjC,+DAAK,KAAK,EAAC,sBAAsB;YAE9B,gBAAgB,CAAC,CAAC,CAAC,CAClB,+DAAK,KAAK,EAAC,wBAAwB;gBACjC,kEACE,KAAK,EAAC,gCAAgC,gBAC3B,4BAA4B;oBAEvC,+DACE,KAAK,EAAC,2BAA2B,EACjC,IAAI,EAAC,cAAc,iBACP,MAAM;wBAElB,+DAAK,IAAI,EAAC,kCAAkC,GAAO,CAC/C,CACC,CACL,CACP,EAAC,CAAC,EAAE;YACL,+DAAK,KAAK,EAAC,mBAAmB;gBAC5B,6DAAG,KAAK,EAAC,wBAAwB,EAAC,IAAI,EAAC,GAAG,EAAC,KAAK,EAAC,QAAQ;oBAEvD,+DAAK,KAAK,EAAC,6BAA6B;wBACtC,+DACE,KAAK,EAAC,uBAAuB,EAC7B,IAAI,EAAC,cAAc,iBACP,MAAM;4BAElB,+DAAK,IAAI,EAAC,8CAA8C,GAAO,CAC3D,CACF;oBACN,gEAAM,KAAK,EAAC,4BAA4B,cAAe,CACrD,CACA,CACF,CACF,CACP,CAAC;AACJ,CAAC;;;;;;;;;;;;;;;;ACzCsC;AAEvC,6BAAe;IACb,OAAO,CACL,6DAAG,IAAI,EAAC,UAAU,EAAC,KAAK,EAAC,6CAA6C,sBAElE,CACL,CAAC;AACJ,CAAC;;;;;;;;;;;;;;;;;;;;;ACRsC;AAEvC,aAAa;AAC0C;AACd;AACc;AACZ;AAE3C,gBAAgB;AACsB;AAEtC,6BAAe,sCAAY;IACzB,UAAU,CAAC,GAAG,EAAE;QACd,MAAM,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAc,cAAc,CAAC,CAAC;QACrE,IAAI,QAAQ;YAAE,IAAI,gDAAM,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC,EAAE,GAAG,CAAC,CAAC;IAER,OAAO,CACL;QACE,kEAAQ,KAAK,EAAC,iCAAiC;YAE5C,qEAAa,EAAE;YAChB,+DAAK,KAAK,EAAC,2CAA2C;gBACpD,+DAAK,KAAK,EAAC,mBAAmB;oBAE3B,8DAAM,CAAC,IAAI,CAAC;oBAEZ,qEAAa,CAAC,KAAK,CAAC,CACjB,CACF;YACN,+DAAK,KAAK,EAAC,gEAAgE;gBACzE,+DAAK,KAAK,EAAC,mBAAmB;oBAE3B,8DAAM,CAAC,KAAK,CAAC;oBAEb,+DAAO,EAAE;oBAET,qEAAa,CAAC,IAAI,CAAC,CAChB,CACF;YACN,+DACE,KAAK,EAAC,8BAA8B,EACpC,IAAI,EAAC,QAAQ,gBACF,YAAY,GAClB,CACA,CACF,CACV,CAAC;AACJ,CAAC","sources":["webpack://sensemaking-tools-prototype/./_glue/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/ambientvideo/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/ambientvideo/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/banner/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/banner/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/base/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/base/utils.js","webpack://sensemaking-tools-prototype/./_glue/lib/carousel/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/carousel/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/constants/attribute.js","webpack://sensemaking-tools-prototype/./_glue/lib/constants/classes.js","webpack://sensemaking-tools-prototype/./_glue/lib/copy/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/copy/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/debounce/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/easing/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/events/eventtarget.js","webpack://sensemaking-tools-prototype/./_glue/lib/events/eventtype.js","webpack://sensemaking-tools-prototype/./_glue/lib/events/key.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/content/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/model/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/model/modelfactory.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/toggle/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/expansionpanels/toggleall/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/category/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/chip/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/result/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/state_manager/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/filter/util/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/focus/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/footer/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/footer/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/deepnav/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/deepnav/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/deepnav/menubaritem.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/drawer/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/drawer/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/popupmenu/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/popupmenu/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/popupmenu/menuitem.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/siteswitcher/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/siteswitcher/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/steppednav/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/steppednav/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/header/steppednav/pages.js","webpack://sensemaking-tools-prototype/./_glue/lib/jumplinks/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/jumplinks/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/math/coordinate.js","webpack://sensemaking-tools-prototype/./_glue/lib/modal/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/modal/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/observer/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/popover/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/popover/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/responsivemonitor/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/smoothscroll/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/smoothscroll/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/smoothscroll/scrollmanager.js","webpack://sensemaking-tools-prototype/./_glue/lib/social/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/social/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/tabpanels/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/tabpanels/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/tabs/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/tabs/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/tooltip/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/tooltip/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/ytvideo/constants.js","webpack://sensemaking-tools-prototype/./_glue/lib/ytvideo/index.js","webpack://sensemaking-tools-prototype/./_glue/lib/ytvideo/videomanager.js","webpack://sensemaking-tools-prototype/./src/layout/header/components/callToActions.tsx","webpack://sensemaking-tools-prototype/./src/layout/header/components/linkbar.tsx","webpack://sensemaking-tools-prototype/./src/layout/header/components/lockup.tsx","webpack://sensemaking-tools-prototype/./src/layout/header/components/skipToContent.tsx","webpack://sensemaking-tools-prototype/./src/layout/header/index.tsx"],"sourcesContent":["/**\n * @fileoverview Glue lib component source re-export.\n * **ONLY USED FOR THE NODE MODULE**\n */\nimport {AmbientVideo} from './lib/ambientvideo';\nimport {Banner} from './lib/banner';\nimport {Carousel} from './lib/carousel/';\nimport {Copy} from './lib/copy';\nimport {Debounce} from './lib/debounce/';\nimport {ExpansionPanels} from './lib/expansionpanels/';\nimport {Filter, FilterStateManager} from './lib/filter/';\nimport {Footer} from './lib/footer';\nimport {Header} from './lib/header';\nimport {Jumplinks} from './lib/jumplinks/';\nimport {Modal} from './lib/modal';\nimport {ResponsiveMonitor,} from './lib/responsivemonitor/';\nimport {SmoothScroll} from './lib/smoothscroll/';\nimport {ScrollManager} from './lib/smoothscroll/scrollmanager';\nimport {Social} from './lib/social';\nimport {TabPanels} from './lib/tabpanels';\nimport {Tabs} from './lib/tabs';\nimport {Tooltip} from './lib/tooltip';\nimport {YoutubeVideo} from './lib/ytvideo';\n\nexport {\n  AmbientVideo,\n  Banner,\n  Carousel,\n  Copy,\n  Debounce,\n  ExpansionPanels,\n  Filter,\n  FilterStateManager,\n  Footer,\n  Header,\n  Jumplinks,\n  Modal,\n  ResponsiveMonitor,\n  ScrollManager,\n  SmoothScroll,\n  Social,\n  TabPanels,\n  Tabs,\n  Tooltip,\n  YoutubeVideo,\n};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-ambient-video';\nCssClasses['BUTTON'] = 'glue-ambient-video__button';\nCssClasses['BUTTON_PAUSE'] = 'glue-ambient-video__button--paused';\nCssClasses['BUTTON_ICON'] = 'glue-ambient-video__icon';\nCssClasses['BUTTON_ICON_PLAY'] = 'glue-ambient-video__icon-play';\nCssClasses['BUTTON_ICON_PAUSE'] = 'glue-ambient-video__icon-pause';\nCssClasses['VIDEO_CONTAINER'] = 'glue-ambient-video__container';\nCssClasses['LIGHT'] = 'glue-ambient-video--light';\nCssClasses['TOOLTIP'] = 'glue-ambient-video__tooltip';\nCssClasses['TOOLTIP_PLAY'] = 'glue-ambient-video__tooltip-play';\nCssClasses['TOOLTIP_PAUSE'] = 'glue-ambient-video__tooltip-pause';\n})(CssClasses || (CssClasses = {}));\nvar ErrorMessage;\n(function(ErrorMessage) {\nErrorMessage['BUTTON_ELEMENT_MISSING'] = 'Ambient Button element is missing.';\nErrorMessage['BUTTON_ICON_ELEMENT_MISSING'] =\n    'Ambient Button Icon element is missing';\nErrorMessage['MEDIA_ELEMENT_MISSING'] = 'Ambient Media element is missing.';\nErrorMessage['PLAY_VIDEO_ERROR'] = 'Play video interrupted.';\nErrorMessage['TOOLTIP_PLAY_MISSING'] =\n    'Ambient Tooltip play element is missing';\nErrorMessage['TOOLTIP_PAUSE_MISSING'] =\n    'Ambient Tooltip pause element is missing';\n})(ErrorMessage || (ErrorMessage = {}));\nexport {CssClasses, ErrorMessage};\n","import {__awaiter} from 'tslib';\n\nimport {Component} from '../base';\nimport {Attribute, Role, TabIndex} from '../constants/attribute';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\n\nimport {CssClasses, ErrorMessage} from './constants';\n\n/**\n * Glue Ambient Video component\n */\nclass AmbientVideo extends Component {\n  constructor(root) {\n    super(root);\n    /**\n     * Checks the state of video and play/pause accordingly.\n     * Adds/Removes the class to toggle the text of tooltip and svg icon\n     */\n    this.togglePlayerState = (event) => {\n      if (event instanceof KeyboardEvent && event.key !== Key.ENTER &&\n          event.key !== Key.SPACE) {\n        return;\n      }\n      if (!this.videoContainer.paused) {\n        this.pauseVideo();\n      } else {\n        this.playVideo();\n      }\n    };\n    const mediaElement =\n        this.root.querySelector(`.${CssClasses.VIDEO_CONTAINER}`);\n    if (!mediaElement) {\n      throw new Error(ErrorMessage.MEDIA_ELEMENT_MISSING);\n    } else {\n      this.videoContainer = mediaElement;\n    }\n    let element = this.root.querySelector(`.${CssClasses.BUTTON}`);\n    if (!element) {\n      throw new Error(ErrorMessage.BUTTON_ELEMENT_MISSING);\n    } else {\n      this.button = element;\n    }\n    element = this.button.querySelector(`.${CssClasses.BUTTON_ICON}`);\n    if (!element) {\n      throw new Error(ErrorMessage.BUTTON_ICON_ELEMENT_MISSING);\n    } else {\n      this.icon = element;\n    }\n    element = this.button.querySelector(`.${CssClasses.TOOLTIP_PLAY}`);\n    if (!element) {\n      throw new Error(ErrorMessage.TOOLTIP_PLAY_MISSING);\n    } else {\n      this.tooltipPlay = element;\n    }\n    element = this.button.querySelector(`.${CssClasses.TOOLTIP_PAUSE}`);\n    if (!element) {\n      throw new Error(ErrorMessage.TOOLTIP_PAUSE_MISSING);\n    } else {\n      this.tooltipPause = element;\n    }\n    this.playVideo();\n    this.initialize();\n  }\n  initialize() {\n    this.button.setAttribute(Attribute.ROLE, Role.BUTTON);\n    this.button.tabIndex = TabIndex.TABBABLE;\n    this.icon.tabIndex = TabIndex.NOT_TABBABLE;\n    this.setTooltipId();\n    this.button.addEventListener(EventType.CLICK, this.togglePlayerState);\n    this.button.addEventListener(EventType.KEYDOWN, this.togglePlayerState);\n  }\n  /**\n   * Set default ID value for tooltips if they are not provided.\n   */\n  setTooltipId() {\n    if (!this.tooltipPlay || !this.tooltipPause) return;\n    if (!this.tooltipPlay.id) {\n      this.tooltipPlay.id = CssClasses.TOOLTIP_PLAY;\n    }\n    if (!this.tooltipPause.id) {\n      this.tooltipPause.id = CssClasses.TOOLTIP_PAUSE;\n    }\n  }\n  /**\n   * Plays video\n   */\n  playVideo() {\n    return __awaiter(this, void 0, void 0, function*() {\n      try {\n        yield this.videoContainer.play();\n        this.button.classList.add(CssClasses.BUTTON_PAUSE);\n        this.button.setAttribute(\n            Attribute.ARIA_LABELLEDBY, this.tooltipPause.id);\n      } catch (error) {\n        this.button.classList.remove(CssClasses.BUTTON_PAUSE);\n        console.error(error);\n      }\n    });\n  }\n  /**\n   * Pause video\n   */\n  pauseVideo() {\n    this.videoContainer.pause();\n    this.button.classList.remove(CssClasses.BUTTON_PAUSE);\n    this.button.setAttribute(Attribute.ARIA_LABELLEDBY, this.tooltipPlay.id);\n  }\n  /**\n   * Resets component and removes event listeners.\n   */\n  destroy() {\n    this.button.removeAttribute(Attribute.TAB_INDEX);\n    this.button.removeAttribute(Attribute.ARIA_LABEL);\n    this.button.removeAttribute(Attribute.ROLE);\n    this.icon.removeAttribute(Attribute.TAB_INDEX);\n    this.button.removeEventListener(EventType.CLICK, this.togglePlayerState);\n    this.button.removeEventListener(EventType.KEYDOWN, this.togglePlayerState);\n  }\n}\nexport {AmbientVideo};\n","/**\n * @fileoverview Constants used by the Banner component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['BANNER'] = 'glue-banner';\nCssClasses['BANNER_CONTENT'] = 'glue-banner__content';\nCssClasses['BANNER_CLOSE_BUTTON'] = 'glue-banner__close-btn';\nCssClasses['BANNER_HIDDEN'] = 'glue-banner--hidden';\n})(CssClasses || (CssClasses = {}));\nvar Numbers;\n(function(Numbers) {\nNumbers[Numbers['BANNER_CLOSE_DELAY'] = 300] = 'BANNER_CLOSE_DELAY';\n})(Numbers || (Numbers = {}));\nvar Strings;\n(function(Strings) {\nStrings['DEFAULT_CLOSE_BUTTON_ARIA_LABEL'] = 'Hide the banner';\nStrings['DEFAULT_EMPHASIS'] = 'low';\n})(Strings || (Strings = {}));\nexport {CssClasses, Numbers, Strings};\n","import {Component} from '../base';\nimport {EventType} from '../events/eventtype';\n\nimport {CssClasses, Numbers} from './constants';\n\n/**\n * A class that displays an important message or helps user perform action\n * through links or button.\n */\nclass Banner extends Component {\n  constructor(root) {\n    var _a;\n    super(root);\n    this.handleClick = () => {\n      this.close();\n    };\n    this.closeButton =\n        this.root.querySelector(`.${CssClasses.BANNER_CLOSE_BUTTON}`);\n    (_a = this.closeButton) === null || _a === void 0 ?\n        void 0 :\n        _a.addEventListener(EventType.CLICK, this.handleClick);\n  }\n  /**\n   * Hides the banner component when close button is clicked or is a\n   * public method that can directly be called.\n   */\n  close() {\n    this.root.classList.add(CssClasses.BANNER_HIDDEN);\n    setTimeout(() => {\n      this.root.style.display = 'none';\n    }, Numbers.BANNER_CLOSE_DELAY);\n  }\n  /**\n   * Removes event listeners.\n   */\n  destroy() {\n    var _a;\n    (_a = this.closeButton) === null || _a === void 0 ?\n        void 0 :\n        _a.removeEventListener(EventType.CLICK, this.handleClick);\n  }\n}\nexport {Banner};\n","/**\n * @fileoverview Parent class for Vanilla components\n */\nclass Component {\n  constructor(root) {\n    this.root = root;\n  }\n  /**\n   * Subclasses may implement this method to release any resources / deregister\n   * any listeners they have attached. An example of this might be\n   * deregistering a resize event from the window object.\n   */\n  destroy() {}\n  /**\n   * Fires a cross-browser-compatible custom event from the component root of\n   * the given type, with the given data.\n   */\n  emit(evtType, evtData, shouldBubble = false) {\n    const evt = new CustomEvent(evtType, {\n      detail: evtData,\n      bubbles: shouldBubble,\n    });\n    this.root.dispatchEvent(evt);\n  }\n}\nexport {Component};\n","/**\n * @fileoverview Shared utility functions for Glue components.\n */\nimport {Direction} from '../constants/attribute';\n/**\n * Extract numbers from CSS properties, like 20px -> 20.\n * @param val CSS property value.\n */\nfunction toNum(val) {\n  return Number(val.slice(0, -2));\n}\n/**\n * Calculates left/top coordinates for an Overlay element based on the\n * position of the Trigger element and the placement option (default: bottom).\n *\n * By default is uses auto placement which will try to position the Overlay\n * relative to the middle of the trigger element.\n * If there is not enough space it will try to position the Overlay on the\n * opposite side of the trigger element.\n * If there is not enough space on the opposite side it will try to position\n * the Overlay on the edge of the window.\n *\n * If placement is set to left/right/top/bottom it will try to position the\n * Overlay on the specified side of the trigger element. If there is not enough\n * space it will use the auto positioning logic.\n *\n *\n * @param root Root element that contains the Content and Trigger elements.\n * @param overlay Element that contains Overlay content.\n * @param trigger Element that triggers the Overlay.\n * @param placement? Placement of the Overlay, default is bottom. Possible\n *     values are: left, right, top, bottom.\n * @return Array containing overlay absolute positions [left, top].\n */\nexport function getOverlayAutoPosition(\n    root, overlay, trigger, placement = 'bottom') {\n  const overlayStyle = getComputedStyle(overlay);\n  // Ignore auto-positioning if overlay is fixed (such as in Social/mobile).\n  if (overlayStyle.position === 'fixed') {\n    return null;\n  }\n  const triggerStyle = getComputedStyle(trigger);\n  const triggerCoords = trigger.getBoundingClientRect();\n  const overlayCoords = overlay.getBoundingClientRect();\n  const firstSrollableParent = getScrollableParent(root);\n  const scrollbarParentCoords = firstSrollableParent.getBoundingClientRect();\n  const isBody = firstSrollableParent === document.body;\n  const scrollableParentHeight =\n      isBody ? window.innerHeight : scrollbarParentCoords.bottom;\n  // Mirror placement in RTL direction.\n  const isRtl = triggerStyle.direction === Direction.RTL ||\n      document.documentElement.dir === Direction.RTL;\n  if (isRtl) {\n    if (placement === 'left') {\n      placement = 'right';\n    } else if (placement === 'right') {\n      placement = 'left';\n    }\n  }\n  let noSpaceAtRight = false;\n  let noSpaceAtLeft = false;\n  let noSpaceAtTop = false;\n  let noSpaceAtBottom = false;\n  const horizOffset = placement === 'top' || placement === 'bottom' ?\n      Math.abs(triggerCoords.width - overlayCoords.width) / 2 :\n      overlayCoords.width;\n  // Check left edge of the container.\n  noSpaceAtLeft = triggerCoords.left - horizOffset < scrollbarParentCoords.left;\n  // Check right edge of the container.\n  noSpaceAtRight =\n      triggerCoords.right + horizOffset > scrollbarParentCoords.right;\n  // Check bottom edge of the container.\n  noSpaceAtBottom =\n      triggerCoords.top + triggerCoords.height + overlayCoords.height >=\n      scrollableParentHeight;\n  // Check top edge of the container.\n  noSpaceAtTop =\n      triggerCoords.top - overlayCoords.height < scrollbarParentCoords.top;\n  // If there is not enough space on both left and right side of the trigger,\n  // align the center of the overlay with the center of the trigger.\n  if (noSpaceAtLeft && noSpaceAtRight) {\n    const left = (triggerCoords.width - overlayCoords.width) / 2;\n    return noSpaceAtTop ?\n        [left, triggerCoords.height + toNum(overlayStyle.marginTop)] :\n        [left, -overlayCoords.height - toNum(overlayStyle.marginTop)];\n  }\n  if (placement === 'left' || placement === 'right') {\n    return getOverlayAutoPositionHorizontal(\n        placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,\n        noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight);\n  } else {\n    return getOverlayAutoPositionVertical(\n        placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,\n        noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight);\n  }\n}\n/**\n * Calculates overlay position for horizontal placements.\n */\nfunction getOverlayAutoPositionHorizontal(\n    placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,\n    noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight) {\n  let left = 0;\n  let top = 0;\n  if (!noSpaceAtTop && !noSpaceAtBottom) {\n    // If there is enough space, aligns the center of the overlay with the\n    // center of the trigger, including margins.\n    const triggerVerticalSpace = triggerCoords.height +\n        toNum(triggerStyle.marginTop) + toNum(triggerStyle.marginBottom);\n    const overlayVerticalSpace = overlayCoords.height +\n        toNum(overlayStyle.marginTop) + toNum(overlayStyle.marginBottom);\n    top = (triggerVerticalSpace - overlayVerticalSpace) / 2;\n  } else {\n    // Align the top of the overlay with the top of the trigger.\n    // If there is not enough space, align the bottom of the overlay with the\n    // bottom of the trigger.\n    top = noSpaceAtTop ? 0 : triggerCoords.height - overlayCoords.height;\n    top += toNum(triggerStyle.marginTop) - toNum(overlayStyle.marginTop);\n  }\n  // Horizontal position after the trigger, including trigger content.\n  const rightDistanceFromTrigger =\n      triggerCoords.width + toNum(triggerStyle.marginRight);\n  // Horizontal position before the trigger, including overlay content.\n  const leftDistanceFromTrigger =\n      overlayCoords.width + toNum(overlayStyle.marginRight);\n  // LEFT: before the trigger.\n  // RIGHT: after the trigger.\n  // Switch to the opposite side if there is not enough space.\n  if (placement === 'left') {\n    left = noSpaceAtLeft ? rightDistanceFromTrigger : -leftDistanceFromTrigger;\n  } else {\n    left = noSpaceAtRight ? -leftDistanceFromTrigger : rightDistanceFromTrigger;\n  }\n  return [left, top];\n}\n/**\n * Calculates overlay position for vertical placements.\n */\nfunction getOverlayAutoPositionVertical(\n    placement, triggerCoords, overlayCoords, triggerStyle, overlayStyle,\n    noSpaceAtTop, noSpaceAtBottom, noSpaceAtLeft, noSpaceAtRight) {\n  let left = 0;\n  let top = 0;\n  if (!noSpaceAtLeft && !noSpaceAtRight) {\n    // If there is enough space, aligns the center of the overlay with the\n    // center of the trigger.\n    left = (triggerCoords.width - overlayCoords.width) / 2;\n  } else {\n    // Align the left of the overlay with the right of the trigger.\n    // If there is not enough space, align the right of the overlay with the\n    // left of the trigger.\n    let triggerHorizSpace = toNum(triggerStyle.marginLeft);\n    let overlayHorizSpace = toNum(overlayStyle.marginLeft);\n    if (noSpaceAtRight) {\n      triggerHorizSpace += triggerCoords.width;\n      overlayHorizSpace += overlayCoords.width;\n    }\n    left = triggerHorizSpace - overlayHorizSpace;\n  }\n  // Vertical position above the trigger, including trigger content.\n  const downDistanceFromTrigger =\n      triggerCoords.height + toNum(overlayStyle.marginTop);\n  // Vertical position below the trigger, including overlay content.\n  const upDistanceFromTrigger =\n      overlayCoords.height + toNum(overlayStyle.marginTop);\n  // TOP: above the trigger.\n  // BOTTOM: below the trigger.\n  // Switch to the opposite side if there is not enough space.\n  if (placement === 'top') {\n    top = noSpaceAtTop ? downDistanceFromTrigger : -upDistanceFromTrigger;\n  } else {\n    top = noSpaceAtBottom ? -upDistanceFromTrigger : downDistanceFromTrigger;\n  }\n  return [left, top];\n}\n/**\n * Determines scrollable parent element for calculating overlay position.\n * @param elem DOM node for which to find the scrollable parent\n * @return elem DOM node which is the first scrollable parent\n */\nfunction getScrollableParent(elem) {\n  // check if overflow property is set.\n  const isOverflowSet = (overflowValue) =>\n      /auto|hidden|scroll|overlay/.test(overflowValue);\n  const computedStyle = getComputedStyle(elem);\n  if (elem === document.documentElement) return document.body;\n  if (isOverflowSet(computedStyle.overflow) ||\n      isOverflowSet(computedStyle.overflowY) ||\n      isOverflowSet(computedStyle.overflowX)) {\n    return elem;\n  } else {\n    return getScrollableParent(elem.parentElement);\n  }\n}\n","/**\n * @fileoverview Constants used by the Carousel component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['ACTIVE'] = 'glue-is-active';\nCssClasses['BUTTON'] = 'glue-carousel__button';\nCssClasses['BUTTON_NEXT'] = 'glue-carousel__button--next';\nCssClasses['BUTTON_PREV'] = 'glue-carousel__button--prev';\nCssClasses['CARDS'] = 'glue-carousel--cards';\nCssClasses['CAROUSEL'] = 'glue-carousel';\nCssClasses['DISABLE_GRAB'] = 'glue-carousel__list--disable-grab';\nCssClasses['HAS_NAVIGATION'] = 'glue-carousel--has-navigation';\nCssClasses['INACTIVE'] = 'glue-is-inactive';\nCssClasses['ITEM'] = 'glue-carousel__item';\nCssClasses['LIST'] = 'glue-carousel__list';\nCssClasses['MODALS'] = 'glue-carousel__modals';\nCssClasses['NAVIGATION'] = 'glue-carousel__navigation';\nCssClasses['NAVIGATION_DOT'] = 'glue-carousel__dot';\nCssClasses['PEEK_OUT'] = 'glue-carousel--peek-out';\nCssClasses['VIEWPORT'] = 'glue-carousel__viewport';\n})(CssClasses || (CssClasses = {}));\nvar Icons;\n(function(Icons) {\nIcons['CHEVRON_RIGHT'] = 'chevron-right';\nIcons['CHEVRON_LEFT'] = 'chevron-left';\n})(Icons || (Icons = {}));\nvar Numbers;\n(function(Numbers) {\n/**\n * A threshold value that corresponds to the Carousel viewport width.\n * It is factor, a value between 0 to 1.\n * E.g. drag threshold is 0.2 * containerWidth.\n */\nNumbers[Numbers['DRAG_THRESHOLD'] = 0.2] = 'DRAG_THRESHOLD';\n/**\n * The minimum distance that the user needs to move before the carousel\n * recognizes the gesture as a drag (rather than a click, etc).\n */\nNumbers[Numbers['DRAGSTART_THRESHOLD_PX'] = 10] = 'DRAGSTART_THRESHOLD_PX';\n/**\n * Distance in pixels for the card carousel to peek out on small viewport\n */\nNumbers[Numbers['PEEK_DISTANCE'] = 24] = 'PEEK_DISTANCE';\n/**\n * When determining the number of slides per page, if the resulting value is\n * within this range from an integer, round up, otherwise round down.\n * E.g. 1.9999962591720426 => 2\n */\nNumbers[Numbers['ROUNDING_THRESHOLD'] = 0.05] = 'ROUNDING_THRESHOLD';\n})(Numbers || (Numbers = {}));\nvar Strings;\n(function(Strings) {\nStrings['DATA_CAROUSEL_ANIMATION_ATTR'] = 'data-glue-carousel-animation';\nStrings['DATA_CAROUSEL_NAVIGATION_LABEL_ATTR'] =\n    'data-glue-carousel-navigation-label';\nStrings['DATA_DOT'] = 'dot';\nStrings['DATA_NAVIGATION_LABEL'] = 'glueCarouselNavigationLabel';\nStrings['NAVIGATION_ARIA_LABEL_DEFAULT'] = 'Choose slide to display';\nStrings['NAVIGATION_LABEL_DEFAULT'] =\n    'Selected tab $glue_carousel_page_number$ of $glue_carousel_page_total$';\nStrings['NAVIGATION_LABEL_NUMBER_VAR_NAME'] = '$glue_carousel_page_number$';\nStrings['NAVIGATION_LABEL_TOTAL_VAR_NAME'] = '$glue_carousel_page_total$';\nStrings['NAVIGATION_NEXT_LABEL_DEFAULT'] = 'Go to the next slide';\nStrings['NAVIGATION_PREV_LABEL_DEFAULT'] = 'Go to the previous slide';\nStrings['RTL'] = 'rtl';\nStrings['SLIDE_CHANGE'] = 'gluecarouselslidechange';\nStrings['TRANSITION_NONE'] = 'none';\n})(Strings || (Strings = {}));\nvar CarouselType;\n(function(CarouselType) {\nCarouselType['CARDS'] = 'cards';\nCarouselType['IMAGE'] = 'image';\nCarouselType['CUSTOM'] = 'custom';\n})(CarouselType || (CarouselType = {}));\nexport {CarouselType, CssClasses, Icons, Numbers, Strings};\n","import {Component} from '../base';\nimport {Attribute, Role, TabIndex} from '../constants/attribute';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\nimport * as focusUtil from '../focus/';\nimport {Observer} from '../observer';\n\nimport {CssClasses, Numbers, Strings} from './constants';\n\n/** The Glue Carousel component. */\nclass Carousel extends Component {\n  constructor(root, options) {\n    super(root);\n    /** Every navigation dot. */\n    this.dots = [];\n    /** Total number of pages. */\n    this.totalPages = 1;\n    /** The number of visible slides within the viewport. */\n    this.slidesPerPage = 1;\n    /**\n     * A flag to turn on/off animation when the component loads.\n     * It has been used to jump from the dummy slide to the first/last actual\n     * slide.\n     */\n    this.animateOnInitialLoad = false;\n    /** The container width. */\n    this.containerWidth = 0;\n    /** The slide width. */\n    this.slideWidth = 0;\n    /** True if this is an RTL page. */\n    this.isRtl = document.documentElement.dir === Strings.RTL;\n    /**\n     * Flag to determine whether we're using a tab panel navigation model.\n     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Tab_Role\n     */\n    this.isTabModel = true;\n    /**\n     * Flag to determine whether the carousel should show the navigation dots.\n     */\n    this.isShowingNavigation = true;\n    /** A collection of scroll value for each page */\n    this.pagesX = [];\n    /** Initial touch position */\n    this.initialTouchPos = null;\n    /** Flag to determine if the carousel is currently being dragged. */\n    this.isDragging = false;\n    /** Last touch poistion */\n    this.lastTouchPos = null;\n    /** True when it is ready to call request animatino frame */\n    this.rafPending = false;\n    /** Current horizontal position */\n    this.currentXPosition = 0;\n    /**\n     * Set this value to false when dragging option is false and it is on\n     * desktop\n     */\n    this.enableDragging = null;\n    /** Re-renders the carousel when the current slide value changes. */\n    this.handleCurrentSlideChange = () => {\n      this.emit(Strings.SLIDE_CHANGE, this.getCurrentSlide());\n      this.render();\n    };\n    /** Re-calculates and renders the carousel when the window resizes. */\n    this.handleResize = () => {\n      this.animateOnInitialLoad = false;\n      this.calculate();\n      this.render();\n      this.updateTouchEvents();\n    };\n    /** Sets the current slide value to the appropriate slide on UI clicks. */\n    this.handleClick = (event) => {\n      const target = event.target;\n      if (target instanceof HTMLElement ||\n          // iOS VoiceOver triggers the event from the svg (b/192919688)\n          target instanceof window['SVGElement']) {\n        if (target.closest(`.${CssClasses.BUTTON_NEXT}`) === this.nextBtn) {\n          this.next();\n        } else if (\n            target.closest(`.${CssClasses.BUTTON_PREV}`) === this.prevBtn) {\n          this.previous();\n        } else if (\n            target instanceof HTMLButtonElement && this.dots.includes(target)) {\n          const page = Number(target.dataset[Strings.DATA_DOT]);\n          this.setCurrentPage(page);\n        } else if (this.isCards && this.isDragging) {\n          // Do not trigger a card click if the carousel has been dragged.\n          event.preventDefault();\n        }\n      }\n    };\n    /**\n     * Sets the current slide value to the appropriate slide on left/right\n     * keyboard press.\n     */\n    this.handleKeydown = (event) => {\n      const isLeft = event.code === Key.LEFT;\n      const isRight = event.code === Key.RIGHT;\n      if (isLeft || isRight) {\n        const isNext = this.isRtl ? isLeft : isRight;\n        if (event.target instanceof HTMLButtonElement &&\n            this.dots.includes(event.target)) {\n          isNext ? this.next() : this.previous();\n        } else if (\n            event.target instanceof HTMLElement &&\n            this.slides.includes(event.target)) {\n          const increment = isNext ? 1 : -1;\n          this.setCurrentSlide(this.getCurrentSlide() + increment);\n        }\n      }\n    };\n    /** Jumps to the real slides (from a dummy) when the transition ends. */\n    this.handleTransitionEnd = (event) => {\n      if (event.target !== this.slidesContainer) {\n        return;\n      }\n      // Jump to the first or last page if it is cyclical.\n      if (this.options.cyclical) {\n        const currentSlide = this.getCurrentSlide();\n        if (currentSlide > this.totalPages) {\n          // Set the flag to false to prevent animation when it jumps from the\n          // dummy slide to the real slide.\n          this.animateOnInitialLoad = false;\n          this.setCurrentSlide(1);\n        } else if (currentSlide < 1) {\n          this.animateOnInitialLoad = false;\n          this.setCurrentSlide(this.totalPages);\n        }\n      }\n    };\n    this.handleGestureStart = (event) => {\n      event.preventDefault();\n      if ((this.isTouchEvent(event) && event.touches.length > 1) ||\n          (event instanceof PointerEvent && event.button !== 0)) {\n        return;\n      }\n      // Add the move and end listeners\n      if (window.PointerEvent && event instanceof PointerEvent &&\n          event.target instanceof Element) {\n        event.target.setPointerCapture(event.pointerId);\n      } else {\n        // Add Mouse Listeners\n        document.addEventListener(\n            EventType.MOUSEMOVE, this.handleGestureMove, true);\n        document.addEventListener(\n            EventType.MOUSEUP, this.handleGestureEnd, true);\n      }\n      this.initialTouchPos = this.getGesturePointFromEvent(event);\n      this.slidesContainer.style.transition = 'initial';\n    };\n    this.handleGestureMove = (event) => {\n      event.preventDefault();\n      if (!this.initialTouchPos) {\n        return;\n      }\n      // Prevent small taps/etc triggering a dragging interaction\n      const currentTouchPos = this.getGesturePointFromEvent(event);\n      if (!this.isDragging) {\n        const distanceDragged =\n            Math.abs(this.getXDistance(this.initialTouchPos, currentTouchPos));\n        if (distanceDragged < Numbers.DRAGSTART_THRESHOLD_PX) {\n          return;\n        }\n      }\n      this.isDragging = true;\n      this.lastTouchPos = currentTouchPos;\n      if (this.rafPending) {\n        return;\n      }\n      this.rafPending = true;\n      window.requestAnimationFrame(() => {\n        this.onAnimFrame();\n      });\n    };\n    this.handleGestureEnd = (event) => {\n      var _a;\n      event.preventDefault();\n      if (this.isTouchEvent(event) &&\n          ((_a = event.touches) === null || _a === void 0 ? void 0 :\n                                                            _a.length) > 0) {\n        return;\n      }\n      this.rafPending = false;\n      // Remove Event Listeners\n      if (window.PointerEvent && event instanceof PointerEvent &&\n          event.target instanceof Element) {\n        event.target.releasePointerCapture(event.pointerId);\n      } else {\n        // Remove Mouse Listeners\n        document.removeEventListener(\n            EventType.MOUSEMOVE, this.handleGestureMove, true);\n        document.removeEventListener(\n            EventType.MOUSEUP, this.handleGestureEnd, true);\n      }\n      this.updateSwipeRestPosition();\n      this.initialTouchPos = null;\n      this.lastTouchPos = null;\n      // Resetting after to allow for click handler to be called first\n      // (to determine actions based on if carousel has been dragged)\n      setTimeout(() => {\n        this.isDragging = false;\n      }, 0);\n    };\n    this.isCards = this.root.classList.contains(CssClasses.CARDS);\n    this.viewport = this.root.querySelector(`.${CssClasses.VIEWPORT}`);\n    this.slidesContainer = this.root.querySelector(`.${CssClasses.LIST}`);\n    this.slides = Array.from(\n        this.slidesContainer.querySelectorAll(`.${CssClasses.ITEM}`));\n    this.slidesRef = Array.from(this.slides);\n    this.navigation = this.root.querySelector(`.${CssClasses.NAVIGATION}`);\n    this.prevBtn = this.root.querySelector(`.${CssClasses.BUTTON_PREV}`);\n    this.nextBtn = this.root.querySelector(`.${CssClasses.BUTTON_NEXT}`);\n    this.options = Object.assign(\n        Object.assign(Object.assign({}, Carousel.defaults), options),\n        this.getDataAttrs());\n    this.observer = new Observer({currentSlide: this.options.currentSlide});\n    this.setup();\n    this.registerEvents();\n  }\n  /** Returns the default carousel options. */\n  static get defaults() {\n    return {\n      currentSlide: 1,\n      peekOut: true,\n      navigation: true,\n      animation: true,\n      cyclical: false,\n      cardsPerPage: 3,\n      dragging: true,\n    };\n  }\n  /** Sets up the component to prepare for the initial rendering. */\n  setup() {\n    // Add peek out feature class\n    if (this.options.peekOut) {\n      this.root.classList.add(CssClasses.PEEK_OUT);\n    }\n    // Copy dummyslides if it is cyclical\n    if (this.options.cyclical) {\n      this.copyDummySlides();\n    }\n    // Add a11y attributes (note dynamic values are set in render functions)\n    this.slidesContainer.setAttribute(Attribute.ARIA_LIVE, 'polite');\n    this.nextBtn.setAttribute(Attribute.ARIA_CONTROLS, this.root.id);\n    this.prevBtn.setAttribute(Attribute.ARIA_CONTROLS, this.root.id);\n    // Calculate and render\n    this.calculate();\n    this.currentXPosition = -1 * this.pagesX[this.getCurrentPage()];\n    this.render();\n  }\n  /** Registers event listeners. */\n  registerEvents() {\n    this.root.addEventListener(EventType.CLICK, this.handleClick);\n    this.root.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.slidesContainer.addEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n    window.addEventListener(EventType.RESIZE, this.handleResize);\n    this.updateTouchEvents();\n    this.observer.listen('currentSlide', this.handleCurrentSlideChange);\n  }\n  /** Unregisters event listeners on removal of component. */\n  destroy() {\n    for (const slide of this.slides) {\n      slide.removeAttribute(Attribute.TAB_INDEX);\n      slide.removeAttribute(Attribute.ROLE);\n      slide.removeAttribute(Attribute.ARIA_HIDDEN);\n    }\n    this.slidesContainer.style.removeProperty('transform');\n    this.root.removeEventListener(EventType.CLICK, this.handleClick);\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.slidesContainer.removeEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n    this.destroyNavigation();\n    window.removeEventListener(EventType.RESIZE, this.handleResize);\n    if (this.enableDragging) {\n      this.deregisterTouchEvents();\n    }\n    this.observer.unlisten('currentSlide', this.handleCurrentSlideChange);\n  }\n  /** Resets the component to the initial values. */\n  reset() {\n    this.setCurrentSlide(this.options.currentSlide);\n  }\n  /** Calculates carousel properties and scroll values. */\n  calculate() {\n    this.isCards ? this.calculateCardsProperties() : this.calculateProperties();\n    this.calcScrollValue();\n  }\n  /** Calculates and sets properies for non-card carousels. */\n  calculateProperties() {\n    this.containerWidth =\n        toNumber(getComputedStyle(this.slidesContainer).width);\n    this.slideWidth = toNumber(getComputedStyle(this.slides[0]).width);\n    const slidesPerPage = this.containerWidth / this.slideWidth;\n    this.slidesPerPage = 1 - (slidesPerPage % 1) < Numbers.ROUNDING_THRESHOLD ?\n        Math.ceil(slidesPerPage) :\n        Math.floor(slidesPerPage);\n    this.totalPages = Math.ceil(this.slidesRef.length / this.slidesPerPage);\n    this.isShowingNavigation = this.options.navigation;\n    // Only use tabs if there's a 1:1 relationship between slide and dot\n    this.isTabModel = this.isShowingNavigation && this.slidesPerPage === 1;\n  }\n  /**\n   * Calculates items per page and total pages attributes (for card carousels)\n   * and updates the CSS grid styles accordingly.\n   */\n  calculateCardsProperties() {\n    // Determine number of cards to show on the page\n    const breakpoint = this.getCurrentBreakpoint();\n    let cardsPerPage;\n    switch (breakpoint) {\n      case 'sm':\n        // Always show one card at a time on mobile\n        cardsPerPage = 1;\n        break;\n      case 'md':\n        // Tablet shows one less card per page than desktop (minimum one)\n        cardsPerPage = Math.max(1, this.options.cardsPerPage - 1);\n        break;\n      default:\n        // Desktop uses the number of cards set in options\n        cardsPerPage = this.options.cardsPerPage;\n    }\n    // Calculate card & container widths\n    const viewportStyles = getComputedStyle(this.viewport);\n    let viewportWidth = toNumber(viewportStyles.width) -\n        toNumber(viewportStyles.paddingLeft) -\n        toNumber(viewportStyles.paddingRight);\n    if (this.options.peekOut && breakpoint === 'sm') {\n      // Adjust how much of next slide peeks out on small viewport\n      viewportWidth = viewportWidth - Numbers.PEEK_DISTANCE;\n    }\n    const gutter =\n        toNumber(getComputedStyle(this.slidesContainer)['columnGap']);\n    const totalPages = this.slides.length / cardsPerPage;\n    const containerWidth =\n        Math.floor(viewportWidth * totalPages + (totalPages - 1) * gutter);\n    // Update element styles\n    this.slidesContainer.style.width = `${containerWidth}px`;\n    this.slidesContainer.style['gridTemplateColumns'] =\n        `repeat(${this.slides.length}, 1fr)`;\n    // Set properties\n    this.containerWidth = viewportWidth + gutter;\n    this.slidesPerPage = cardsPerPage;\n    this.slideWidth = this.containerWidth / cardsPerPage;\n    this.totalPages = Math.ceil(totalPages);\n    // Never show navigation dots on mobile\n    this.isShowingNavigation = this.options.navigation && breakpoint !== 'sm';\n    // Never use tab model as items are anchors\n    this.isTabModel = false;\n  }\n  /** Renders all the UI components in Carousel. */\n  render() {\n    this.renderSlides();\n    this.renderButtons();\n    this.renderNavigation();\n  }\n  /** Returns the currently active slide (1-indexed). */\n  getCurrentSlide() {\n    return this.observer.data['currentSlide'];\n  }\n  /** Returns the currently visible page (1-indexed). */\n  getCurrentPage() {\n    return Math.ceil(this.getCurrentSlide() / this.slidesPerPage);\n  }\n  /** Sets the currently active slide in the state (1-indexed). */\n  setCurrentSlide(slide) {\n    // Allow setting value to dummies (+/-1) if an animated cyclical carousel\n    const buffer = this.options.cyclical && this.options.animation ? 1 : 0;\n    const min = 1 - buffer;\n    const max = this.slidesRef.length + buffer;\n    // Wrap value if cyclical, behaving like a carousel does visually\n    // eg. Slide 4 of a 3 slide cylical carousel is 1\n    this.observer.data['currentSlide'] =\n        this.options.cyclical ? wrap(slide, min, max) : clamp(slide, min, max);\n  }\n  /** Sets the current slide value to the first slide of the requested page. */\n  setCurrentPage(page) {\n    const slide = (page - 1) * this.slidesPerPage + 1;\n    this.setCurrentSlide(slide);\n  }\n  /** Sets the current slide value to the previous page. */\n  previous() {\n    const previousPage = this.getCurrentPage() - 1;\n    this.setCurrentPage(previousPage);\n  }\n  /** Sets the current slide value to the next page. */\n  next() {\n    const nextPage = this.getCurrentPage() + 1;\n    this.setCurrentPage(nextPage);\n  }\n  /** Renders the appropriate slide attributes. */\n  renderSlides() {\n    this.transit();\n    const currentIndex =\n        wrap(this.getCurrentSlide(), 1, this.slidesRef.length) - 1;\n    const currentPage = this.getCurrentPage();\n    const currentPageIndex = currentPage - 1;\n    const isFocused = document.activeElement instanceof HTMLElement &&\n        this.slides.includes(document.activeElement);\n    for (const [index, slide] of this.slidesRef.entries()) {\n      const isCurrent = index === currentIndex;\n      const isVisible = isCurrent ||\n          // [or] slide is part of the current page\n          Math.floor(index / this.slidesPerPage) === currentPageIndex ||\n          // [or] it's visible on the last page due to edge alignment\n          (currentPage === this.totalPages &&\n           index >= this.slidesRef.length - this.slidesPerPage);\n      if (isVisible ||\n          (this.isCards && document.documentElement.clientWidth < 600)) {\n        slide.removeAttribute(Attribute.ARIA_HIDDEN);\n      } else {\n        slide.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n      }\n      this.isTabModel ? slide.setAttribute(Attribute.ROLE, Role.TABPANEL) :\n                        slide.removeAttribute(Attribute.ROLE);\n      if (this.isCards) {\n        slide.tabIndex = isCurrent ? TabIndex.TABBABLE : TabIndex.NOT_TABBABLE;\n      }\n      // If any slide is in focus, move focus to current\n      if (isCurrent && isFocused) {\n        // Preventing scroll to ensure browser doesn't try and bring the\n        // focussed element into view during transition.\n        slide.focus({preventScroll: true});\n        // To prevent Safari from scrolling.\n        // https://caniuse.com/mdn-api_htmlelement_focus_preventscroll_option\n        setTimeout(() => {\n          this.viewport.scrollLeft = 0;\n        }, 0);\n      }\n    }\n    this.removeFocusOnHiddenElements();\n  }\n  /** Remove keyboard focus on focusable elements in the hidden slides. */\n  removeFocusOnHiddenElements() {\n    const index = wrap(this.getCurrentSlide(), 1, this.slidesRef.length) - 1;\n    const currentIndex = this.options.cyclical ? index + 1 : index;\n    for (const [index, slide] of this.slides.entries()) {\n      const focusableElements = focusUtil.getFocusableElements(slide);\n      for (const focusableElement of focusableElements) {\n        if (index === currentIndex) {\n          focusableElement.removeAttribute(Attribute.TAB_INDEX);\n        } else {\n          focusableElement.tabIndex = TabIndex.NOT_TABBABLE;\n        }\n      }\n    }\n  }\n  /**\n   *  Turn on/off dragging based on settings and screen size.\n   *  In small viewport, dragging is always enabled.\n   *  In other viewport sizes, it depends on the component configurations.\n   */\n  updateTouchEvents() {\n    const breakpoint = this.getCurrentBreakpoint();\n    if (!this.options.dragging && breakpoint !== 'sm') {\n      if (this.enableDragging) this.deregisterTouchEvents();\n      this.slidesContainer.classList.add(CssClasses.DISABLE_GRAB);\n      this.enableDragging = false;\n    } else {\n      if (!this.enableDragging) this.registerTouchEvents();\n      this.slidesContainer.classList.remove(CssClasses.DISABLE_GRAB);\n      this.enableDragging = true;\n    }\n  }\n  /** Updates the transform for the viewport. */\n  transit() {\n    // Turn off animation in the initial loading and when it jumps from the\n    // dummy slide to the real slide.\n    if (!(this.animateOnInitialLoad && this.options.animation)) {\n      this.slidesContainer.style.transition = 'initial';\n    }\n    // Retrieve the new translateX values\n    const newTranslateX = this.pagesX[this.getCurrentPage()];\n    this.slidesContainer.style.transform =\n        `translate3d(${newTranslateX}px, 0, 0)`;\n    this.currentXPosition = newTranslateX;\n    // Turn on animation if it is temporarily turned off.\n    if (this.options.animation && !this.animateOnInitialLoad) {\n      this.turnOnAnimation();\n    }\n  }\n  /** Turns on animation for slides (needs a slight buffer to avoid skips). */\n  turnOnAnimation() {\n    this.animateOnInitialLoad = true;\n    // Use setTimeout to prevent the animation on the initial loading.\n    // There is probably a gap before CSS takes the transform value setup in JS.\n    setTimeout(() => {\n      this.slidesContainer.style.transition = '';\n    }, 10);\n  }\n  /** Renders the appropriate attributes in the dot navigation. */\n  renderNavigation() {\n    // If no navigation is required, hide\n    if (!this.isShowingNavigation) {\n      this.root.classList.remove(CssClasses.HAS_NAVIGATION);\n      return;\n    }\n    // Show navigation and set a11y attributes\n    this.root.classList.add(CssClasses.HAS_NAVIGATION);\n    this.isTabModel ?\n        this.navigation.setAttribute(Attribute.ROLE, Role.TABLIST) :\n        this.navigation.removeAttribute(Attribute.ROLE);\n    // Build dots if number of pages has changed (or first render)\n    if (this.dots.length !== this.totalPages) {\n      this.buildNavigation();\n    }\n    const currentIndex = wrap(this.getCurrentPage(), 1, this.totalPages) - 1;\n    const isFocused = document.activeElement instanceof HTMLButtonElement &&\n        this.dots.includes(document.activeElement);\n    for (const [index, dot] of this.dots.entries()) {\n      const isCurrent = index === currentIndex;\n      dot.classList.toggle(CssClasses.ACTIVE, isCurrent);\n      dot.tabIndex = isCurrent ? TabIndex.TABBABLE : TabIndex.NOT_TABBABLE;\n      if (this.isTabModel) {\n        dot.setAttribute(Attribute.ARIA_SELECTED, `${isCurrent}`);\n      } else {\n        dot.setAttribute(Attribute.ARIA_CURRENT, `${isCurrent}`);\n      }\n      // If any dot is in focus, move focus to current\n      if (isCurrent && isFocused) {\n        dot.focus();\n      }\n    }\n  }\n  /** Shows or hides the next/previous buttons. */\n  renderButtons() {\n    if (this.options.cyclical) {\n      return;\n    }\n    const activeElement = document.activeElement;\n    const currentPage = this.getCurrentPage();\n    const isFirstPage = currentPage === 1;\n    const isLastPage = currentPage === this.totalPages;\n    // Show/hide buttons\n    this.prevBtn.classList.toggle(CssClasses.INACTIVE, isFirstPage);\n    this.nextBtn.classList.toggle(CssClasses.INACTIVE, isLastPage);\n    // If a button was in focus and now hidden, move to other\n    if (isLastPage && activeElement === this.nextBtn) {\n      this.prevBtn.focus();\n    } else if (isFirstPage && activeElement === this.prevBtn) {\n      this.nextBtn.focus();\n    }\n  }\n  /** Builds the dot navigation. */\n  buildNavigation() {\n    var _a;\n    this.destroyNavigation();\n    // Create a dot per page\n    for (let i = 0; i < this.totalPages; i++) {\n      const dot = document.createElement('button');\n      dot.classList.add(CssClasses.NAVIGATION_DOT);\n      dot.dataset[Strings.DATA_DOT] = `${i + 1}`;\n      if (this.isTabModel) {\n        const id = (_a = this.slidesRef[i * this.slidesPerPage]) === null ||\n                _a === void 0 ?\n            void 0 :\n            _a.id;\n        dot.setAttribute(Attribute.ARIA_CONTROLS, id);\n        dot.setAttribute(Attribute.ARIA_LABELLEDBY, id);\n        dot.setAttribute(Attribute.ROLE, Role.TAB);\n      } else {\n        const template =\n            this.navigation.dataset[Strings.DATA_NAVIGATION_LABEL] ||\n            Strings.NAVIGATION_LABEL_DEFAULT;\n        const label =\n            template\n                .replace(Strings.NAVIGATION_LABEL_NUMBER_VAR_NAME, `${i + 1}`)\n                .replace(\n                    Strings.NAVIGATION_LABEL_TOTAL_VAR_NAME,\n                    `${this.totalPages}`);\n        dot.setAttribute(Attribute.ARIA_CONTROLS, this.root.id);\n        dot.setAttribute(Attribute.ARIA_LABEL, label);\n      }\n      this.navigation.appendChild(dot);\n      this.dots.push(dot);\n    }\n  }\n  /** Destroys the dot navigation. */\n  destroyNavigation() {\n    var _a;\n    while (this.dots.length) {\n      (_a = this.dots.pop()) === null || _a === void 0 ? void 0 : _a.remove();\n    }\n  }\n  /** Copies the first and last slides into the DOM (for cyclical carousels). */\n  copyDummySlides() {\n    const firstSlide = this.cloneSlide(this.slides[0]);\n    const lastSlide = this.cloneSlide(this.slides[this.slides.length - 1]);\n    this.slidesContainer.append(firstSlide);\n    this.slidesContainer.prepend(lastSlide);\n    this.slides = [lastSlide, ...this.slides, firstSlide];\n  }\n  /** Clones a slide (for first/last dummies). */\n  cloneSlide(slide) {\n    const clone = slide.cloneNode(true);\n    clone.id = `${slide.id}-copy`;\n    clone.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    clone.tabIndex = TabIndex.NOT_TABBABLE;\n    return clone;\n  }\n  /** Calculates the scroll values for each page. */\n  calcScrollValue() {\n    // Determine min/max pages (depending on dummy slides)\n    const delta = this.options.cyclical ? 1 : 0;\n    const min = 1 - delta;\n    const max = this.totalPages + delta;\n    // The direction we're moving the slide container in\n    const direction = this.isRtl ? 1 : -1;\n    this.pagesX = [];\n    for (let page = min; page <= max; page++) {\n      const pageX =\n          page < max ?  // Calculate the x position for the first slide within\n                        // that page (not using page - 1 * containerWidth as\n                        // slides may not fit exactly)\n          (page - 1 + delta) * this.slidesPerPage *\n              this.slideWidth :  // For final page, ensure end position is flush\n                                   // against container edge\n          this.slides.length * this.slideWidth - this.containerWidth;\n      this.pagesX[page] = pageX * direction;\n    }\n  }\n  registerTouchEvents() {\n    if (window.PointerEvent) {\n      // Add Pointer Event Listener\n      this.viewport.addEventListener(\n          EventType.POINTERDOWN, this.handleGestureStart, true);\n      this.viewport.addEventListener(\n          EventType.POINTERMOVE, this.handleGestureMove, true);\n      this.viewport.addEventListener(\n          EventType.POINTERUP, this.handleGestureEnd, true);\n      this.viewport.addEventListener(\n          EventType.POINTERCANCEL, this.handleGestureEnd, true);\n    } else {\n      // Add Touch Listener\n      this.viewport.addEventListener(\n          EventType.TOUCHSTART, this.handleGestureStart, true);\n      this.viewport.addEventListener(\n          EventType.TOUCHMOVE, this.handleGestureMove, true);\n      this.viewport.addEventListener(\n          EventType.TOUCHEND, this.handleGestureEnd, true);\n      this.viewport.addEventListener(\n          EventType.TOUCHCANCEL, this.handleGestureEnd, true);\n      // Add Mouse Listener\n      this.viewport.addEventListener(\n          EventType.MOUSEDOWN, this.handleGestureStart, true);\n    }\n  }\n  deregisterTouchEvents() {\n    if (window.PointerEvent) {\n      // Add Pointer Event Listener\n      this.viewport.removeEventListener(\n          EventType.POINTERDOWN, this.handleGestureStart, true);\n      this.viewport.removeEventListener(\n          EventType.POINTERMOVE, this.handleGestureMove, true);\n      this.viewport.removeEventListener(\n          EventType.POINTERUP, this.handleGestureEnd, true);\n      this.viewport.removeEventListener(\n          EventType.POINTERCANCEL, this.handleGestureEnd, true);\n    } else {\n      // Add Touch Listener\n      this.viewport.removeEventListener(\n          EventType.TOUCHSTART, this.handleGestureStart, true);\n      this.viewport.removeEventListener(\n          EventType.TOUCHMOVE, this.handleGestureMove, true);\n      this.viewport.removeEventListener(\n          EventType.TOUCHEND, this.handleGestureEnd, true);\n      this.viewport.removeEventListener(\n          EventType.TOUCHCANCEL, this.handleGestureEnd, true);\n      // Add Mouse Listener\n      this.viewport.removeEventListener(\n          EventType.MOUSEDOWN, this.handleGestureStart, true);\n    }\n  }\n  updateSwipeRestPosition() {\n    const differenceInX =\n        this.getXDistance(this.initialTouchPos, this.lastTouchPos);\n    // Let CSS transition to take charge it\n    this.slidesContainer.style.transition = '';\n    const validDrag =\n        Math.abs(differenceInX) >= this.containerWidth * Numbers.DRAG_THRESHOLD;\n    // If dragging distance is over 20% of the viewport width, transit to\n    // the next/prev page, otherwise rewind to the original position.\n    if (validDrag) {\n      if ((differenceInX > 0 && !this.isRtl) ||\n          (differenceInX < 0 && this.isRtl)) {\n        this.next();\n      }\n      if ((differenceInX < 0 && !this.isRtl) ||\n          (differenceInX > 0 && this.isRtl)) {\n        this.previous();\n      }\n    }\n    this.transit();\n  }\n  /** Calculates the x distance between 2 positions. */\n  getXDistance(startPosition, endPosition) {\n    return startPosition && endPosition ? startPosition.x - endPosition.x : 0;\n  }\n  getGesturePointFromEvent(event) {\n    const point = {x: 0, y: 0};\n    if (this.isTouchEvent(event)) {\n      if (event.targetTouches) {\n        // Prefer Touch Events\n        point.x = event.targetTouches[0].clientX;\n        point.y = event.targetTouches[0].clientY;\n      }\n    } else {\n      // Either Mouse event or Pointer Event\n      point.x = event.clientX;\n      point.y = event.clientY;\n    }\n    return point;\n  }\n  onAnimFrame() {\n    if (!this.rafPending) {\n      return;\n    }\n    const differenceInX =\n        this.getXDistance(this.initialTouchPos, this.lastTouchPos);\n    const newXTransform = this.currentXPosition - differenceInX;\n    const transformStyle = `translate3d(${newXTransform}px, 0, 0)`;\n    this.slidesContainer.style.transform = transformStyle;\n    this.rafPending = false;\n  }\n  /** Determines whether the event is a TouchEvent. */\n  isTouchEvent(event) {\n    return window.TouchEvent && event instanceof TouchEvent;\n  }\n  /** Returns the options set via data attributes. */\n  getDataAttrs() {\n    const options = {};\n    for (const option of Object.keys(Carousel.defaults)) {\n      const attr =\n          `glueCarousel${option.toUpperCase().slice(0, 1)}${option.slice(1)}`;\n      if (this.root.dataset[attr]) {\n        if (option === 'currentSlide' || option === 'cardsPerPage') {\n          const value = Number(this.root.dataset[attr]);\n          if (!isNaN(value)) options[option] = value;\n        } else {\n          options[option] = this.root.dataset[attr] === 'true';\n        }\n      }\n    }\n    return options;\n  }\n  /**\n   * Retrieves the named breakpoint currently injected in DOM.\n   */\n  getCurrentBreakpoint() {\n    const styles = window.getComputedStyle(document.body, ':after');\n    const content = styles.getPropertyValue('content');\n    const breakpoint = content.replace(/[\"']/g, '');\n    return breakpoint;\n  }\n}\n/** Clamps a number between the min and max values. */\nfunction clamp(num, min, max) {\n  return Math.max(min, Math.min(max, num));\n}\n/** Converts a CSS property value (as a pixel string) to a number. */\nfunction toNumber(propertyValue) {\n  return Number(propertyValue.replace('px', ''));\n}\n/**\n * Wraps a number between the min and max values (different to clamp as will\n * loop around).\n */\nfunction wrap(num, min, max) {\n  const range = max + 1 - min;\n  const wrapped = min + ((num - min) % range);\n  return wrapped < min ? wrapped + range : wrapped;\n}\nexport {Carousel};\n","/**\n * @fileoverview A list of Glue attributes.\n */\nvar Attribute;\n(function(Attribute) {\nAttribute['ARIA_CONTROLS'] = 'aria-controls';\nAttribute['ARIA_CURRENT'] = 'aria-current';\nAttribute['ARIA_DESCRIBEDBY'] = 'aria-describedby';\nAttribute['ARIA_EXPANDED'] = 'aria-expanded';\nAttribute['ARIA_HASPOPUP'] = 'aria-haspopup';\nAttribute['ARIA_HIDDEN'] = 'aria-hidden';\nAttribute['ARIA_LABELLEDBY'] = 'aria-labelledby';\nAttribute['ARIA_LABEL'] = 'aria-label';\nAttribute['ARIA_LIVE'] = 'aria-live';\nAttribute['ARIA_MODAL'] = 'aria-modal';\nAttribute['ARIA_SELECTED'] = 'aria-selected';\nAttribute['INERT'] = 'inert';\nAttribute['ROLE'] = 'role';\nAttribute['TAB_INDEX'] = 'tabindex';\nAttribute['TYPE'] = 'type';\n})(Attribute || (Attribute = {}));\nvar DataAttrs;\n(function(DataAttrs) {\nDataAttrs['NO_SNIPPET'] = 'nosnippet';\n})(DataAttrs || (DataAttrs = {}));\nvar Direction;\n(function(Direction) {\nDirection['LTR'] = 'ltr';\nDirection['RTL'] = 'rtl';\n})(Direction || (Direction = {}));\nvar Role;\n(function(Role) {\nRole['COMPLEMENTARY'] = 'complementary';\nRole['BUTTON'] = 'button';\nRole['DIALOG'] = 'dialog';\nRole['REGION'] = 'region';\nRole['TABPANEL'] = 'tabpanel';\nRole['TABLIST'] = 'tablist';\nRole['NAVIGATION'] = 'navigation';\nRole['TAB'] = 'tab';\nRole['MENU'] = 'menu';\nRole['MENUITEM'] = 'menuitem';\nRole['MENUBAR'] = 'menubar';\nRole['TOOLTIP'] = 'tooltip';\nRole['GRIDCELL'] = 'gridcell';\nRole['ROW'] = 'row';\nRole['PRESENTATION'] = 'presentation';\nRole['NONE'] = 'none';\n})(Role || (Role = {}));\nvar TabIndex;\n(function(TabIndex) {\nTabIndex[TabIndex['TABBABLE'] = 0] = 'TABBABLE';\nTabIndex[TabIndex['NOT_TABBABLE'] = -1] = 'NOT_TABBABLE';\n})(TabIndex || (TabIndex = {}));\nexport {Attribute, DataAttrs, Direction, Role, TabIndex};\n","/**\n * @fileoverview A list of Glue classes.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['SHOW'] = 'glue-is-shown';\nCssClasses['ACTIVE'] = 'glue-is-active';\n})(CssClasses || (CssClasses = {}));\nexport {CssClasses};\n","/**\n * @fileoverview Constants used by the Copy component.\n */\n/**\n * Classes that identify sub elements or adjust display of sub elements.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-copy';\nCssClasses['VALUE'] = 'glue-copy-value';\nCssClasses['BUTTON'] = 'glue-copy-button';\nCssClasses['IS_COPIED'] = 'glue-is-copied';\nCssClasses['POPOVER_ROOT'] = 'glue-popover';\nCssClasses['SOCIAL_POPOVER_ROOT'] = 'glue-social__popover';\n})(CssClasses || (CssClasses = {}));\n/**\n * List of demos used by demo server.\n */\nvar Demos;\n(function(Demos) {\nDemos['BASE'] = 'base';\nDemos['SOCIAL'] = 'social';\n})(Demos || (Demos = {}));\n/**\n * Data properties that identify user-provided messages.\n */\nvar Message;\n(function(Message) {\nMessage['SUCCESS'] = 'glue-copy-success';\nMessage['FAIL'] = 'glue-copy-fail';\n})(Message || (Message = {}));\n/**\n * Various strings used throughout the copy component.\n */\nvar Strings;\n(function(Strings) {\n/**\n * Error message provided if input element is not found.\n */\nStrings['MISSING_INPUT'] = 'Input element is missing';\n/**\n * Error message provided if copy button element is not found.\n */\nStrings['MISSING_COPY_BUTTON'] = 'Copy button is missing';\n/**\n * Default message shown to users after successful copy operation.\n */\nStrings['SUCCESS_MESSAGE'] = 'Copied to clipboard';\n/**\n * Default message shown to users after failed copy operation.\n */\nStrings['FAIL_MESSAGE'] = 'Press Ctrl+C or \\u2318+C to copy';\n})(Strings || (Strings = {}));\nexport {CssClasses, Demos, Message, Strings};\n","import {__awaiter} from 'tslib';\n\nimport {Component} from '../base';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\nimport {CustomEvent as PopoverEvents} from '../popover/constants';\n\nimport {CssClasses, Message, Strings} from './constants';\n\n/**\n * A class to copy text input content to clipboard.\n */\nclass Copy extends Component {\n  /** @param root root element for the Copy component. */\n  constructor(root) {\n    var _a;\n    super(root);\n    // Message to show if copy command succeeds.\n    this.successMsg = Strings.SUCCESS_MESSAGE;\n    // Message to show if copy command fails.\n    this.failMsg = Strings.FAIL_MESSAGE;\n    // Original label of the copy button.\n    this.originalLabel = '';\n    const copyValEl = this.root.querySelector(`.${CssClasses.VALUE}`);\n    const copyButtonEl = this.root.querySelector(`.${CssClasses.BUTTON}`);\n    this.popoverParentEl =\n        (_a = this.root.closest(`.${CssClasses.POPOVER_ROOT}`)) !== null &&\n            _a !== void 0 ?\n        _a :\n        this.root.closest(`.${CssClasses.SOCIAL_POPOVER_ROOT}`);\n    if (!copyValEl) {\n      throw new Error(Strings.MISSING_INPUT);\n    }\n    if (!copyButtonEl) {\n      throw new Error(Strings.MISSING_COPY_BUTTON);\n    }\n    this.copyValueEl = copyValEl;\n    this.copyButtonEl = copyButtonEl;\n    this.selection = window.getSelection();\n    this.clickHandler = (evt) => {\n      this.copy();\n      evt.preventDefault();\n    };\n    this.keyDownHandler = (evt) => {\n      if (evt.key === Key.ENTER) {\n        this.copy();\n        evt.preventDefault();\n      }\n    };\n    this.closeHandler = () => {\n      this.reset();\n    };\n    this.init();\n  }\n  /** Initializes the copy component. */\n  init() {\n    var _a;\n    const success = this.root.getAttribute(Message.SUCCESS);\n    const fail = this.root.getAttribute(Message.FAIL);\n    this.successMsg = success ? success : this.successMsg;\n    this.failMsg = fail ? fail : this.failMsg;\n    this.originalLabel =\n        this.copyButtonEl.textContent ? this.copyButtonEl.textContent : '';\n    this.copyButtonEl.addEventListener(EventType.CLICK, this.clickHandler);\n    this.copyButtonEl.addEventListener(EventType.KEYDOWN, this.keyDownHandler);\n    // Resets the copy button if its parent popover is closed\n    (_a = this.popoverParentEl) === null || _a === void 0 ?\n        void 0 :\n        _a.addEventListener(PopoverEvents.CLOSE_EVENT, this.closeHandler);\n  }\n  /**\n   * Resets component and removes all event listeners.\n   */\n  destroy() {\n    var _a;\n    this.reset();\n    this.copyButtonEl.removeEventListener(EventType.CLICK, this.clickHandler);\n    this.copyButtonEl.removeEventListener(\n        EventType.KEYDOWN, this.keyDownHandler);\n    (_a = this.popoverParentEl) === null || _a === void 0 ?\n        void 0 :\n        _a.removeEventListener(PopoverEvents.CLOSE_EVENT, this.closeHandler);\n  }\n  /** Copies text input string to clipboard. */\n  copy() {\n    return __awaiter(this, void 0, void 0, function*() {\n      var _a, _b;\n      if (this.copyValueEl && this.copyValueEl.select) {\n        this.copyValueEl.select();\n        const userAgentMatch = navigator.userAgent.match(/ipad|iphone/i);\n        if (userAgentMatch) {\n          const range = document.createRange();\n          range.selectNodeContents(this.copyValueEl);\n          (_a = this.selection) === null || _a === void 0 ?\n              void 0 :\n              _a.removeAllRanges();\n          (_b = this.selection) === null || _b === void 0 ? void 0 :\n                                                            _b.addRange(range);\n          this.copyValueEl.setSelectionRange(0, 999999);\n        }\n      }\n      yield navigator.clipboard.writeText(this.copyValueEl.value)\n          .then(\n              () => {\n                // Shows success message and updates various elements\n                this.copyButtonEl.textContent = this.successMsg;\n                this.copyButtonEl.classList.add(CssClasses.IS_COPIED);\n                this.copyButtonEl.disabled = true;\n                this.copyValueEl.blur();\n              },\n              () => {\n                // Render failure message\n                this.copyButtonEl.textContent = this.failMsg;\n              });\n      this.copyValueEl.focus();\n    });\n  }\n  /**\n   * Resets input and copy button and re-enables copy button.\n   */\n  reset() {\n    var _a;\n    this.copyButtonEl.textContent = this.originalLabel;\n    this.copyButtonEl.classList.remove(CssClasses.IS_COPIED);\n    this.copyButtonEl.disabled = false;\n    this.copyValueEl.setSelectionRange(0, 0);\n    (_a = this.selection) === null || _a === void 0 ? void 0 :\n                                                      _a.removeAllRanges();\n  }\n}\nexport {Copy};\n","/**\n * @fileoverview A simple function to create a debounced function.\n * A debounced function wraps a function, and delay its execution every time\n * the debounced function is called. This is equivalent to goog.async.Debouncer\n * but lighter and a simpler API.\n *\n * @see https://glue-docs.appspot.com/docs/components/raw/debounce\n *\n * Example:\n *\n * // Call a function 250ms after the last scroll event fires.\n * var handleScroll = function() {};\n * window.addEventListener('scroll', new Debounce(handleScroll, 250).debounce);\n *\n */\n/**\n * Debounces a function after a given delay.\n */\nclass Debounce {\n  /**\n   * @param fn The function to debounce.\n   * @param delay The delay in ms until the function should be executed.\n   */\n  constructor(fn, delay) {\n    this.fn = fn;\n    this.delay = delay;\n  }\n  /**\n   * Debounces by reinitializing the timer until the function should execute.\n   */\n  debounce() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = window.setTimeout(this.fn, this.delay);\n  }\n  /**\n   * Cancels any ongoing debouncing timer.\n   */\n  cancel() {\n    clearTimeout(this.timeoutId);\n  }\n}\nexport {Debounce};\n","/**\n * @fileoverview A series of utility functions for use in implementing easing in\n * javascript animations.\n *\n * Closure provides three easing functions (goog.fx.easing.easeIn,\n * goog.fx.easing.easeOut, goog.fx.easing.inAndOut), but as that is a woefully\n * inadequate library for broad animation use, this series of functions adds\n * many more options to be used in a similar way. Easing functions are useful\n * for adding a natural feel to what would otherwise be unrealistic, linear\n * animations.\n *\n * Example usage: Say you have a DOM element that you want to animate by moving\n * it between two arbitrary locations in a page, over 2 seconds. Normally you'd\n * determine its starting position, its ending position, set up an interval,\n * then with each iteration, determine the position you should move it to based\n * on its initial and ending position values and a percentage that represents\n * its progress from start to finish, based on the 2 second duration. Call that\n * percentage T. In order to implement an easing method using glue.fx.easing,\n * simply pass T through your desired easing method, and the returned value is\n * an \"eased\" value of T. Using that new T, you set the element's position,\n * and the resulting animation will have a smooth ease to it, instead of its\n * original, jarring linear movement. It's hard to understand this without\n * seeing it in action, so visit the example link below for some live animation\n * utilizing all of the easing functions provided in this library.\n *\n * If you are more familiar with jQuery's style of easing methods which expect\n * four arguments (t, b, c, d), you can use glue.fx.easing.ease(), passing in\n * those four arguments and a reference to the easing method you'd like to use.\n * Whether you should use this, or directly call one of the single-argument\n * methods, is up to the developer, and largely depends on circumstance.\n *\n * Note: Frequently, you will have the easing method by name in string form (as\n * when contained in some JSON configuration data), so you can also call it\n * like: glue.fx.easing[methodName](percentage);\n *\n * For examples, see:\n * https://glue-docs.appspot.com/docs/components/raw/fx-easing\n *\n * A namespace for the easing functions. This is being created and exported\n * because we will often have the name of our desired easing method by string\n * only, so we'll need to test to see if glue.fx.easing contains a property\n * (function) with that name, and then call it like so:\n * glue.fx.easing[methodName](percentage);\n */\n/**\n * Eases values based on the typical four-argument easing method structure used\n * by popular libraries like jQuery. This is an adapter to interface with the\n * single-argument easing methods in this class.\n * @param t Current time of the animation.\n * @param b Beginning value of the property to be eased.\n * @param c Total change in the property value across this animation.\n * @param d Total duration of the animation.\n * @param func The easing method to call.\n * @return The final eased value.\n */\nexport function ease(t, b, c, d, func) {\n  return b + c * func(t / d);\n}\n/**\n * Eases the value in with a Sine curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInSine(t) {\n  return t === 0 || t === 1 ? t : 1 - Math.cos(t * (Math.PI / 2));\n}\n/**\n * Eases the value out with a Sine curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutSine(t) {\n  return t === 0 || t === 1 ? t : Math.sin(t * (Math.PI / 2));\n}\n/**\n * Eases the value in and out with a Sine curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutSine(t) {\n  return t === 0 || t === 1 ? t : -0.5 * (Math.cos(Math.PI * t) - 1);\n}\n/**\n * Eases the value in with a quadratic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInQuad(t) {\n  return t === 0 || t === 1 ? t : t * t;\n}\n/**\n * Eases the value out with a quadratic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutQuad(t) {\n  return t === 0 || t === 1 ? t : t * (2 - t);\n}\n/**\n * Eases the value in and out with a quadratic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutQuad(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return 2 * t * t;\n  } else {\n    return -1 + (4 - 2 * t) * t;\n  }\n}\n/**\n * Eases the value in with a cubic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInCubic(t) {\n  return t === 0 || t === 1 ? t : t * t * t;\n}\n/**\n * Eases the value out with a cubic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutCubic(t) {\n  return t === 0 || t === 1 ? t : --t * t * t + 1;\n}\n/**\n * Eases the value in and out with a cubic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutCubic(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return 4 * t * t * t;\n  } else {\n    return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  }\n}\n/**\n * Eases the value in with a quartic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInQuart(t) {\n  return t === 0 || t === 1 ? t : t * t * t * t;\n}\n/**\n * Eases the value out with a quartic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutQuart(t) {\n  return t === 0 || t === 1 ? t : 1 - --t * t * t * t;\n}\n/**\n * Eases the value in and out with a quartic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutQuart(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return 8 * t * t * t * t;\n  } else {\n    return 1 - 8 * --t * t * t * t;\n  }\n}\n/**\n * Eases the value in with a quintic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInQuint(t) {\n  return t === 0 || t === 1 ? t : t * t * t * t * t;\n}\n/**\n * Eases the value out with a quintic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutQuint(t) {\n  return t === 0 || t === 1 ? t : 1 + --t * t * t * t * t;\n}\n/**\n * Eases the value in and out with a quintic curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutQuint(t) {\n  return t === 0 || t === 1 ? t :\n      t < 0.5               ? 16 * t * t * t * t * t :\n                              1 + 16 * --t * t * t * t * t;\n}\n/**\n * Eases the value in with an exponential curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInExpo(t) {\n  return t === 0 || t === 1 ? t : Math.pow(2, 10 * (t - 1));\n}\n/**\n * Eases the value out with an exponential curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutExpo(t) {\n  return t === 0 || t === 1 ? t : 1 - Math.pow(2, -10 * t);\n}\n/**\n * Eases the value in and out with an exponential curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutExpo(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return 0.5 * Math.pow(2, 10 * (t * 2 - 1));\n  } else {\n    return 0.5 * (2 - Math.pow(2, -10 * (t * 2 - 1)));\n  }\n}\n/**\n * Eases the value in with a circular curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInCirc(t) {\n  return t === 0 || t === 1 ? t : 1 - Math.sqrt(1 - t * t);\n}\n/**\n * Eases the value out with a circular curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutCirc(t) {\n  return t === 0 || t === 1 ? t : Math.sqrt(1 - (t - 1) * (t - 1));\n}\n/**\n * Eases the value in and out with a circular curve.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutCirc(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return -0.5 * (Math.sqrt(1 - t * t * 4) - 1);\n  } else {\n    return 0.5 * (Math.sqrt(1 - 4 * (t - 1) * (t - 1)) + 1);\n  }\n}\n/**\n * Eases the value in after bounding backwards at the beginning.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInBack(t) {\n  return t === 0 || t === 1 ? t : t * t * (2.70158 * t - 1.70158);\n}\n/**\n * Eases the value out after bounding past the end point and back.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutBack(t) {\n  return t === 0 || t === 1 ?\n      t :\n      (t - 1) * (t - 1) * (2.70158 * (t - 1) + 1.70158) + 1;\n}\n/**\n * Eases the value in and out with an initial and ending movement beyond the\n * full range.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutBack(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return 0.5 * (t * 2) * (t * 2) * (3.5949095 * (t * 2) - 2.5949095);\n  } else {\n    return (\n        0.5 *\n        ((t * 2 - 2) * (t * 2 - 2) * (3.5949095 * (t * 2 - 2) + 2.5949095) +\n         2));\n  }\n}\n/**\n * Eases the value in with an elastic springy motion.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInElastic(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else {\n    return (\n        -1 *\n        (Math.pow(2, 10 * (t - 1)) *\n         Math.sin(((t - 1.075) * (2 * Math.PI)) / 0.3)));\n  }\n}\n/**\n * Eases the value out with an elastic springy motion.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutElastic(t) {\n  return t === 0 || t === 1 ?\n      t :\n      Math.pow(2, -10 * t) * Math.sin(((t - 0.075) * (2 * Math.PI)) / 0.3) + 1;\n}\n/**\n * Eases the value in and out with an elastic springy motion.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutElastic(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return (\n        -0.5 *\n        (Math.pow(2, 10 * (t * 2 - 1)) *\n         Math.sin(((t * 2 - 1.1125) * 2 * Math.PI) / 0.45)));\n  } else {\n    return (\n        0.5 * Math.pow(2, -10 * (t * 2 - 1)) *\n            Math.sin(((t * 2 - 1.1125) * 2 * Math.PI) / 0.45) +\n        1);\n  }\n}\n/**\n * Eases the value in with a simple physics bounce.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInBounce(t) {\n  return t === 0 || t === 1 ? t : 1 - easeOutBounce(1 - t);\n}\n/**\n * Eases the value out with a simple physics bounce.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeOutBounce(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 1 / 2.75) {\n    return 7.5625 * t * t;\n  } else if (t < 2 / 2.75) {\n    return 7.5625 * (t - 1.5 / 2.75) * (t - 1.5 / 2.75) + 0.75;\n  } else if (t < 2.5 / 2.75) {\n    return 7.5625 * (t - 2.25 / 2.75) * (t - 2.25 / 2.75) + 0.9375;\n  } else {\n    return 7.5625 * (t - 2.625 / 2.75) * (t - 2.625 / 2.75) + 0.984375;\n  }\n}\n/**\n * Eases the value in and out with starting and ending bounces.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function easeInOutBounce(t) {\n  if (t === 0 || t === 1) {\n    return t;\n  } else if (t < 0.5) {\n    return easeInBounce(t * 2) * 0.5;\n  } else {\n    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n  }\n}\n/**\n * Returns the value without any easing. This is only useful if a script is\n * expecting an easing method, but one isn't needed in that instance.\n * @param t Input between 0 and 1.\n * @return Output between 0 and 1.\n */\nexport function linear(t) {\n  return t;\n}\n/**\n * A Record/Map for easing functions.\n * This is for looking up an easing function by name.\n */\nexport const easingFunctions = {\n  'easeInSine': easeInSine,\n  'easeOutSine': easeOutSine,\n  'easeInOutSine': easeInOutSine,\n  'easeInQuad': easeInQuad,\n  'easeOutQuad': easeOutQuad,\n  'easeInOutQuad': easeInOutQuad,\n  'easeInCubic': easeInCubic,\n  'easeOutCubic': easeOutCubic,\n  'easeInOutCubic': easeInOutCubic,\n  'easeInQuart': easeInQuart,\n  'easeOutQuart': easeOutQuart,\n  'easeInOutQuart': easeInOutQuart,\n  'easeInQuint': easeInQuint,\n  'easeOutQuint': easeOutQuint,\n  'easeInOutQuint': easeInOutQuint,\n  'easeInExpo': easeInExpo,\n  'easeOutExpo': easeOutExpo,\n  'easeInOutExpo': easeInOutExpo,\n  'easeInCirc': easeInCirc,\n  'easeOutCirc': easeOutCirc,\n  'easeInOutCirc': easeInOutCirc,\n  'easeInBack': easeInBack,\n  'easeOutBack': easeOutBack,\n  'easeInOutBack': easeInOutBack,\n  'easeInElastic': easeInElastic,\n  'easeOutElastic': easeOutElastic,\n  'easeInOutElastic': easeInOutElastic,\n  'easeInBounce': easeInBounce,\n  'easeOutBounce': easeOutBounce,\n  'easeInOutBounce': easeInOutBounce,\n  'linear': linear,\n};\n","/**\n * @fileoverview A lightweight implementation of the Observable pattern, with\n * a Closure-like API.\n */\nclass EventTarget {\n  constructor() {\n    this.listeners = {};\n  }\n  /**\n   * Emits an event.\n   * Note: This interface differs from the Closure dispatchEvent method. The\n   * parameters are different. See {@code goog.events.Listenable.dispatchEvent}\n   * @param eventData Additional event data.\n   */\n  dispatchEvent(evtType, eventData) {\n    const listeners = this.getListenersList(evtType);\n    let listener;\n    for (let i = 0; i < listeners.length; i++) {\n      listener = listeners[i];\n      listener(eventData);\n    }\n  }\n  /**\n   * Listens to an event, and executes a handler function when it fires.\n   */\n  listen(evtType, handler) {\n    const listeners = this.getListenersList(evtType);\n    listeners.push(handler);\n  }\n  /**\n   * Stops listening to an event.\n   */\n  unlisten(evtType, handler) {\n    const listeners = this.getListenersList(evtType);\n    for (let i = listeners.length - 1; i >= 0; i--) {\n      const h = listeners[i];\n      if (h === handler) {\n        listeners.splice(i, 1);\n      }\n    }\n  }\n  /**\n   * Returns the list of listeners for a specific event type.\n   */\n  getListenersList(evtType) {\n    if (!this.listeners[evtType]) {\n      this.listeners[evtType] = [];\n    }\n    return this.listeners[evtType];\n  }\n  /**\n   * Removes all listeners on the host component.\n   */\n  removeAllListeners() {\n    for (const evtType of Object.keys(this.listeners)) {\n      if (Object.prototype.hasOwnProperty.call(this.listeners, evtType)) {\n        this.listeners[evtType].forEach((handler) => {\n          this.unlisten(evtType, handler);\n        });\n      }\n    }\n  }\n}\nexport {EventTarget};\n","/**\n * @fileoverview Constants of event types.\n */\nvar EventType;\n(function(EventType) {\n// Mouse\nEventType['CLICK'] = 'click';\nEventType['FOCUS'] = 'focus';\nEventType['MOUSEENTER'] = 'mouseenter';\nEventType['MOUSEOVER'] = 'mouseover';\nEventType['MOUSELEAVE'] = 'mouseleave';\nEventType['MOUSEOUT'] = 'mouseout';\nEventType['MOUSEWHEEL'] = 'mousewheel';\nEventType['HOVER'] = 'hover';\nEventType['NONE'] = 'none';\nEventType['MOUSEDOWN'] = 'mousedown';\nEventType['MOUSEMOVE'] = 'mousemove';\nEventType['MOUSEUP'] = 'mouseup';\n// Keyboard\nEventType['KEYDOWN'] = 'keydown';\nEventType['KEYPRESS'] = 'keypress';\nEventType['KEYUP'] = 'keyup';\nEventType['BLUR'] = 'blur';\nEventType['LOAD'] = 'load';\nEventType['PAN'] = 'pan';\nEventType['PAN_LEFT'] = 'panleft';\nEventType['PAN_RIGHT'] = 'panright';\nEventType['PAN_END'] = 'panend';\nEventType['PAN_START'] = 'panstart';\nEventType['PAN_MOVE'] = 'panmove';\nEventType['SCROLL'] = 'scroll';\n// Element\nEventType['CHANGE'] = 'change';\nEventType['FOCUS_IN'] = 'focusin';\nEventType['FOCUS_OUT'] = 'focusout';\n// CSS Event\nEventType['TRANSITIONEND'] = 'transitionend';\nEventType['TRANSITIONSTART'] = 'transitionstart';\n// Viewport\nEventType['RESIZE'] = 'resize';\nEventType['ORIENTATION_CHANGE'] = 'orientationchange';\nEventType['DOM_CONTENT_READY'] = 'DOMContentReady';\nEventType['HASHCHANGE'] = 'hashchange';\n// Pointer\nEventType['POINTERDOWN'] = 'pointerdown';\nEventType['POINTERMOVE'] = 'pointermove';\nEventType['POINTERUP'] = 'pointerup';\nEventType['POINTERCANCEL'] = 'pointercancel';\n// Touch\nEventType['TOUCHSTART'] = 'touchstart';\nEventType['TOUCHMOVE'] = 'touchmove';\nEventType['TOUCHEND'] = 'touchend';\nEventType['TOUCHCANCEL'] = 'touchcancel';\n})(EventType || (EventType = {}));\nexport {EventType};\n","/**\n * @fileoverview Constants used when working with key events.\n */\nvar Key;\n(function(Key) {\nKey['ENTER'] = 'Enter';\nKey['SPACE'] = ' ';\nKey['TAB'] = 'Tab';\nKey['ESC'] = 'Escape';\n// These only trigger with `keydown` not `keypress` on Chrome.\nKey['LEFT'] = 'ArrowLeft';\nKey['UP'] = 'ArrowUp';\nKey['RIGHT'] = 'ArrowRight';\nKey['DOWN'] = 'ArrowDown';\nKey['HOME'] = 'Home';\nKey['END'] = 'End';\nKey['PAGEUP'] = 'PageUp';\nKey['PAGEDOWN'] = 'PageDown';\n})(Key || (Key = {}));\nvar KeyCode;\n(function(KeyCode) {\nKeyCode[KeyCode['ENTER'] = 13] = 'ENTER';\nKeyCode[KeyCode['SPACE'] = 32] = 'SPACE';\nKeyCode[KeyCode['TAB'] = 9] = 'TAB';\nKeyCode[KeyCode['ESC'] = 27] = 'ESC';\nKeyCode[KeyCode['LEFT'] = 37] = 'LEFT';\nKeyCode[KeyCode['UP'] = 38] = 'UP';\nKeyCode[KeyCode['RIGHT'] = 39] = 'RIGHT';\nKeyCode[KeyCode['DOWN'] = 40] = 'DOWN';\nKeyCode[KeyCode['HOME'] = 36] = 'HOME';\nKeyCode[KeyCode['END'] = 35] = 'END';\nKeyCode[KeyCode['PAGEUP'] = 33] = 'PAGEUP';\nKeyCode[KeyCode['PAGEDOWN'] = 34] = 'PAGEDOWN';\n})(KeyCode || (KeyCode = {}));\nexport {Key, KeyCode};\n","/**\n * @fileoverview Constants used in expansion panels components.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['GROUP'] = 'glue-expansion-panels';\nCssClasses['PANEL'] = 'glue-expansion-panel';\nCssClasses['CONTENT'] = 'glue-expansion-panel__content';\nCssClasses['TOGGLE'] = 'glue-expansion-panel__toggle';\nCssClasses['BUTTON'] = 'glue-expansion-panel__button';\nCssClasses['HEADER'] = 'glue-expansion-panels__header';\nCssClasses['HEADER_TEXT'] = 'glue-expansion-panel__header-text';\nCssClasses['TOGGLE_ALL'] = 'glue-expansion-panels__toggle-all';\nCssClasses['TOGGLE_ALL_TEXT'] = 'glue-expansion-panels__toggle-text';\nCssClasses['ARROW'] = 'glue-expansion-panel__header-arrow';\nCssClasses['IS_EXPANDED'] = 'glue-is-expanded';\nCssClasses['IS_COLLAPSED'] = 'glue-is-collapsed';\nCssClasses['IS_MIXED'] = 'glue-is-mixed';\n})(CssClasses || (CssClasses = {}));\nvar DataAttr;\n(function(DataAttr) {\nDataAttr['KEY'] = 'glueExpansionPanelsKey';\nDataAttr['SMOOTHANIMTIMING'] = 'glueExpansionPanelsSmoothAnimTiming';\nDataAttr['TOGGLEFOR'] = 'glueExpansionPanelToggleFor';\nDataAttr['INITIAL'] = 'glueExpansionPanelInitial';\nDataAttr['EXPAND_TOOLTIP'] = 'glueExpansionPanelExpandTooltip';\nDataAttr['COLLAPSE_TOOLTIP'] = 'glueExpansionPanelCollapseTooltip';\n})(DataAttr || (DataAttr = {}));\nvar Strings;\n(function(Strings) {\nStrings['DEFAULT_INSTANCE_ID'] = 'expansion_panels';\nStrings['EXPANDED'] = 'expanded';\nStrings['COLLAPSED'] = 'collapsed';\nStrings['MIXED'] = 'mixed';\nStrings['TOOLTIP_EXPAND'] = 'Press to expand';\nStrings['TOOLTIP_COLLAPSE'] = 'Press to collapse';\n})(Strings || (Strings = {}));\nvar EventNames;\n(function(EventNames) {\n// dispatched by model whenever there is a change in the group status\nEventNames['PANELGROUP_STATUS_CHANGED'] = 'glueExpansionPanelsStatusChanged';\n// dispatched by toggle to trigger content component to expand or collapse\nEventNames['TOGGLE_CONTENT'] = 'glueExpansionPanelsToggleContent';\n// dispatched to trigger all content components to expand\nEventNames['EXPAND_ALL_CONTENT'] = 'glueExpansionPanelsExpandAllContent';\n// dispatched to trigger all content components to collapse\nEventNames['COLLAPSE_ALL_CONTENT'] = 'glueExpansionPanelsCollapseAllContent';\n})(EventNames || (EventNames = {}));\nvar ErrorMessages;\n(function(ErrorMessages) {\nErrorMessages['TOGGLE_MISSING_CONTENT_ID'] =\n    '[Glue Expansion Panels Toggle] - Toggle is not linked to a content element.';\nErrorMessages['TOGGLE_MISSING_CONTENT_ELEMENT'] =\n    '[Glue Expansion Panels Toggle] - Cannot find content element to link toggle to.';\nErrorMessages['MISSING_CONTENT_ID'] =\n    '[Glue Expansion Panels Content] - An ID must be set on the content element.';\n})(ErrorMessages || (ErrorMessages = {}));\nexport {CssClasses, DataAttr, ErrorMessages, EventNames, Strings};\n","import {Component} from '../../base';\nimport {Attribute, Role, TabIndex} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport * as focusUtil from '../../focus/';\nimport {CssClasses, DataAttr, ErrorMessages, EventNames, Strings,} from '../constants';\nimport {ModelFactory} from '../model/modelfactory';\n/**\n * Class for creating expansion panels content.\n */\nclass ExpansionPanelsContent extends Component {\n  /**\n   * @param root The HTML element containing the individual panel's content.\n   */\n  constructor(root) {\n    var _a, _b, _c;\n    super(root);\n    /**\n     * An array to hold the tabindex value of focusable child elements of panel\n     * content, so it can be adjusted when the panel content is expanded or\n     * collapsed.\n     */\n    this.tabIndexArr = [];\n    this.isCollapsed = true;\n    /**\n     * Keeps track of the panel height (unitless, but ultimately in pixels).\n     */\n    this.panelHeight = 0;\n    this.groupEl = this.root.closest(`.${CssClasses.GROUP}`);\n    this.panelEl = this.root.closest(`.${CssClasses.PANEL}`);\n    this.toggleButton =\n        (_b = (_a = this.panelEl) === null || _a === void 0 ?\n             void 0 :\n             _a.querySelector(`.${CssClasses.BUTTON}`)) !== null &&\n            _b !== void 0 ?\n        _b :\n        null;\n    this.toggleContentHandler = (target) => {\n      this.toggleContent(target);\n    };\n    this.expandHandler = () => {\n      this.expand();\n    };\n    this.collapseHandler = () => {\n      this.collapse();\n    };\n    this.transitionendHandler = () => {\n      this.unsetPanelHeight();\n    };\n    const modelKey =\n        (_c = this.root.closest(`.${CssClasses.GROUP}`)) === null ||\n            _c === void 0 ?\n        void 0 :\n        _c.dataset[DataAttr.KEY];\n    this.model = ModelFactory.get(modelKey);\n    if (!this.root.id) {\n      throw new Error(ErrorMessages.MISSING_CONTENT_ID);\n    }\n    this.init();\n  }\n  init() {\n    // Store initial tabIndex value for all focusable elements in panel content.\n    this.tabIndexArr = this.getTabIndexArray();\n    // Toggle the panel's initial state\n    if (this.root.dataset[DataAttr.INITIAL] === 'expanded') {\n      this.isCollapsed = false;\n      this.updateHtmlAttributes(false);\n      this.setPanelHeight('');\n      this.updateStatus(false);\n    } else {\n      this.isCollapsed = true;\n      this.updateHtmlAttributes(true);\n      this.setPanelHeight('0px');\n    }\n    // start listening for events\n    this.model.listen(EventNames.TOGGLE_CONTENT, this.toggleContentHandler);\n    this.model.listen(EventNames.EXPAND_ALL_CONTENT, this.expandHandler);\n    this.model.listen(EventNames.COLLAPSE_ALL_CONTENT, this.collapseHandler);\n    if (this.model.isAnimated === true) {\n      this.root.addEventListener(\n          EventType.TRANSITIONEND, this.transitionendHandler);\n    }\n    // set aria properties\n    this.addA11yFeatures();\n  }\n  destroy() {\n    var _a;\n    // remove styles and attributes\n    (_a = this.panelEl) === null || _a === void 0 ?\n        void 0 :\n        _a.classList.remove(CssClasses.IS_COLLAPSED, CssClasses.IS_EXPANDED);\n    this.setPanelHeight('');\n    // reset accessibility properties from expanded/collapsed state\n    this.removeAriaAttributes();\n    this.setFocusableElements(false, this.tabIndexArr);\n    // clear tabindex values\n    this.tabIndexArr = [];\n    // stop listening for events\n    this.model.unlisten(EventNames.TOGGLE_CONTENT, this.toggleContentHandler);\n    this.model.unlisten(EventNames.EXPAND_ALL_CONTENT, this.expandHandler);\n    this.model.unlisten(EventNames.COLLAPSE_ALL_CONTENT, this.collapseHandler);\n    if (this.model.isAnimated === true) {\n      this.root.removeEventListener(\n          EventType.TRANSITIONEND, this.transitionendHandler);\n    }\n    // reset aria properties\n    this.removeA11yFeatures();\n  }\n  /**\n   * Expands (shows) the content, both visually and to screen readers\n   */\n  expand() {\n    if (this.isCollapsed === false) {\n      return;\n    }\n    this.updateHtmlAttributes(false);\n    this.updateHeight(false);\n    this.updateStatus(false);\n  }\n  /**\n   * Collapses (hides) the content, both visually and to screen readers\n   */\n  collapse() {\n    if (this.isCollapsed === true) {\n      return;\n    }\n    this.updateHtmlAttributes(true);\n    this.updateHeight(true);\n    this.updateStatus(true);\n  }\n  /**\n   * When toggle event is fired, expands or collapses the content element.\n   * @param target The ID of the panel that should be toggled.\n   */\n  toggleContent(target) {\n    if (target === this.root.id) {\n      this.isCollapsed ? this.expand() : this.collapse();\n    }\n  }\n  /**\n   * Updates content element's ARIA attributes and adds/removes classes based\n   * on context (Expanded / Collapsed).\n   * @param flag The flag to check if the state is\n   * expanded or collapsed.\n   */\n  updateHtmlAttributes(flag) {\n    var _a, _b;\n    this.setAriaAttributes(flag);\n    this.setFocusableElements(flag, this.tabIndexArr);\n    const addClass = flag ? CssClasses.IS_COLLAPSED : CssClasses.IS_EXPANDED;\n    const removeClass = flag ? CssClasses.IS_EXPANDED : CssClasses.IS_COLLAPSED;\n    (_a = this.panelEl) === null || _a === void 0 ? void 0 :\n                                                    _a.classList.add(addClass);\n    (_b = this.panelEl) === null || _b === void 0 ?\n        void 0 :\n        _b.classList.remove(removeClass);\n  }\n  /**\n   * Updates height of content element based on context (Expanded / Collapsed).\n   * @param flag The flag to check if the state is\n   * expanded or collapsed.\n   */\n  updateHeight(flag) {\n    this.panelHeight = this.root.scrollHeight;\n    if (this.model.isAnimated === true) {\n      this.setPanelHeight(`${this.panelHeight}px`);\n      // Applicable when the panels are to be collapsed.\n      if (flag) {\n        // Force a redraw of the layout by calling scrollHeight again,\n        // then set the height to 0 after a brief delay (1ms)\n        // This is so broswers will reliably transition the height change\n        this.panelHeight = this.root.scrollHeight;\n        window.setTimeout(this.setPanelHeight.bind(this), 1, '0px');\n      }\n    } else {\n      // If no animation is set, immediately set the height to\n      // 0 or unset depending on the context.\n      this.setPanelHeight(flag ? '0px' : '');\n    }\n  }\n  /**\n   * Updates status of content element based on context (Expanded / Collapsed).\n   * @param flag The flag to check if the state is\n   * expanded or collapsed.\n   */\n  updateStatus(flag) {\n    flag ? this.model.panelsCollapsed++ : this.model.panelsCollapsed--;\n    this.model.updatePanelsStatus();\n    this.isCollapsed = flag;\n  }\n  /**\n   * Get tabindex array.\n   */\n  getTabIndexArray() {\n    const focusableEls = focusUtil.getFocusableElements(this.root);\n    const tabIndexArray = focusableEls.map((el) => el.tabIndex);\n    return tabIndexArray;\n  }\n  /**\n   * Set content height.\n   */\n  setPanelHeight(height) {\n    this.root.style.height = height;\n  }\n  /**\n   * Unset content height.\n   */\n  unsetPanelHeight() {\n    if (this.root.style.height !== '0px') {\n      this.root.style.height = '';\n    }\n  }\n  /**\n   * Get localised tooltip text from the template file\n   * @param isPanelExpanded The flag to check if the panel is expanded or not\n   */\n  getTooltipText(isPanelExpanded = false) {\n    var _a, _b, _c, _d;\n    const tooltipText = isPanelExpanded ?\n        (_b = (_a = this.groupEl) === null || _a === void 0 ?\n             void 0 :\n             _a.dataset[DataAttr.EXPAND_TOOLTIP]) !== null &&\n                _b !== void 0 ?\n        _b :\n        Strings.TOOLTIP_EXPAND :\n        (_d = (_c = this.groupEl) === null || _c === void 0 ?\n             void 0 :\n             _c.dataset[DataAttr.COLLAPSE_TOOLTIP]) !== null &&\n            _d !== void 0 ?\n        _d :\n        Strings.TOOLTIP_COLLAPSE;\n    return tooltipText;\n  }\n  /**\n   * Set aria attributes.\n   */\n  setAriaAttributes(isPanelCollapsed) {\n    this.root.hidden = isPanelCollapsed;\n    if (this.toggleButton) {\n      this.toggleButton.title = this.getTooltipText(isPanelCollapsed);\n      this.toggleButton.setAttribute(\n          Attribute.ARIA_EXPANDED, String(!isPanelCollapsed));\n    }\n    if (isPanelCollapsed) {\n      this.root.setAttribute(Attribute.ARIA_HIDDEN, String(isPanelCollapsed));\n    } else {\n      this.root.removeAttribute(Attribute.ARIA_HIDDEN);\n    }\n  }\n  /**\n   * Remove aria attributes.\n   */\n  removeAriaAttributes() {\n    var _a, _b;\n    (_a = this.toggleButton) === null || _a === void 0 ?\n        void 0 :\n        _a.removeAttribute(Attribute.ARIA_EXPANDED);\n    (_b = this.toggleButton) === null || _b === void 0 ?\n        void 0 :\n        _b.removeAttribute('title');\n    this.root.removeAttribute(Attribute.ARIA_HIDDEN);\n    this.root.hidden = false;\n  }\n  /**\n   * Set focusable elements.\n   */\n  setFocusableElements(isPanelCollapsed, tabIndexArr) {\n    const focusableEls = focusUtil.getFocusableElements(this.root);\n    if (isPanelCollapsed) {\n      for (const el of focusableEls) {\n        el.tabIndex = TabIndex.NOT_TABBABLE;\n      }\n    } else {\n      for (let i = 0; i < focusableEls.length; i++) {\n        const el = focusableEls[i];\n        el.tabIndex = tabIndexArr[i];\n      }\n    }\n  }\n  /**\n   * Add a11y features.\n   */\n  addA11yFeatures() {\n    var _a, _b;\n    this.root.setAttribute(\n        Attribute.ARIA_LABELLEDBY,\n        (_b = (_a = this.toggleButton) === null || _a === void 0 ?\n             void 0 :\n             _a.id) !== null &&\n                _b !== void 0 ?\n            _b :\n            '');\n    this.root.setAttribute(Attribute.ROLE, Role.REGION);\n  }\n  /**\n   * Remove a11y features.\n   */\n  removeA11yFeatures() {\n    this.root.removeAttribute(Attribute.ARIA_LABELLEDBY);\n    this.root.removeAttribute(Attribute.ROLE);\n  }\n}\nexport {ExpansionPanelsContent};\n","import {Component} from '../base';\n\nimport {CssClasses, DataAttr, EventNames, Strings} from './constants';\nimport {ExpansionPanelsContent} from './content';\nimport {ExpansionPanelsModel} from './model';\nimport {ModelFactory} from './model/modelfactory';\nimport {ExpansionPanelsToggle} from './toggle';\nimport {ExpansionPanelsToggleAll} from './toggleall';\n\n/**\n * Class for creating expansion panels panel group.\n */\nclass ExpansionPanels extends Component {\n  /**\n   * @param root The HTML element containing the panel group.\n   * @param options Expansion Panels options object.\n   */\n  constructor(root, options) {\n    super(root);\n    this.toggleAllComponents = [];\n    this.panelContentComponents = [];\n    this.panelToggleComponents = [];\n    this.options = Object.assign({}, ExpansionPanelsModel.defaults, options);\n    this.statusChangeHandler = () => {\n      this.updateStatus();\n    };\n    this.modelKey =\n        this.root.dataset[DataAttr.KEY] || Strings.DEFAULT_INSTANCE_ID;\n    this.model = ModelFactory.get(this.modelKey, this.options);\n    this.init();\n  }\n  /**\n   * Initialize the component.\n   */\n  init() {\n    this.model.panelsCount =\n        this.root.getElementsByClassName(CssClasses.PANEL).length;\n    this.model.panelsCollapsed = this.model.panelsCount;\n    // Initialize child components. Track them so component can be fully\n    // destroyed\n    for (const toggleAllEl of this.root.querySelectorAll(\n             `.${CssClasses.TOGGLE_ALL}`)) {\n      this.toggleAllComponents.push(new ExpansionPanelsToggleAll(toggleAllEl));\n    }\n    for (const panelContentEl of this.root.querySelectorAll(\n             `.${CssClasses.CONTENT}`)) {\n      this.panelContentComponents.push(\n          new ExpansionPanelsContent(panelContentEl));\n    }\n    for (const panelToggleEl of this.root.querySelectorAll(\n             `.${CssClasses.BUTTON}`)) {\n      this.panelToggleComponents.push(new ExpansionPanelsToggle(panelToggleEl));\n    }\n    // listen for status change events\n    this.model.listen(\n        EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);\n    // Set panel group's initial status\n    this.model.updatePanelsStatus();\n  }\n  destroy() {\n    // Destroy child components\n    let subcomponent;\n    while (this.toggleAllComponents.length > 0) {\n      subcomponent = this.toggleAllComponents.pop();\n      subcomponent.destroy();\n    }\n    while (this.panelContentComponents.length > 0) {\n      subcomponent = this.panelContentComponents.pop();\n      subcomponent.destroy();\n    }\n    while (this.panelToggleComponents.length > 0) {\n      subcomponent = this.panelToggleComponents.pop();\n      subcomponent.destroy();\n    }\n    // reset panel group class\n    this.model.panelsCount = 0;\n    this.model.updatePanelsStatus();\n    // remove listener for update events\n    this.model.unlisten(\n        EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);\n    // remove instance from models list\n    ModelFactory.clearSingle(this.modelKey);\n  }\n  /**\n   * Update the class on panel group root indicating current status\n   */\n  updateStatus() {\n    this.root.classList.remove(\n        CssClasses.IS_COLLAPSED, CssClasses.IS_MIXED, CssClasses.IS_EXPANDED);\n    if (this.model.panelsStatus) {\n      this.root.classList.add(`glue-is-${this.model.panelsStatus}`);\n    }\n  }\n}\nexport {ExpansionPanels};\n","import {EventTarget} from '../../events/eventtarget';\nimport {EventNames, Strings} from '../constants';\n/**\n * The data model used for an Expansion Panel group (a collection of one or\n * more expansion panels).\n * @unrestricted\n */\nclass ExpansionPanelsModel {\n  /**\n   * @param options Expansion Panels options object.\n   */\n  constructor(options) {\n    const mergedOptions =\n        Object.assign({}, ExpansionPanelsModel.defaults, options);\n    /**\n     * Whether the panels are animated on activation or not.\n     */\n    this.isAnimated = mergedOptions.isAnimated;\n    /**\n     * Total number of panels in this group.\n     */\n    this.panelsCount = mergedOptions.panelsCount;\n    /**\n     * Number of panels currently collapsed in this group. Updated whenever a\n     * panel is expanded or collapsed.\n     * Initially same as total panel count (all panels collapsed).\n     */\n    this.panelsCollapsed = this.panelsCount;\n    /**\n     * Current status of the panels group: collapsed, expanded, or mixed.\n     * Updated whenever a panel is expanded or collapsed.\n     * Initially collapsed.\n     */\n    this.panelsStatus = Strings.COLLAPSED;\n    /**\n     * Use EventTarget module to delegate event handling between various\n     * subcomponents.\n     */\n    this.eventTarget = new EventTarget();\n  }\n  /**\n   * Default model options.\n   */\n  static get defaults() {\n    return {\n      isAnimated: true,\n      panelsCount: 1,\n    };\n  }\n  /**\n   * Updates the panel group's status based on collapsed/expanded panel count.\n   */\n  updatePanelsStatus() {\n    if (this.panelsCount === 0) {\n      this.panelsStatus = '';\n    } else if (this.panelsCount === this.panelsCollapsed) {\n      this.panelsStatus = Strings.COLLAPSED;\n    } else if (this.panelsCollapsed === 0) {\n      this.panelsStatus = Strings.EXPANDED;\n    } else {\n      this.panelsStatus = Strings.MIXED;\n    }\n    // Fire event so panel group knows to update its CSS class tracking status\n    this.dispatchEvent(EventNames.PANELGROUP_STATUS_CHANGED);\n  }\n  /**\n   * Sets up a listener on the model's eventTarget\n   */\n  listen(eventName, handler) {\n    this.eventTarget.listen(eventName, handler);\n  }\n  /**\n   * Removes a listener from the model's eventTarget\n   */\n  unlisten(eventName, handler) {\n    this.eventTarget.unlisten(eventName, handler);\n  }\n  /**\n   * Fires an event on the model's eventTarget. Can include additional data so\n   * only specific components will respond to the event.\n   * @param eventData Optional additional event data.\n   */\n  dispatchEvent(eventName, eventData) {\n    this.eventTarget.dispatchEvent(eventName, eventData);\n  }\n}\nexport {ExpansionPanelsModel};\n","/**\n * tslint:disable class-as-namespace\n */\nimport {Strings} from '../constants';\n\nimport {ExpansionPanelsModel} from './index';\n\n/**\n * Expansion Panels model factory.\n */\nclass ModelFactory {\n  /**\n   * Returns a new or existing expansion panels model instance based on an\n   * identifier.\n   * Falls back on a default instance if no id is provided.\n   */\n  static get(\n      id = Strings.DEFAULT_INSTANCE_ID,\n      options = ExpansionPanelsModel.defaults) {\n    let instance = ModelFactory.instances[id];\n    if (!instance) {\n      instance = new ExpansionPanelsModel(options);\n      ModelFactory.instances[id] = instance;\n    }\n    return instance;\n  }\n  /**\n   * Clears a single expansion panels model instance.\n   */\n  static clearSingle(id) {\n    delete ModelFactory.instances[id];\n  }\n  /**\n   * Clears all existing expansion panels model instances.\n   */\n  static clearAll() {\n    ModelFactory.instances = {};\n  }\n}\n/**\n * Internal list of all registered expansion panels model instances.\n */\nModelFactory.instances = {};\nexport {ModelFactory};\n","import {Component} from '../../base';\nimport {Attribute, Role, TabIndex} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {CssClasses, DataAttr, ErrorMessages, EventNames} from '../constants';\nimport {ModelFactory} from '../model/modelfactory';\n/**\n * Class for creating expansion panels toggle.\n */\nclass ExpansionPanelsToggle extends Component {\n  /**\n   * @param root The HTML element containing the individual panel's toggle.\n   */\n  constructor(root) {\n    var _a;\n    super(root);\n    this.clickHandler = (e) => {\n      e.preventDefault();\n      this.toggle();\n    };\n    this.keydownHandler = (e) => {\n      this.handleKeydown(e);\n    };\n    const modelKey =\n        (_a = this.root.closest(`.${CssClasses.GROUP}`)) === null ||\n            _a === void 0 ?\n        void 0 :\n        _a.dataset[DataAttr.KEY];\n    this.model = ModelFactory.get(modelKey);\n    const contentId = this.root.dataset[DataAttr.TOGGLEFOR];\n    // stop setup if toggle cannot be linked to content\n    if (!contentId) {\n      throw new Error(ErrorMessages.TOGGLE_MISSING_CONTENT_ID);\n    } else {\n      this.contentId = contentId;\n    }\n    this.init();\n  }\n  /**\n   * Initialize the component.\n   */\n  init() {\n    // stop initialization if content element is not found\n    const panelEl = this.root.closest(`.${CssClasses.PANEL}`);\n    const contentEl = panelEl === null || panelEl === void 0 ?\n        void 0 :\n        panelEl.querySelector('#' + this.contentId);\n    if (!contentEl) {\n      throw new Error(ErrorMessages.TOGGLE_MISSING_CONTENT_ELEMENT);\n    }\n    // set up accessibility features\n    this.addA11yFeatures();\n    // set up handlers\n    this.root.addEventListener(EventType.CLICK, this.clickHandler);\n    this.root.addEventListener(EventType.KEYDOWN, this.keydownHandler);\n  }\n  destroy() {\n    // remove accessibility features\n    this.removeA11yFeatures();\n    // remove handlers\n    this.root.removeEventListener(EventType.CLICK, this.clickHandler);\n    this.root.removeEventListener(EventType.KEYDOWN, this.keydownHandler);\n  }\n  /**\n   * Toggles a panel open or closed depending on its current state.\n   * Dispatches an event so the panel content targeted will expand/collapse.\n   */\n  toggle() {\n    this.model.dispatchEvent(EventNames.TOGGLE_CONTENT, this.contentId);\n  }\n  /**\n   * Triggers a toggle on the ENTER or SPACE keyboard event.\n   */\n  handleKeydown(event) {\n    if (event.key === Key.ENTER || event.key === Key.SPACE) {\n      event.preventDefault();\n      this.toggle();\n    }\n  }\n  /**\n   * Add a11y features.\n   */\n  addA11yFeatures() {\n    this.root.setAttribute(Attribute.ARIA_CONTROLS, this.contentId);\n    this.root.setAttribute(Attribute.ROLE, Role.BUTTON);\n    this.root.tabIndex = TabIndex.TABBABLE;\n  }\n  /**\n   * Remove a11y features.\n   */\n  removeA11yFeatures() {\n    this.root.removeAttribute(Attribute.ARIA_CONTROLS);\n    this.root.removeAttribute(Attribute.ROLE);\n    this.root.removeAttribute(Attribute.TAB_INDEX);\n  }\n}\nexport {ExpansionPanelsToggle};\n","import {Component} from '../../base';\nimport {Attribute} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {CssClasses, DataAttr, EventNames, Strings} from '../constants';\nimport {ModelFactory} from '../model/modelfactory';\n/**\n * Class for creating expansion panel toggle all.\n */\nclass ExpansionPanelsToggleAll extends Component {\n  /**\n   * @param root The HTML element containing the panel group's toggle all.\n   */\n  constructor(root) {\n    var _a;\n    super(root);\n    this.statusChangeHandler = () => {\n      this.updateToggleAllStatus();\n    };\n    this.clickHandler = (e) => {\n      e.preventDefault();\n      this.toggleAll();\n    };\n    this.keydownHandler = (e) => {\n      this.handleKeydown(e);\n    };\n    this.keyupHandler = (e) => {\n      this.handleKeyup(e);\n    };\n    this.model = ModelFactory.get(\n        (_a = this.root.closest(`.${CssClasses.GROUP}`)) === null ||\n                _a === void 0 ?\n            void 0 :\n            _a.dataset[DataAttr.KEY]);\n    this.init();\n  }\n  /**\n   * Initialize component.\n   */\n  init() {\n    // set up accessibility features\n    this.addA11yFeatures();\n    // set up handlers\n    this.root.addEventListener(EventType.CLICK, this.clickHandler);\n    this.root.addEventListener(EventType.KEYDOWN, this.keydownHandler);\n    this.root.addEventListener(EventType.KEYUP, this.keyupHandler);\n    // listen for status change events\n    this.model.listen(\n        EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);\n  }\n  destroy() {\n    // remove accessibility features\n    this.removeA11yFeatures();\n    // remove handlers\n    this.root.removeEventListener(EventType.CLICK, this.clickHandler);\n    this.root.removeEventListener(EventType.KEYDOWN, this.keydownHandler);\n    this.root.removeEventListener(EventType.KEYUP, this.keyupHandler);\n    // remove listener for update events\n    this.model.unlisten(\n        EventNames.PANELGROUP_STATUS_CHANGED, this.statusChangeHandler);\n  }\n  /**\n   * Toggles all the panels in the group to either expand or collapsed based\n   * on the panel group's status\n   */\n  toggleAll() {\n    if (this.model.panelsStatus === Strings.EXPANDED) {\n      // if all panels are expanded, collapse all panels\n      this.model.dispatchEvent(EventNames.COLLAPSE_ALL_CONTENT);\n    } else {\n      // if at least one panel is collapsed, expand all panels\n      this.model.dispatchEvent(EventNames.EXPAND_ALL_CONTENT);\n    }\n    // Update group status\n    this.model.updatePanelsStatus();\n  }\n  /**\n   * Triggers a toggleAll on the ENTER or SPACE keyboard event.\n   */\n  handleKeydown(event) {\n    if (event.key === Key.ENTER || event.key === Key.SPACE) {\n      event.preventDefault();\n      this.toggleAll();\n    }\n  }\n  /**\n   * Prevents Firefox from firing a click event on spacebar keyup event\n   * Fixes http://b/194148554\n   */\n  handleKeyup(event) {\n    if (event.key === Key.SPACE) {\n      event.preventDefault();\n    }\n  }\n  /**\n   * Add a11y features.\n   */\n  addA11yFeatures() {\n    this.root.setAttribute(\n        Attribute.ARIA_EXPANDED,\n        this.model.panelsStatus === Strings.EXPANDED ? 'true' : 'false');\n    const toggleText = Array.from(\n        this.root.querySelectorAll(`.${CssClasses.TOGGLE_ALL_TEXT}`));\n    for (const text of toggleText) {\n      text.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    }\n  }\n  /**\n   * Remove a11y features.\n   */\n  removeA11yFeatures() {\n    this.root.removeAttribute(Attribute.ARIA_EXPANDED);\n    const toggleText = Array.from(\n        this.root.querySelectorAll(`.${CssClasses.TOGGLE_ALL_TEXT}`));\n    for (const text of toggleText) {\n      text.removeAttribute(Attribute.ARIA_HIDDEN);\n    }\n  }\n  /**\n   * Update the aria-expanded attribute on toggle button\n   */\n  updateToggleAllStatus() {\n    if (this.model.panelsStatus === Strings.EXPANDED) {\n      this.root.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n    } else {\n      this.root.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n    }\n  }\n}\nexport {ExpansionPanelsToggleAll};\n","// taze: material_dts from //marketing/glue/cdn:material_dts\nimport {MdCheckbox} from '@material/web/checkbox/checkbox';\nimport {MdRadio} from '@material/web/radio/radio';\nimport {MdFilledSelect} from '@material/web/select/filled-select';\nimport {MdOutlinedSelect} from '@material/web/select/outlined-select';\n\nimport {Component} from '../../base';\nimport {EventType} from '../../events/eventtype';\nimport {Observer} from '../../observer';\nimport {CssClasses, MaterialClasses, Strings,} from '../constants';\nimport {FilterStateManager} from '../state_manager';\n\n/**\n * A filter category class to manage an individual Glue filter.\n */\nclass FilterCategory extends Component {\n  /**\n   * Creates an instance of GlueFilterCategory.\n   */\n  constructor(root) {\n    super(root);\n    this.chips = {};\n    this.stateManager = new FilterStateManager();\n    this.handleSelectChangeFunc = (evt) => {\n      this.handleSelectChange(evt);\n    };\n    this.handleMaterialSelectChangeFunc = (evt) => {\n      this.handleMaterialSelectChange(evt);\n    };\n    this.handleMWC3SelectChangeFunc = (evt) => {\n      this.handleMWC3SelectChange(evt);\n    };\n    this.handleInputChangeFunc = (evt) => {\n      this.handleInputChange(evt);\n    };\n    this.selectEl = this.root.querySelector('select');\n    this.nativeCategoryItems = [\n      ...this.root.querySelectorAll(`input.${CssClasses.CATEGORY_ITEM}`),\n    ];\n    this.materialCategoryItems = [\n      ...this.root.querySelectorAll(\n          `li.${CssClasses.CATEGORY_ITEM}:not(.${MaterialClasses.LIST_ITEM})`),\n    ];\n    this.materialSelectEl =\n        this.root.querySelector(`.${MaterialClasses.SELECT}`);\n    this.mwc3SelectEl =\n        this.root.querySelector(`.${MaterialClasses.MWC3_SELECT} :first-child`);\n    this.category = this.root.dataset[Strings.CATEGORY];\n    // Grab the category counter, if provided\n    this.categoryCountEl = document.querySelector(\n        `#${Strings.CATEGORY_COUNT_ID}-${this.category}`);\n    this.init();\n  }\n  init() {\n    var _a;\n    // Throws an error if filter category is not set.\n    if (!this.category) {\n      throw new Error(Strings.ERROR_MISSING_CATEGORY);\n    }\n    this.model = (_a = this.stateManager.getModel(this.category)) !== null &&\n            _a !== void 0 ?\n        _a :\n        new Observer({});\n    // Initializes select element.\n    if (this.selectEl) {\n      this.initSelect(this.selectEl);\n    }\n    // Initializes native HTML input checkbox or radio elements.\n    if (this.nativeCategoryItems.length !== 0) {\n      this.initNativeInputs(this.nativeCategoryItems);\n    }\n    // Initializes Material 2 or 3 input checkbox or radio elements.\n    if (this.materialCategoryItems.length !== 0) {\n      this.initMaterialInputs(this.materialCategoryItems);\n    }\n    // Initializes Material 2 select element.\n    if (this.materialSelectEl) {\n      this.initMaterialSelect(this.materialSelectEl);\n    }\n    // Initializes Material 3 select element.\n    if (this.mwc3SelectEl) {\n      this.initMWC3Select(this.mwc3SelectEl);\n    }\n    // Add the data model to stateManager.\n    this.stateManager.setModel(this.category, this.model);\n    // Sets initial category count\n    this.renderCategoryCounter();\n  }\n  /**\n   * Removes event listeners on filter elementss.\n   */\n  destroy() {\n    this.selectEl &&\n        this.root.removeEventListener(\n            EventType.CHANGE, this.handleSelectChangeFunc);\n    this.materialSelectEl &&\n        this.root.removeEventListener(\n            Strings.MATERIALSELECT_CHANGE, this.handleMaterialSelectChangeFunc);\n    this.mwc3SelectEl &&\n        this.root.removeEventListener(\n            EventType.CHANGE, this.handleMWC3SelectChangeFunc);\n    this.nativeCategoryItems &&\n        this.root.removeEventListener(\n            EventType.CHANGE, this.handleInputChangeFunc);\n    this.materialCategoryItems &&\n        this.root.removeEventListener(\n            EventType.CHANGE, this.handleInputChangeFunc);\n  }\n  /**\n   * Resets the data model.\n   */\n  reset() {\n    for (const key of Object.keys(this.model.data)) {\n      this.model.data[key] = false;\n    }\n    // Updates Material 2 Select rendering manually\n    if (this.materialSelect) {\n      this.materialSelect.selectedIndex = 0;\n    }\n    // Reset Material 3 Select rendering manually\n    if (this.mwc3SelectEl) {\n      this.mwc3SelectEl.value = '';\n    }\n    // Reset category counter rendering\n    this.renderCategoryCounter();\n  }\n  /** Initializes the select element. */\n  initSelect(selectEl) {\n    // Iterates all select options except the first default option.\n    const filterItems = [\n      ...selectEl.querySelectorAll(`option.${CssClasses.CATEGORY_ITEM}`),\n    ];\n    const filterElements = filterItems.slice(1);\n    for (const el of filterElements) {\n      if (el.value) {\n        const filterOption = el.value;\n        const isSelected = selectEl.value === filterOption;\n        // Updates data model and subscribes to the data change.\n        this.setModelProperty(filterOption, isSelected);\n        this.model.listen(filterOption, () => {\n          el.selected = this.model.data[filterOption];\n        });\n        // Updates chip data.\n        this.chips[filterOption] = el.innerText;\n      } else {\n        throw new Error(Strings.ERROR_MISSING_VALUE);\n      }\n    }\n    this.root.addEventListener(EventType.CHANGE, this.handleSelectChangeFunc);\n  }\n  /**\n   * Initializes the Material Select element.\n   */\n  initMaterialSelect(materialSelectEl) {\n    var _a;\n    this.materialSelect = new mdc.select.MDCSelect(materialSelectEl);\n    const initialValue =\n        ((_a = this.materialSelect) === null || _a === void 0 ? void 0 :\n                                                                _a.value) ||\n        '';\n    // Iterates all select options except the first default option.\n    const filterItems = [\n      ...materialSelectEl.querySelectorAll(`li.${MaterialClasses.LIST_ITEM}`),\n    ];\n    const filterElements = filterItems.slice(1);\n    for (const el of filterElements) {\n      const filterOption = el.dataset[Strings.DATA_VALUE];\n      const filterLabelEl =\n          el.querySelector(`.${MaterialClasses.SELECT_LABEL}`);\n      if (filterOption && filterLabelEl) {\n        const isSelected = initialValue === filterOption;\n        // Updates data model.\n        this.setModelProperty(filterOption, isSelected);\n        // Updates chips data.\n        this.chips[filterOption] = filterLabelEl.innerText;\n      }\n    }\n    this.root.addEventListener(\n        Strings.MATERIALSELECT_CHANGE, this.handleMaterialSelectChangeFunc);\n  }\n  /**\n   * Initializes the MWC3 Select element.\n   */\n  initMWC3Select(mwc3SelectEl) {\n    // Iterates all select options\n    const filterElements = [\n      ...mwc3SelectEl.querySelectorAll(`md-select-option`),\n    ];\n    for (const el of filterElements) {\n      if (el.value) {\n        // Updates data model.\n        this.setModelProperty(el.value, el.selected);\n        // Updates chips data. Use display text if provided or text content\n        this.chips[el.value] =\n            el.displayText ? el.displayText : el.innerText.trim();\n      }\n    }\n    this.root.addEventListener(\n        EventType.CHANGE, this.handleMWC3SelectChangeFunc);\n  }\n  /**\n   * Initializes native HTML input checkbox or radio elements.\n   */\n  initNativeInputs(nativeCategoryItems) {\n    var _a, _b;\n    // Iterates all checkbox or radio elements to update data object, and\n    // throws an error if attribute 'value' is not set on the element.\n    for (const el of nativeCategoryItems) {\n      const filterOption = el.value;\n      if (filterOption) {\n        const isSelected = el.checked;\n        // Updates data model and subscribes to the data change.\n        this.setModelProperty(filterOption, isSelected);\n        this.model.listen(filterOption, () => {\n          el.checked = this.model.data[filterOption];\n        });\n        // Updates chip data.\n        this.chips[filterOption] =\n            ((_b = (_a = el.parentNode) === null || _a === void 0 ?\n                  void 0 :\n                  _a.querySelector('label')) === null ||\n                     _b === void 0 ?\n                 void 0 :\n                 _b.innerText) ||\n            '';\n      } else {\n        throw new Error(Strings.ERROR_MISSING_VALUE);\n      }\n    }\n    this.root.addEventListener(EventType.CHANGE, this.handleInputChangeFunc);\n  }\n  /**\n   * Initializes Material input checkbox or radio elements.\n   */\n  initMaterialInputs(materialCategoryItems) {\n    // Iterates all checkbox or radio elements to update data object, and\n    // throws an error if attribute 'value' is not set on the element.\n    for (const el of materialCategoryItems) {\n      // Initialize Material elements\n      const materialFormFieldEl =\n          el.querySelector(`.${MaterialClasses.FORM_FIELD}`);\n      if (materialFormFieldEl) {\n        // Initialize Material 2 components\n        // TODO: b/323929145 - Remove this as part of Material 2 removal.\n        const materialFormField =\n            new mdc.formField.MDCFormField(materialFormFieldEl);\n        const materialInput = materialFormFieldEl.children[0];\n        if (materialInput.classList.contains('mdc-checkbox')) {\n          const materialCheckbox = new mdc.checkbox.MDCCheckbox(materialInput);\n          materialFormField.input = materialCheckbox;\n        } else if (materialInput.classList.contains('mdc-radio')) {\n          const materialRadio = new mdc.radio.MDCRadio(materialInput);\n          materialFormField.input = materialRadio;\n        } else {\n          throw new Error(Strings.ERROR_MISSING_MATERIAL);\n        }\n        // Set up filter\n        const inputEl = el.querySelector('input');\n        const labelEl = el.querySelector('label');\n        if (inputEl) {\n          const filterOption = inputEl.value;\n          const isSelected = inputEl.checked;\n          if (filterOption) {\n            // Updates data model and subscribes to the data change.\n            this.setModelProperty(filterOption, isSelected);\n            this.model.listen(filterOption, () => {\n              inputEl.checked = this.model.data[filterOption];\n            });\n            // Updates chip data.\n            this.chips[filterOption] =\n                (labelEl === null || labelEl === void 0 ? void 0 :\n                                                          labelEl.innerText) ||\n                '';\n          } else {\n            throw new Error(Strings.ERROR_MISSING_VALUE);\n          }\n        }\n      } else {\n        // Set up Material 3 inputs\n        const labelEl = el.querySelector('label');\n        const checkboxEl = el.querySelector('md-checkbox');\n        const radioEl = el.querySelector('md-radio');\n        let chipText = '';\n        if (labelEl && labelEl.textContent) {\n          chipText = labelEl.textContent.trim();\n        }\n        if (checkboxEl) {\n          const filterOption = checkboxEl.value;\n          const isSelected = checkboxEl.checked;\n          if (filterOption) {\n            // Updates data model and subscribes to the data change.\n            this.setModelProperty(filterOption, isSelected);\n            this.model.listen(filterOption, () => {\n              checkboxEl.checked = this.model.data[filterOption];\n            });\n            // Updates chip data.\n            this.chips[filterOption] = chipText;\n          } else {\n            throw new Error(Strings.ERROR_MISSING_VALUE);\n          }\n        } else if (radioEl) {\n          const filterOption = radioEl.value;\n          const isSelected = radioEl.checked;\n          if (filterOption) {\n            // Updates data model and subscribes to the data change.\n            this.setModelProperty(filterOption, isSelected);\n            this.model.listen(filterOption, () => {\n              radioEl.checked = this.model.data[filterOption];\n            });\n            // Updates chip data.\n            this.chips[filterOption] = chipText;\n          } else {\n            throw new Error(Strings.ERROR_MISSING_VALUE);\n          }\n        } else {\n          throw new Error(Strings.ERROR_MISSING_MATERIAL);\n        }\n      }\n    }\n    this.root.addEventListener(EventType.CHANGE, this.handleInputChangeFunc);\n  }\n  /**\n   * Handles the select element when it changes using single-select parameters.\n   * @param evt Change event.\n   */\n  handleSelectChange(evt) {\n    for (const key of Object.keys(this.model.data)) {\n      // reset all select options to false (single select)\n      this.setModelProperty(key, false);\n    }\n    if (evt.target instanceof HTMLSelectElement && evt.target.value) {\n      // set only the current option as true in the data model\n      this.setModelProperty(evt.target.value, true);\n    }\n  }\n  /**\n   * Handles the Material Select element when it changes by updating the data\n   * model and the Material Select element.\n   * @param evt Change event from MDCSelect.\n   */\n  handleMaterialSelectChange(evt) {\n    const el = evt.target;\n    // As a custom event, includes information on the value being changed to\n    const filterOption = evt.detail.value;\n    if (this.materialSelect && el instanceof HTMLDivElement &&\n        el.classList.contains(MaterialClasses.SELECT)) {\n      // reset all select options to false (single select)\n      for (const key of Object.keys(this.model.data)) {\n        this.setModelProperty(key, false);\n      }\n      // set only the current option as true in the data model\n      if (filterOption) {\n        this.setModelProperty(filterOption, true);\n      }\n    }\n  }\n  /**\n   * Handles the MWC3 Select element when it changes by updating the data\n   * model and the Material Select element.\n   * @param evt Change event from md-select.\n   */\n  handleMWC3SelectChange(evt) {\n    const el = evt.target;\n    if (el instanceof MdOutlinedSelect || el instanceof MdFilledSelect) {\n      // reset all select options to false (single select)\n      for (const key of Object.keys(this.model.data)) {\n        this.setModelProperty(key, false);\n      }\n      // set currently selected value to true\n      if (el.value) {\n        this.setModelProperty(el.value, true);\n      }\n    }\n  }\n  /**\n   * Handles native HTML or Material input checkbox or radio elements on change.\n   * @param evt Change event.\n   */\n  handleInputChange(evt) {\n    const el = evt.target;\n    if (el instanceof HTMLInputElement || el instanceof MdRadio ||\n        el instanceof MdCheckbox) {\n      if ((el instanceof HTMLInputElement && el.type === 'radio') ||\n          el instanceof MdRadio) {\n        if (el.checked) {\n          // Reset all other radio options and then re-check the radio\n          for (const key of Object.keys(this.model.data)) {\n            this.setModelProperty(key, false);\n          }\n          el.checked = true;\n        }\n      }\n      // Update the filter item's value in the model\n      const filterOption = el.value;\n      this.setModelProperty(filterOption, el.checked);\n    }\n    // Update the category counter\n    this.renderCategoryCounter();\n  }\n  /**\n   * Updates the filter item's value in the data model if it already exists, or\n   * adds it to the model.\n   * @param key The filter item's name\n   * @param value Whether the filter item is active or inactive\n   */\n  setModelProperty(key, value) {\n    this.model.data[key] !== undefined ?\n        (this.model.data[key] = value) :\n        this.model.defineReactive(this.model.data, key, value);\n    this.emit(Strings.UPDATE_STATUS, {}, true);\n  }\n  /**\n   * Renders the count of active filters into the counter element if it exists.\n   * TODO(b/373719612): Optimize later by storing count in data model and\n   * re-rendering whenever model is changed\n   */\n  renderCategoryCounter() {\n    if (this.categoryCountEl) {\n      let activeCategories = 0;\n      // Count active categories\n      for (const key of Object.keys(this.model.data)) {\n        if (this.model.data[key] === true) {\n          activeCategories++;\n        }\n      }\n      // Removes all child nodes\n      while (this.categoryCountEl.firstChild) {\n        this.categoryCountEl.removeChild(this.categoryCountEl.firstChild);\n      }\n      // Sets the new count\n      let numEl;\n      if (activeCategories) {\n        numEl = document.createTextNode(activeCategories.toString());\n      } else {\n        // if no categories are active, show total category count\n        numEl = document.createTextNode(\n            Object.keys(this.model.data).length.toString());\n      }\n      this.categoryCountEl.appendChild(numEl);\n    }\n  }\n}\nexport {FilterCategory};\n","import {Component} from '../../base';\nimport {Attribute, Role, TabIndex} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {CssClasses, Strings} from '../constants';\nimport {FilterStateManager} from '../state_manager';\n/**\n * A class to manage Filter Chips subcomponent.\n */\nclass FilterChips extends Component {\n  constructor(root, data) {\n    super(root);\n    this.data = data;\n    this.chipArr = [];\n    this.stateManager = new FilterStateManager();\n    this.isRtl = document.documentElement.dir === Strings.RTL;\n    /**\n     * Handles key press events on the root container to navigate between chips\n     */\n    this.handleRootKeydown = (evt) => {\n      if (evt.code === Key.LEFT || evt.code === Key.RIGHT ||\n          evt.code === Key.HOME || evt.code === Key.END) {\n        const isLeft = evt.code === Key.LEFT;\n        const isRight = evt.code === Key.RIGHT;\n        if (isLeft || isRight) {\n          // Move to previous or next chip based on language direction\n          const isNext = this.isRtl ? isLeft : isRight;\n          if (isNext) {\n            this.focusedChip++;\n          } else {\n            this.focusedChip--;\n          }\n        } else if (evt.code === Key.HOME) {\n          // Move to first chip\n          this.focusedChip = 0;\n        } else if (evt.code === Key.END) {\n          // Move to last chip\n          this.focusedChip = this.chipArr.length - 1;\n        }\n        // Keep chip position within bounds of chipArr\n        if (this.focusedChip < 0) {\n          this.focusedChip = 0;\n        } else if (this.focusedChip >= this.chipArr.length) {\n          this.focusedChip = this.chipArr.length - 1;\n        }\n        this.chipArr[this.focusedChip].focus();\n        evt.stopPropagation();\n        evt.preventDefault();\n      }\n    };\n    /**\n     * Handles clicks on filter chips.\n     */\n    this.handleChipClick = (evt) => {\n      let chipEl;\n      const element = evt.target;\n      if (element instanceof HTMLElement) {\n        // Find the chip element.\n        element.classList.contains(CssClasses.CHIP) ?\n            (chipEl = element) :\n            (chipEl = element.closest(`.${CssClasses.CHIP}`));\n        if (chipEl) {\n          this.updateChip(chipEl);\n        }\n      }\n    };\n    /**\n     * Handles keyboard events on filter chips.\n     */\n    this.handleChipKeydown = (evt) => {\n      let chipEl;\n      const element = evt.target;\n      if (element instanceof HTMLElement &&\n          (evt.code === Key.ENTER || evt.code === Key.SPACE)) {\n        // Find the chip element.\n        element.classList.contains(CssClasses.CHIP) ?\n            (chipEl = element) :\n            (chipEl = element.closest(`.${CssClasses.CHIP}`));\n        if (chipEl) {\n          this.updateChip(chipEl);\n        }\n        evt.stopPropagation();\n        evt.preventDefault();\n      }\n    };\n    this.isPrimary = root.classList.contains(CssClasses.CHIPS_PRIMARY);\n    this.addFilterLabel = root.dataset[Strings.CHIPS_LABEL_ADD] ?\n        root.dataset[Strings.CHIPS_LABEL_ADD] :\n        Strings.ADD_FILTER;\n    this.removeFilterLabel = root.dataset[Strings.CHIPS_LABEL_REMOVE] ?\n        root.dataset[Strings.CHIPS_LABEL_REMOVE] :\n        Strings.REMOVE_FILTER;\n    // Set initial focused chip as out of bounds, so when you hit left or right\n    // the first time you tab into the element, you focus on the first chip\n    this.focusedChip = -1;\n    this.init();\n  }\n  /**\n   * Initializes the chips component.\n   */\n  init() {\n    this.root.tabIndex =\n        this.isPrimary ? TabIndex.TABBABLE : TabIndex.NOT_TABBABLE;\n    const rowEl = document.createElement('div');\n    rowEl.setAttribute(Attribute.ROLE, Role.ROW);\n    for (const filterCategory of Object.keys(this.data)) {\n      const model = this.stateManager.getModel(filterCategory);\n      for (const filterCategoryItem of Object.keys(this.data[filterCategory])) {\n        if (this.isPrimary) {\n          // Primary chips container should render and display all chips\n          const chipEl = this.createChip(filterCategory, filterCategoryItem);\n          rowEl.appendChild(chipEl);\n          const chipButton = chipEl.firstElementChild;\n          chipButton.addEventListener(EventType.CLICK, this.handleChipClick);\n          chipButton.addEventListener(\n              EventType.KEYDOWN, this.handleChipKeydown);\n          this.chipArr.push(chipButton);\n        }\n        // Subscribes to the filter changes.\n        model === null || model === void 0 ?\n            void 0 :\n            model.listen(filterCategoryItem, () => {\n              this.render(\n                  filterCategory, filterCategoryItem,\n                  model.data[filterCategoryItem]);\n            });\n      }\n    }\n    if (this.isPrimary) {\n      // Append the chips bar\n      this.root.appendChild(rowEl);\n    }\n    this.root.addEventListener(EventType.KEYDOWN, this.handleRootKeydown);\n  }\n  /**\n   * Creates a chip element and returns it.\n   */\n  createChip(filterCategory, filterCategoryItem) {\n    const chipContainerEl = document.createElement('span');\n    chipContainerEl.setAttribute(Attribute.ROLE, Role.GRIDCELL);\n    const chipEl = document.createElement('button');\n    chipEl.classList.add(CssClasses.CHIP);\n    chipEl.tabIndex = TabIndex.NOT_TABBABLE;\n    chipEl.setAttribute(Attribute.TYPE, Role.BUTTON);\n    chipEl.dataset[Strings.CATEGORY] = filterCategory;\n    chipEl.dataset[Strings.CATEGORY_ITEM] = filterCategoryItem;\n    const chipTextNode =\n        document.createTextNode(this.data[filterCategory][filterCategoryItem]);\n    chipEl.setAttribute(\n        Attribute.ARIA_LABEL,\n        `${this.addFilterLabel} ${chipTextNode.textContent}`);\n    chipEl.append(chipTextNode);\n    if (this.isPrimary) {\n      // Primary chips have a checkmark icon before the text content\n      const checkmarkIcon = this.createCheckmarkIcon();\n      chipEl.prepend(checkmarkIcon);\n    } else {\n      // Secondary chips have a close icon after the text content\n      const closeButton = this.createCloseIconDiv();\n      chipEl.append(closeButton);\n    }\n    chipContainerEl.appendChild(chipEl);\n    return chipContainerEl;\n  }\n  /**\n   * Changes the rendering of a specific chip and the container based on filter\n   * status\n   */\n  render(category, categoryItem, isActive) {\n    // Find the chip related to this filter, if it exists\n    const chipEl = this.root.querySelector(`[data-glue-filter-category='${\n        category}'][data-glue-filter-category-item='${categoryItem}']`);\n    if (this.isPrimary) {\n      // Primary chips are always visible; adjust their classes and labels\n      if (chipEl) {\n        chipEl.classList.toggle(CssClasses.CHIP_ISACTIVE, isActive);\n        const ariaLabel =\n            isActive ? `${this.removeFilterLabel}` : `${this.addFilterLabel}`;\n        chipEl.setAttribute(\n            Attribute.ARIA_LABEL, `${ariaLabel} ${chipEl.textContent}`);\n      }\n    } else {\n      // If not primary chips, chip needs to be either added or removed to DOM\n      // First find the row parent for chips bar, or create one if it doesn't\n      // exists\n      let rowEl = this.root.querySelector(`[role='${Role.ROW}']`);\n      if (!rowEl) {\n        rowEl = document.createElement('div');\n        rowEl.setAttribute(Attribute.ROLE, Role.ROW);\n        this.root.appendChild(rowEl);\n      }\n      if (chipEl && !isActive) {\n        // If chip is already in the DOM, and filter is inactive, remove it.\n        // unassign handlers\n        chipEl.removeEventListener(EventType.CLICK, this.handleChipClick);\n        chipEl.removeEventListener(EventType.KEYDOWN, this.handleChipKeydown);\n        const cellEl = chipEl.parentElement;\n        // remove element from the row\n        rowEl.removeChild(cellEl);\n        // remove it from chipArr\n        const chipIndex = this.chipArr.indexOf(chipEl);\n        this.chipArr.splice(chipIndex, 1);\n        if (this.chipArr.length === 0) {\n          // if row is now empty, remove it\n          this.root.removeChild(rowEl);\n        }\n      } else if (isActive) {\n        // If chip is not already in the DOM, and filter is active, add it.\n        // Add DOM to the row parent\n        const newChipEl = this.createChip(category, categoryItem);\n        rowEl.appendChild(newChipEl);\n        const chipButton = newChipEl.firstElementChild;\n        if (chipButton instanceof HTMLElement) {\n          // Add event handlers\n          chipButton.addEventListener(EventType.CLICK, this.handleChipClick);\n          chipButton.addEventListener(\n              EventType.KEYDOWN, this.handleChipKeydown);\n          // Set classes and labels\n          chipButton.classList.add(CssClasses.CHIP_ISACTIVE);\n          chipButton.setAttribute(\n              Attribute.ARIA_LABEL,\n              `${this.removeFilterLabel} ${chipButton.textContent}`);\n          // Updates chips array.\n          this.chipArr.push(chipButton);\n        }\n      }\n      // If there is at least 1 chip (row exists), make the container tabbable.\n      rowEl = this.root.querySelector(`[role='${Role.ROW}']`);\n      this.root.tabIndex = rowEl ? TabIndex.TABBABLE : TabIndex.NOT_TABBABLE;\n      if (!rowEl) {\n        // Reset focused chip if no chips are visible.\n        this.focusedChip = -1;\n      }\n    }\n  }\n  /**\n   * Creates and returns an SVG checkmark icon\n   */\n  createCheckmarkIcon() {\n    const checkmarkIcon =\n        document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    checkmarkIcon.setAttribute('viewBox', '-2 -3 30 30');\n    checkmarkIcon.setAttribute(Attribute.ROLE, Role.PRESENTATION);\n    checkmarkIcon.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    checkmarkIcon.classList.add(CssClasses.CHIP_CHECKMARK, 'glue-icon');\n    const checkmarkPath =\n        document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    checkmarkPath.setAttribute('d', 'M1.73,12.91 8.1,19.28 22.79,4.59');\n    checkmarkIcon.appendChild(checkmarkPath);\n    return checkmarkIcon;\n  }\n  /**\n   * Creates and returns a div with the close icon styles applied\n   */\n  createCloseIconDiv() {\n    const closeButton = document.createElement('div');\n    closeButton.classList.add(CssClasses.CHIP_CLOSEBTN);\n    return closeButton;\n  }\n  /**\n   * Updates the status of the current chip\n   */\n  updateChip(chipEl) {\n    var _a;\n    const filterCategory = chipEl.dataset[Strings.CATEGORY];\n    const filterCategoryItem = chipEl.dataset[Strings.CATEGORY_ITEM];\n    const isActive = chipEl.classList.contains(CssClasses.CHIP_ISACTIVE);\n    // Store chip's position in chipArr\n    this.focusedChip = this.chipArr.indexOf(chipEl);\n    if (filterCategory && filterCategoryItem) {\n      const model = this.stateManager.getModel(filterCategory);\n      if (model) {\n        model.data[filterCategoryItem] = !isActive;\n        this.emit(Strings.UPDATE_STATUS, {}, true);\n        // Adjusts focused (secondary) chip by finding nearest chip\n        if (!this.isPrimary && !model.data[filterCategoryItem]) {\n          if (this.chipArr.length === 0) {\n            // if array is completely empty, no chip is focusable.\n            this.focusedChip = -1;\n          } else {\n            // move index back 1 position since chip was removed from array\n            this.focusedChip--;\n            if (this.focusedChip < 0) {\n              // If we moved before start of array, return there\n              this.focusedChip = 0;\n            } else if (this.focusedChip >= this.chipArr.length) {\n              // If we are beyond the end of the array, return there\n              this.focusedChip = this.chipArr.length - 1;\n            }\n          }\n        }\n        (_a = this.chipArr[this.focusedChip]) === null || _a === void 0 ?\n            void 0 :\n            _a.focus();\n      }\n    }\n  }\n  /**\n   * Destroys the chips component: removes event handlers and resets container.\n   */\n  destroy() {\n    this.root.tabIndex = TabIndex.NOT_TABBABLE;\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleRootKeydown);\n    this.chipArr.forEach((el) => {\n      el.removeEventListener(EventType.CLICK, this.handleChipClick);\n      el.removeEventListener(EventType.KEYDOWN, this.handleChipKeydown);\n    });\n    const chipsRowEl = this.root.querySelector('div[role=row]');\n    if (chipsRowEl) {\n      this.root.removeChild(chipsRowEl);\n    }\n  }\n}\nexport {FilterChips};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-filter';\nCssClasses['ROOT_MWS'] = 'glue-filter--mws';\nCssClasses['APPLY_FILTERS'] = 'glue-filter__apply-filters';\nCssClasses['CATEGORIES'] = 'glue-filter__categories';\nCssClasses['CATEGORY'] = 'glue-filter__category';\nCssClasses['CATEGORY_COUNT'] = 'glue-filter__category-count';\nCssClasses['CATEGORY_ITEM'] = 'glue-filter__category-item';\nCssClasses['CHIP'] = 'glue-filter__chip';\nCssClasses['CHIP_ISACTIVE'] = 'glue-filter__chip--is-active';\nCssClasses['CHIP_CHECKMARK'] = 'glue-filter__chip-checkmark';\nCssClasses['CHIP_CLOSEBTN'] = 'glue-filter__chip-close-btn';\nCssClasses['CHIPS'] = 'glue-filter__chips';\nCssClasses['CHIPS_BAR'] = 'glue-filter__chips-bar';\nCssClasses['CHIPS_HEADER'] = 'glue-filter__chips-header';\nCssClasses['CHIPS_PRIMARY'] = 'glue-filter__chips--primary';\nCssClasses['CONTROLS'] = 'glue-filter__filter-controls';\nCssClasses['EXPANSIONPANELS'] = 'glue-filter__panels';\nCssClasses['MODAL'] = 'glue-filter__modal';\nCssClasses['MODAL_CONTENT'] = 'glue-filter__modal-content';\nCssClasses['MODAL_CONTROLS'] = 'glue-filter__modal-controls';\nCssClasses['MODAL_TOGGLE'] = 'glue-filter__modal-toggle';\nCssClasses['MODAL_VIEWRESULTS'] = 'glue-filter__view-results';\nCssClasses['RESET_ALL'] = 'glue-filter__reset-all';\nCssClasses['RESET_ALL_FILTERED'] = 'glue-filter__reset-all--filtered';\nCssClasses['RESULT'] = 'glue-filter__result';\nCssClasses['RESULT_IS_MATCHING'] = 'glue-filter__result--is-matching';\nCssClasses['RESULTS'] = 'glue-filter__results';\nCssClasses['RESULTS_COUNT'] = 'glue-filter__results-count';\nCssClasses['RESULTS_STATUS'] = 'glue-filter__results-status';\nCssClasses['SHOW_RESULTS'] = 'glue-filter__show-results';\nCssClasses['TITLE'] = 'glue-filter__filter-title';\n})(CssClasses || (CssClasses = {}));\nvar MaterialClasses;\n(function(MaterialClasses) {\nMaterialClasses['CHECKBOX'] = 'mdc-checkbox__native-control';\nMaterialClasses['RADIO'] = 'mdc-radio__native-control';\nMaterialClasses['LIST_ITEM'] = 'mdc-list-item';\nMaterialClasses['FORM_FIELD'] = 'mdc-form-field';\nMaterialClasses['LABEL'] = 'mdc-floating-label';\nMaterialClasses['SELECT'] = 'mdc-select';\nMaterialClasses['SELECT_LABEL'] = 'mdc-list-item__text';\nMaterialClasses['MWC3_CHECKBOX'] = 'glue-mwc3-checkbox';\nMaterialClasses['MWC3_RADIO'] = 'glue-mwc3-radio';\nMaterialClasses['MWC3_SELECT'] = 'glue-mwc3-select';\n})(MaterialClasses || (MaterialClasses = {}));\nvar Strings;\n(function(Strings) {\n// data parameters\nStrings['CATEGORIES'] = 'glueFilterCategories';\nStrings['CATEGORY'] = 'glueFilterCategory';\nStrings['CATEGORY_ITEM'] = 'glueFilterCategoryItem';\nStrings['CHIPS_LABEL_ADD'] = 'glueFilterChipsLabelAdd';\nStrings['CHIPS_LABEL_REMOVE'] = 'glueFilterChipsLabelRemove';\nStrings['CHIPS_LABEL_RESET'] = 'glueFilterChipsLabelReset';\nStrings['RESULT_MATCH'] = 'glueFilterResultMatch';\nStrings['DATA_VALUE'] = 'value';\nStrings['STRATEGY'] = 'glueFilterStrategy';\nStrings['PREFIX'] = 'data-glue-filter-';\n// Layout\nStrings['RTL'] = 'rtl';\n// Events\nStrings['UPDATE_STATUS'] = 'gluefilterupdatestatus';\nStrings['MATERIALSELECT_CHANGE'] = 'MDCSelect:change';\n// Defaults\nStrings['CLEAR_FILTERS'] = 'Clear filters';\nStrings['ADD_FILTER'] = 'Add filter';\nStrings['REMOVE_FILTER'] = 'Remove filter';\nStrings['RESULTS_COUNT'] = '[COUNT] results';\nStrings['MODAL_TOGGLE_TEXT'] = 'Filter';\nStrings['MODAL_CLOSE_TEXT'] = 'Close filter modal';\nStrings['MODAL_RESULTS_COUNT'] = 'Show [COUNT] results';\nStrings['PANELS_COLLAPSE_LABEL'] = 'Collapse this filter category';\nStrings['PANELS_EXPAND_LABEL'] = 'Expand this filter category';\nStrings['APPLIED_FILTERS'] = 'Applied filters';\n// Error messages\nStrings['ERROR_MISSING_CATEGORY'] =\n    'Filter category is not set on the element.';\nStrings['ERROR_MISSING_MATERIAL'] =\n    'Material input was not found on this element';\nStrings['ERROR_MISSING_VALUE'] = 'Attribute \"value\" is not set on the element.';\n// Layout types\nStrings['LAYOUT_VERTICAL'] = 'vertical';\nStrings['LAYOUT_HORIZONTAL_DROPDOWN'] = 'horizontal-dropdown';\nStrings['LAYOUT_HORIZONTAL_CHIPS'] = 'horizontal-chips';\n// ID generators\nStrings['CATEGORY_COUNT_ID'] = 'glue-filter-category-count';\n})(Strings || (Strings = {}));\nexport {CssClasses, MaterialClasses, Strings};\n","import {Component} from '../base';\nimport {EventType} from '../events/eventtype';\nimport {ExpansionPanels} from '../expansionpanels';\nimport {Modal} from '../modal';\nimport {ResponsiveMonitor} from '../responsivemonitor';\n\nimport {FilterCategory} from './category';\nimport {FilterChips} from './chip';\nimport {CssClasses, Strings} from './constants';\nimport {FilterResult} from './result';\nimport {FilterStateManager} from './state_manager';\n\n/** A class to filter a list of content. */\nclass Filter extends Component {\n  /** Creates an instance of GlueFilter. */\n  constructor(root) {\n    super(root);\n    /** A collection of filter categories. */\n    this.categories = [];\n    this.handleReset = () => {\n      this.reset();\n    };\n    this.handleUpdateResetButton = () => {\n      this.updateResetButton();\n    };\n    this.handleOpenModal = () => {\n      var _a;\n      (_a = this.modal) === null || _a === void 0 ? void 0 : _a.open();\n    };\n    this.handleCloseModal = () => {\n      var _a;\n      (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();\n    };\n    this.resetAllEls = [\n      ...this.root.querySelectorAll(`.${CssClasses.RESET_ALL}`),\n    ];\n    // Grab subcomponent elements\n    this.modalEl = this.root.querySelector(`.${CssClasses.MODAL}`);\n    this.modalToggleEl = this.root.querySelector(`.${CssClasses.MODAL_TOGGLE}`);\n    this.modalCloseEl = this.root.querySelector(`.${CssClasses.SHOW_RESULTS}`);\n    this.expansionPanelsEl =\n        this.root.querySelector(`.${CssClasses.EXPANSIONPANELS}`);\n    this.init();\n  }\n  /** Initializes subfeatures of the filter component. */\n  init() {\n    this.initCategories();\n    this.initResults();\n    this.initChips();\n    this.initPanels();\n    this.initResponsiveModal();\n    this.initResetAll();\n  }\n  /** Initializes filter category elements. */\n  initCategories() {\n    const filters = [\n      ...this.root.querySelectorAll(`.${CssClasses.CATEGORY}`),\n    ];\n    if (!filters.length) {\n      throw new Error('There are no filter category elements found.');\n    }\n    for (const el of filters) {\n      const filterCategory = new FilterCategory(el);\n      this.categories.push(filterCategory);\n    }\n  }\n  /** Initializes results container element. */\n  initResults() {\n    const resultsEl = this.root.querySelector(`.${CssClasses.RESULTS}`);\n    if (!resultsEl) {\n      throw new Error('There is no filter results container found.');\n    }\n    this.results = new FilterResult(resultsEl);\n  }\n  /** Initializes chips if the container element exists. */\n  initChips() {\n    var _a;\n    const chipsEl = this.root.querySelector(`.${CssClasses.CHIPS}`);\n    if (chipsEl) {\n      const chipsCollection = {};\n      for (const [index, filterCategory] of Object.entries(this.categories)) {\n        const category =\n            (_a = filterCategory.category) !== null && _a !== void 0 ?\n            _a :\n            `glue-filter-category-${index}`;\n        chipsCollection[category] = filterCategory.chips;\n      }\n      this.chips = new FilterChips(chipsEl, chipsCollection);\n    }\n  }\n  /** Initializes reset all buttons if they exist. */\n  initResetAll() {\n    this.resetAllEls = [\n      ...this.root.querySelectorAll(`.${CssClasses.RESET_ALL}`),\n    ];\n    if (this.resetAllEls.length) {\n      for (const el of this.resetAllEls) {\n        el.addEventListener(EventType.CLICK, this.handleReset);\n      }\n      this.root.addEventListener(\n          Strings.UPDATE_STATUS, this.handleUpdateResetButton);\n    }\n  }\n  /** Initializes expansion panels if they exist */\n  initPanels() {\n    if (this.expansionPanelsEl) {\n      this.expansionPanels = new ExpansionPanels(this.expansionPanelsEl);\n    }\n  }\n  /** Initializes responsive monitor to create/destroy modal if modal exists */\n  initResponsiveModal() {\n    if (this.modalEl) {\n      if (!this.modalToggleEl) {\n        throw new Error('Filter modal exists but its toggle is missing.');\n      }\n      this.responsiveModal = new ResponsiveMonitor({\n        breakpoint: ['sm', 'md'],\n        enter: () => {\n          var _a, _b;\n          // Initializes modal and toggle handlers on small/medium viewports\n          this.modal = new Modal(this.modalEl, this.modalToggleEl);\n          (_a = this.modalToggleEl) === null || _a === void 0 ?\n              void 0 :\n              _a.addEventListener(EventType.CLICK, this.handleOpenModal);\n          (_b = this.modalCloseEl) === null || _b === void 0 ?\n              void 0 :\n              _b.addEventListener(EventType.CLICK, this.handleCloseModal);\n        },\n        leave: () => {\n          var _a, _b, _c, _d;\n          // Closes/destroys modal and remove handlers on large/xl viewports\n          (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();\n          (_b = this.modal) === null || _b === void 0 ? void 0 : _b.destroy();\n          (_c = this.modalToggleEl) === null || _c === void 0 ?\n              void 0 :\n              _c.removeEventListener(EventType.CLICK, this.handleOpenModal);\n          (_d = this.modalCloseEl) === null || _d === void 0 ?\n              void 0 :\n              _d.removeEventListener(EventType.CLICK, this.handleCloseModal);\n        },\n      });\n    }\n  }\n  /**\n   * Removes event listeners and destroys subcomponents.\n   */\n  destroy() {\n    var _a, _b, _c, _d, _e, _f, _g;\n    // Destroys/resets filter categories and chips\n    this.categories.forEach((filterCategory) => {\n      filterCategory.destroy();\n    });\n    (_a = this.chips) === null || _a === void 0 ? void 0 : _a.destroy();\n    FilterStateManager.reset();\n    // Cleans up resetall buttons\n    if (this.resetAllEls.length) {\n      for (const el of this.resetAllEls) {\n        el.removeEventListener(EventType.CLICK, this.handleReset);\n      }\n      this.root.removeEventListener(\n          Strings.UPDATE_STATUS, this.handleUpdateResetButton);\n    }\n    // Destroys panels\n    (_b = this.expansionPanels) === null || _b === void 0 ? void 0 :\n                                                            _b.destroy();\n    // Destroys/cleans up modal\n    (_c = this.responsiveModal) === null || _c === void 0 ? void 0 :\n                                                            _c.destroy();\n    (_d = this.modal) === null || _d === void 0 ? void 0 : _d.close();\n    (_e = this.modal) === null || _e === void 0 ? void 0 : _e.destroy();\n    (_f = this.modalToggleEl) === null || _f === void 0 ?\n        void 0 :\n        _f.removeEventListener(EventType.CLICK, this.handleOpenModal);\n    (_g = this.modalCloseEl) === null || _g === void 0 ?\n        void 0 :\n        _g.removeEventListener(EventType.CLICK, this.handleCloseModal);\n  }\n  /**\n   * Resets all filters, or a single filter if the filter category is specified.\n   * @param category The filter category to reset.\n   */\n  reset(category) {\n    if (category) {\n      this.categories\n          .filter((val) => {\n            return val.category === category;\n          })[0]\n          .reset();\n    } else {\n      this.categories.forEach((filterCategory) => {\n        filterCategory.reset();\n      });\n      // Updates classes\n      this.updateResetButton();\n    }\n  }\n  /**\n   * Returns a list of matched items.\n   */\n  getFilteredItems() {\n    return this.results.filteredItems;\n  }\n  /**\n   * Returns the StateManager.\n   */\n  getStateManager() {\n    return new FilterStateManager();\n  }\n  /**\n   * Updates class on the Reset All buttons when filters are toggled.\n   * Class should only be added when at least one filter is active.\n   */\n  updateResetButton() {\n    let areFiltersActive = false;\n    const isActive = (filterValue) => filterValue === true;\n    for (const filterCategory of this.categories) {\n      if (!areFiltersActive) {\n        areFiltersActive =\n            Object.values(filterCategory.model.data).some(isActive);\n      }\n    }\n    for (const el of this.resetAllEls) {\n      if (areFiltersActive) {\n        el.classList.add(CssClasses.RESET_ALL_FILTERED);\n      } else {\n        el.classList.remove(CssClasses.RESET_ALL_FILTERED);\n      }\n    }\n  }\n}\nexport {Filter, FilterStateManager};\n","import {Component} from '../../base';\nimport {Attribute} from '../../constants/attribute';\nimport {CssClasses, Strings} from '../constants';\nimport {FilterStateManager} from '../state_manager';\nimport {filterlist} from '../util';\n/**\n * A class to manage filter result component.\n */\nclass FilterResult extends Component {\n  /**\n   * Creates an instance of GlueFilterResult.\n   */\n  constructor(root) {\n    super(root);\n    this.resultItems = [];\n    this.filteredItems = [];\n    this.resultTags = [];\n    this.filterCategories = [];\n    this.filterData = {};\n    this.init();\n  }\n  /** Initializes filter result component. */\n  init() {\n    var _a;\n    // Updates strategy value of the filter.\n    this.filterData.strategy = this.root.dataset[Strings.STRATEGY];\n    // Validates filter categories.\n    const filterCategories = this.root.dataset[Strings.CATEGORIES];\n    if (!filterCategories) {\n      throw new Error('Filter categories are not set on the result element.');\n    }\n    this.filterCategories = filterCategories.split(' ');\n    if (!this.checkfilterCategories(this.filterCategories)) {\n      throw new Error('These filter categories are not valid.');\n    }\n    // Subscribes to filter data changes.\n    for (const filterCategory of this.filterCategories) {\n      const model = new FilterStateManager().getModel(filterCategory);\n      const data =\n          (_a = model === null || model === void 0 ? void 0 : model.data) !==\n                  null &&\n              _a !== void 0 ?\n          _a :\n          {};\n      for (const key of Object.keys(data)) {\n        model === null || model === void 0 ? void 0 : model.listen(key, () => {\n          this.render();\n        });\n      }\n    }\n    // Collects tags from each result item.\n    this.resultItems = [\n      ...this.root.querySelectorAll(`.${CssClasses.RESULT}`),\n    ];\n    this.resultItems.forEach((el) => {\n      // Parse data-glue-filter-result-match as data-glue-filter-CATEGORY\n      if (el.dataset[Strings.RESULT_MATCH]) {\n        JSON.parse(el.dataset[Strings.RESULT_MATCH], (key, value) => {\n          if (key) {\n            el.dataset[key] = value;\n          }\n        });\n      }\n      const tags = {};\n      this.filterCategories.forEach((filterCategory) => {\n        const filterTag = el.getAttribute(Strings.PREFIX + filterCategory);\n        tags[filterCategory] = filterTag ? filterTag.split(' ') : [];\n      });\n      this.resultTags.push(tags);\n    });\n    this.render();\n  }\n  /** Returns true if all filter categories are valid. */\n  checkfilterCategories(filterCategories) {\n    for (const category of filterCategories) {\n      if (!new FilterStateManager().getModel(category)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** Returns filter results. */\n  getFilterResults() {\n    var _a;\n    const data = {};\n    for (const category of this.filterCategories) {\n      data[category] =\n          (_a = new FilterStateManager().getModel(category)) === null ||\n              _a === void 0 ?\n          void 0 :\n          _a.data;\n    }\n    this.filterData = Object.assign({}, this.filterData, data);\n    return filterlist(this.resultTags, this.filterData);\n  }\n  /**\n   * Renders filter results elements.\n   */\n  render() {\n    const results = this.getFilterResults();\n    for (const [index, el] of this.resultItems.entries()) {\n      el.classList.toggle(CssClasses.RESULT_IS_MATCHING, results[index]);\n      results[index] ? el.removeAttribute(Attribute.ARIA_HIDDEN) :\n                       el.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    }\n    this.filteredItems = [\n      ...this.root.querySelectorAll(`.${CssClasses.RESULT_IS_MATCHING}`),\n    ];\n    this.renderCounter();\n  }\n  /**\n   * Renders the count of filtered results.\n   */\n  renderCounter() {\n    const counter = this.filteredItems.length;\n    const filterRootEl = this.root.closest(`.${CssClasses.ROOT}`) ?\n        this.root.closest(`.${CssClasses.ROOT}`) :\n        this.root;\n    const resultsCount =\n        filterRootEl.querySelectorAll(`.${CssClasses.RESULTS_COUNT}`);\n    if (resultsCount.length) {\n      for (const el of resultsCount) {\n        // Removes all child nodes\n        while (el.firstChild) {\n          el.removeChild(el.firstChild);\n        }\n        const numEl = document.createTextNode(counter.toString());\n        el.appendChild(numEl);\n      }\n    }\n  }\n}\nexport {FilterResult};\n","/**\n * A class to manage state of list filter component.\n * It manages a collection of models.\n */\nclass FilterStateManager {\n  constructor() {\n    this.models = {};\n    if (!FilterStateManager.instance) {\n      FilterStateManager.instance = this;\n    } else {\n      this.models = FilterStateManager.instance.getModels();\n    }\n    return FilterStateManager.instance;\n  }\n  /**\n   * Returns the data object based on the key.\n   * @param key The key of the data.\n   */\n  getModel(key) {\n    return this.models[key];\n  }\n  /**\n   * Returns all data objects.\n   */\n  getModels() {\n    return this.models;\n  }\n  /**\n   * Sets data model.\n   * @param key The key of the data.\n   * @param model The data to be set.\n   */\n  setModel(key, model) {\n    this.models[key] = model;\n  }\n  // Resets the StateManager instance.\n  static reset() {\n    FilterStateManager.instance = undefined;\n  }\n}\nexport {FilterStateManager};\n","/**\n * Returns matching results for a list of data.\n *\n *  The first argument is targetArray which includes a list of targets.\n *  Each target is an object which represents a filter category and\n *  possible values.\n *  Example:\n *  targetArray: Target[] = [\n *    {\n *      'color': ['green', 'red'],\n *      'type': ['fruit'],\n *    },\n *    {\n *      'color': ['yellow'],\n *      'type': ['vegetable'],\n *    }\n *  ]\n *\n *  The second parameter is a filter object, which represents the matching\n *  criteria used to evaluate the list of items.\n *  Example:\n *  filter: Filter = {\n *    'type': {\n *      'vegetable': true,\n *      'fruit': false,\n *    },\n *    'color': {\n *      'red': true,\n *      'orange': true,\n *      'yellow': false,\n *      'green': false\n *    }\n *  }\n *  The output is an array of boolean values, they represent whether the\n *  corresponding items are matched. Example: [true,true,false].\n * @param targetArr The target data object to filter\n * @param filter The filter object with stategy and filters.\n * @param matchFunc An optional function to use for matching.\n * @return The result showing whether the data matches the filter.\n */\nfunction filterlist(targetArr, filter, matchFunc) {\n  const output = [];\n  targetArr.forEach((target) => {\n    const filtered = filterData(target, filter, matchFunc);\n    output.push(filtered);\n  });\n  return output;\n}\n/**\n * Returns matching result for a single data based on the filter.\n * @return Shows whether the data matches the filter.\n */\nfunction filterData(target, filter, matchFunc) {\n  let isMatch = false;\n  // Set a default filter strategy to 'strict'\n  if (filter.strategy === undefined ||\n      !['strict', 'loose'].includes(filter.strategy)) {\n    filter.strategy = 'strict';\n  }\n  for (const key of Object.keys(target)) {\n    isMatch = false;\n    // Ignores the filter if the filter is inactive. The filter is inactive\n    // if all filter options are false.\n    if (!checkActiveState(filter, key) || filter[key] === undefined) {\n      isMatch = true;\n    } else {\n      for (const value of target[key]) {\n        const filterGroup = filter[key];\n        let matchResult = false;\n        if (matchFunc) {\n          matchResult = matchFunc.call(undefined, filter, key, value);\n        } else if (typeof filterGroup === 'object') {\n          matchResult = filterGroup[value];\n        }\n        if (matchResult === true) {\n          isMatch = true;\n          break;\n        }\n      }\n    }\n    if ((filter.strategy === 'strict') === isMatch) {\n      continue;\n    } else {\n      return isMatch;\n    }\n  }\n  return isMatch;\n}\n/**\n * Checks whether the filter is active. Returns true if users have\n * changed the filter value.\n * @param filter The object includes all filters.\n * @param filterId The id of the filter item.\n * @return If the state is active.\n */\nfunction checkActiveState(filter, filterId) {\n  const item = filter[filterId];\n  if (typeof item === 'object') {\n    for (const filterOption in item) {\n      if (item[filterOption]) return true;\n    }\n  }\n  if (typeof item === 'string' && item.length > 0) {\n    return true;\n  }\n  return false;\n}\nexport {\n  filterlist,\n};\n","/**\n * @fileoverview Utilities relating to keyboard focus.\n */\n/**\n * Query selectors for elements that can receive focus.\n * Include Material 3 custom elements that Glue uses.\n */\nconst FOCUSABLE_ELEMENT_SELECTORS = [\n  'input',\n  'textarea',\n  'select',\n  'button',\n  'iframe',\n  '[role=\"button\"]',\n  'a',\n  '[tabindex]',\n  'md-checkbox',\n  'md-radio',\n  'md-switch',\n  'md-outlined-select',\n  'md-filled-select',\n  'md-outlined-text-field',\n  'md-filled-text-field',\n];\n/**\n * Returns true if the element is able to receive focus. Note that this will\n * return true even for elements where the user isn't able to move focus\n * to the element but javascript is able to move focus.\n * @param el The Element to check for focusability.\n * @return Returns true if the element is focusable\n */\nfunction isElementFocusable(el) {\n  return (\n      FOCUSABLE_ELEMENT_SELECTORS\n          .filter((selector) => {\n            return el.matches(selector);\n          })\n          .length > 0);\n}\n/**\n * Get all child focusable elements.\n * @param el The parent element.\n * @return Array containing all child focusable elements.\n */\nfunction getFocusableElements(el) {\n  const inputs = el.querySelectorAll('input');\n  const anchors = el.querySelectorAll('a');\n  const textareas = el.querySelectorAll('textarea');\n  const selects = el.querySelectorAll('select');\n  const buttons = el.querySelectorAll('button');\n  const iframes = el.querySelectorAll('iframe');\n  const roleBtnElements = el.querySelectorAll(\n      '[role=\"button\"]' +\n      ':not(input)' +\n      ':not(a)' +\n      ':not(textarea)' +\n      ':not(select)' +\n      ':not(button)' +\n      ':not(iframe)');\n  const tabindexElements = el.querySelectorAll(\n      '[tabindex=\"0\"]' +\n      ':not([role=\"button\"])' +\n      ':not(input)' +\n      ':not(a)' +\n      ':not(textarea)' +\n      ':not(select)' +\n      ':not(button)' +\n      ':not(iframe)' +\n      ':not(md-checkbox)' +\n      ':not(md-radio)' +\n      ':not(md-switch)' +\n      ':not(md-outlined-select)' +\n      ':not(md-filled-select)' +\n      ':not(md-outlined-text-field)' +\n      ':not(md-filled-text-field)');\n  const mdCheckboxes = el.querySelectorAll('md-checkbox');\n  const mdRadios = el.querySelectorAll('md-radio');\n  const mdSwitches = el.querySelectorAll('md-switch');\n  const mdOutlinedSelects = el.querySelectorAll('md-outlined-select');\n  const mdFilledSelects = el.querySelectorAll('md-filled-select');\n  const mdOutlinedTextFields = el.querySelectorAll('md-outlined-text-field');\n  const mdFilledTextFields = el.querySelectorAll('md-filled-text-field');\n  return [\n    ...inputs,\n    ...anchors,\n    ...textareas,\n    ...selects,\n    ...buttons,\n    ...iframes,\n    ...roleBtnElements,\n    ...tabindexElements,\n    ...mdCheckboxes,\n    ...mdRadios,\n    ...mdSwitches,\n    ...mdOutlinedSelects,\n    ...mdFilledSelects,\n    ...mdOutlinedTextFields,\n    ...mdFilledTextFields,\n  ];\n}\nexport {FOCUSABLE_ELEMENT_SELECTORS, getFocusableElements, isElementFocusable};\n","/**\n * @fileoverview Constants used in footer component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['FOOTER_ROOT'] = 'glue-footer';\nCssClasses['FOOTER_UPPER'] = 'glue-footer__upper';\nCssClasses['FOOTER_LINK'] = 'glue-footer__link';\nCssClasses['FOOTER_LOGO'] = 'glue-footer__logo';\nCssClasses['FOOTER_LOGO_IMG'] = 'glue-footer__logo-img';\nCssClasses['FOOTER_PANELS'] = 'glue-footer__site-links';\nCssClasses['FOOTER_PANELS_GROUP'] = 'glue-footer__site-links-grid';\nCssClasses['FOOTER_PANELS_PANEL'] = 'glue-footer__site-links-column';\nCssClasses['FOOTER_PANELS_TOGGLE'] = 'glue-footer__site-links-header';\nCssClasses['FOOTER_PANELS_BUTTON'] = 'glue-footer__site-links-header-button';\nCssClasses['FOOTER_PANELS_CONTENT'] = 'glue-footer__site-links-list';\nCssClasses['FOOTER_PANELS_CONTENT_ITEM'] = 'glue-footer__site-links-list-item';\nCssClasses['FOOTER_PANELS_HEADER_TEXT'] = 'glue-footer__site-links-header-text';\nCssClasses['FOOTER_GLOBAL'] = 'glue-footer__global';\nCssClasses['FOOTER_GLOBAL_LINKS'] = 'glue-footer__global-links';\nCssClasses['FOOTER_GLOBAL_LINKS_EXTRA'] = 'glue-footer__global-links--extra';\nCssClasses['FOOTER_GLOBAL_LINKS_LIST_ITEM'] =\n    'glue-footer__global-links-list-item';\nCssClasses['FOOTER_GLOBAL_LINKS_LIST_ITEM_EXTRA'] =\n    'glue-footer__global-links-list-item--extra';\nCssClasses['FOOTER_LANG_DROPDOWN'] = 'glue-footer__lang-dropdown';\n})(CssClasses || (CssClasses = {}));\nvar DataAttr;\n(function(DataAttr) {\nDataAttr['MODEL_NAME'] = 'footer';\nDataAttr['KEY'] = 'glueExpansionPanelsKey';\nDataAttr['TOGGLEFOR'] = 'glueExpansionPanelToggleFor';\n})(DataAttr || (DataAttr = {}));\nexport {CssClasses, DataAttr};\n","import {Component} from '../base';\nimport {ExpansionPanels} from '../expansionpanels';\nimport {CssClasses as ExpansionPanelsClasses} from '../expansionpanels/constants';\nimport {ResponsiveMonitor} from '../responsivemonitor/';\n\nimport {CssClasses, DataAttr} from './constants';\n\n/**\n * Class for creating Footer.\n */\nclass Footer extends Component {\n  /**\n   * @param root The element that contains the footer sitelinks.\n   * @param options Footer sitelink options.\n   */\n  constructor(root, options) {\n    super(root);\n    this.options = Object.assign({}, Footer.defaults, options);\n    // Set up expansion panel options\n    this.panelsOptions = {\n      isAnimated: this.options.isAnimated,\n      panelsCount: this.options.columnCount,\n    };\n    this.panelGroupEl =\n        this.root.querySelector(`.${CssClasses.FOOTER_PANELS_GROUP}`);\n    // Set up rules for Responsive Monitor if panel group exists\n    if (this.panelGroupEl) {\n      this.responsiveSitelinks = new ResponsiveMonitor({\n        breakpoint: this.options.panelsBreakpoints,\n        enter: () => {\n          if (this.panelGroupEl) {\n            // Set up expansion panels\n            this.configureExpansionPanels(true);\n            this.panelsComponent =\n                new ExpansionPanels(this.panelGroupEl, this.panelsOptions);\n          }\n        },\n        leave: () => {\n          var _a;\n          if (this.panelGroupEl) {\n            // Remove expansion panels\n            (_a = this.panelsComponent) === null || _a === void 0 ?\n                void 0 :\n                _a.destroy();\n            this.configureExpansionPanels(false);\n          }\n        },\n      });\n    }\n  }\n  /**\n   * Default footer sitelinks options.\n   */\n  static get defaults() {\n    return {\n      panelsBreakpoints: ['sm'],\n      isAnimated: true,\n      columnCount: 4,\n    };\n  }\n  /**\n   * Destroy the component.\n   */\n  destroy() {\n    var _a;\n    // Destroy panels (if set)\n    if (this.panelsComponent) {\n      this.panelsComponent.destroy();\n      this.configureExpansionPanels(false);\n    }\n    // Destroy Responsive monitor instance\n    (_a = this.responsiveSitelinks) === null || _a === void 0 ? void 0 :\n                                                                _a.destroy();\n  }\n  /**\n   * Configure expansion panels if they exist\n   */\n  configureExpansionPanels(isPanels) {\n    if (!this.panelGroupEl) {\n      return;\n    }\n    // Group settings\n    this.panelGroupEl.classList.toggle(ExpansionPanelsClasses.GROUP, isPanels);\n    if (isPanels) {\n      this.panelGroupEl.dataset[DataAttr.KEY] = DataAttr.MODEL_NAME;\n    } else {\n      delete this.panelGroupEl.dataset[DataAttr.KEY];\n    }\n    // Individual panel settings\n    for (const panelEl of this.panelGroupEl.querySelectorAll(\n             `.${CssClasses.FOOTER_PANELS_PANEL}`)) {\n      const panelToggleEl =\n          panelEl.querySelector(`.${CssClasses.FOOTER_PANELS_TOGGLE}`);\n      const panelButtonEl =\n          panelEl.querySelector(`.${CssClasses.FOOTER_PANELS_BUTTON}`);\n      const panelContentEl =\n          panelEl.querySelector(`.${CssClasses.FOOTER_PANELS_CONTENT}`);\n      panelEl === null || panelEl === void 0 ?\n          void 0 :\n          panelEl.classList.toggle(ExpansionPanelsClasses.PANEL, isPanels);\n      panelToggleEl === null || panelToggleEl === void 0 ?\n          void 0 :\n          panelToggleEl.classList.toggle(\n              ExpansionPanelsClasses.TOGGLE, isPanels);\n      panelButtonEl === null || panelButtonEl === void 0 ?\n          void 0 :\n          panelButtonEl.classList.toggle(\n              ExpansionPanelsClasses.BUTTON, isPanels);\n      panelContentEl === null || panelContentEl === void 0 ?\n          void 0 :\n          panelContentEl.classList.toggle(\n              ExpansionPanelsClasses.CONTENT, isPanels);\n      // Accessibility attributes for various elements\n      if (isPanels && panelButtonEl && panelContentEl) {\n        panelButtonEl.dataset[DataAttr.TOGGLEFOR] = panelContentEl.id;\n      } else {\n        panelButtonEl === null || panelButtonEl === void 0 ?\n            void 0 :\n            panelButtonEl.removeAttribute(DataAttr.TOGGLEFOR);\n      }\n    }\n  }\n}\nexport {Footer};\n","/**\n * @fileoverview Constants used by the Header component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-header';\nCssClasses['BAR'] = 'glue-header__bar';\nCssClasses['TOGGLE_BTN'] = 'glue-header__drawer-toggle-btn';\nCssClasses['DRAWER_EL'] = 'glue-header__drawer';\nCssClasses['DRAWER_EL_BACKDROP'] = 'glue-header__drawer-backdrop';\nCssClasses['HAMBURGER'] = 'glue-header__hamburger';\nCssClasses['DRAWER_IS_SHOWN'] = 'glue-is-showing-drawer';\nCssClasses['DOUBLE'] = 'glue-header--double';\nCssClasses['SINGLE'] = 'glue-header--single';\nCssClasses['WHOLLY_SCROLLED'] = 'glue-header-is-wholly-scrolled';\nCssClasses['LOCK_UP'] = 'glue-header__lock-up';\nCssClasses['ICON_LOCK_UP'] = 'glue-header--icon-lockup';\nCssClasses['LINK_BAR'] = 'glue-header__link-bar';\nCssClasses['LIST'] = 'glue-header__list';\nCssClasses['LIST_ITEM'] = 'glue-header__item';\nCssClasses['NESTED_LIST'] = 'glue-header__list--nested';\nCssClasses['LINK_ITEM'] = 'glue-header__link';\nCssClasses['LOGO'] = 'glue-header__logo';\nCssClasses['LOGO_LINK'] = 'glue-header__logo-link';\nCssClasses['LOGO_PRODUCT'] = 'glue-header__logo--product';\nCssClasses['LOGO_CONTAINER'] = 'glue-header__logo-container';\nCssClasses['LOGO_PRODUCT_CAMPAIGN'] = 'glue-header__logo--product-campaign';\nCssClasses['LOGO_SVG'] = 'glue-header__logo-svg';\nCssClasses['NO_DRAWER'] = 'glue-header-no-drawer';\nCssClasses['STEPPED_NAV_ENABLE'] = 'glue-header-stepped-nav-enabled';\nCssClasses['ACTIVE_MENU'] = 'glue-header--is-active';\nCssClasses['ACTIVE_LINK'] = 'glue-header__item--active';\nCssClasses['IS_ANIMATING'] = 'glue-is-animating';\nCssClasses['BAR_DESKTOP'] = 'glue-header__bar--desktop';\nCssClasses['BAR_MOBILE'] = 'glue-header__bar--mobile';\nCssClasses['REWIND_SHADOW'] = 'glue-header--rewind-box-shadow';\nCssClasses['HEADER_CONTAINER'] = 'glue-header__container';\nCssClasses['HEADER_CONTAINER_LINKBAR'] = 'glue-header__container--linkbar';\nCssClasses['HEADER_CONTAINER_CTA'] = 'glue-header__container--cta';\nCssClasses['SKIP_BTN'] = 'glue-header__skip-content';\nCssClasses['DEEP_NAV'] = 'glue-header__deep-nav';\nCssClasses['TRANSPARENT'] = 'glue-header--transparent';\nCssClasses['HOVERED'] = 'glue-header--hovered';\nCssClasses['FOCUSED'] = 'glue-header--focused';\nCssClasses['ACTIVE'] = 'glue-header--active';\nCssClasses['TIER'] = 'glue-header__tier';\nCssClasses['STACKED'] = 'glue-header--complex-stacked';\nCssClasses['SIMPLE'] = 'glue-header--simple';\nCssClasses['REVERSE'] = 'glue-header--reverse';\nCssClasses['NO_CTA'] = 'glue-header--no-cta';\nCssClasses['CTA'] = 'glue-header__cta';\nCssClasses['SUPPLEMENTAL'] = 'glue-header__supplemental';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['MISSING_ROOT_ELEMENT'] =\n    'No element with \"glue-header class\" was found. Header component needs a root element.';\nStrings['MISSING_HEADER_BAR_ELEMENT'] =\n    'No element with \"glue-header__bar\" class was found. This is required by Header component.';\nStrings['MISSING_DRAWER_ELEMENT'] =\n    'No element with \"glue-header__drawer\" class was found. This is required by Header component.';\nStrings['MISSING_TOGGLE_BTN_ELEMENT'] =\n    'No element with \"glue-header__drawer-toggle-btn\" class was found. This is required by Header component.';\nStrings['MISSING_LINK_BAR_ELEMENT'] =\n    'No element with \"glue-header__link-bar\" class was found. This is required by Header component.';\nStrings['UNKNOWN_CUSTOM_BREAKPOINT'] =\n    'Unknown custom breakpoint. Valid values are \"md\", \"lg\", or \"xl\".';\nStrings['SCROLL_UP'] = 'up';\nStrings['SCROLL_DOWN'] = 'down';\nStrings['INCORRECT_TYPE'] = 'Incorrect data type';\nStrings['SHOW_EVENT'] = 'glueheadershow';\nStrings['HIDE_EVENT'] = 'glueheaderhide';\n})(Strings || (Strings = {}));\nvar Numbers;\n(function(Numbers) {\nNumbers[Numbers['MAX_PAGE_OFFSET'] = 500] = 'MAX_PAGE_OFFSET';\nNumbers[Numbers['ANIMATING_STATE_BUFFER'] = 20] = 'ANIMATING_STATE_BUFFER';\nNumbers[Numbers['SCROLL_THRESHOLD'] = 50] = 'SCROLL_THRESHOLD';\nNumbers[Numbers['POSITION_CHANGE_BUFFER'] = 300] = 'POSITION_CHANGE_BUFFER';\n})(Numbers || (Numbers = {}));\nvar Icons;\n(function(Icons) {\nIcons['DOWN_ARROW'] = 'expand-more';\nIcons['RIGHT_ARROW'] = 'chevron-right';\nIcons['LEFT_ARROW'] = 'chevron-left';\nIcons['HAMBURGER'] = 'menu';\n})(Icons || (Icons = {}));\nexport {CssClasses, Icons, Numbers, Strings};\n","var Strings;\n(function(Strings) {\nStrings['ERROR_MSG_NO_CHILDREN'] = 'has no element children.';\nStrings['ERROR_PREFIX'] = 'Menubar constructor argument el ';\n})(Strings || (Strings = {}));\nexport {Strings};\n","import {Component} from '../../base';\nimport {Attribute, Role} from '../../constants/attribute';\nimport {CssClasses} from '../constants';\n\nimport {Strings} from './constants';\nimport {MenubarItem} from './menubaritem';\n\n/**\n * This class creates a navigation menu bar instance, each menu item may control\n * a dropdown sub menu.\n */\nclass Menubar extends Component {\n  constructor(root) {\n    super(root);\n    /** A collection of the menu items */\n    this.menubarItems = [];\n    /** A collection of the first characters of each menu item label */\n    this.firstChars = [];\n    /** The first  menu item. */\n    this.firstItem = null;\n    /** The last  menu item. */\n    this.lastItem = null;\n    /** A flag to show menubar's focus status. */\n    this.hasFocus = false;\n    /** A flag to show menubar's hover status. */\n    this.hasHover = false;\n    if (root.childElementCount === 0) {\n      throw new Error(Strings.ERROR_PREFIX + Strings.ERROR_MSG_NO_CHILDREN);\n    }\n    this.init();\n  }\n  /**\n   * Initializes the menubar component.\n   * Throws an error if the menubar is empty.\n   */\n  init() {\n    var _a;\n    const listItems =\n        this.root.querySelectorAll(`:scope > .${CssClasses.LIST_ITEM}`);\n    this.root.setAttribute(Attribute.ROLE, Role.MENUBAR);\n    for (const listItem of listItems) {\n      listItem.setAttribute(Attribute.ROLE, Role.NONE);\n    }\n    // Traverse the children elements and store reference in menuitems array.\n    let elem = this.root.firstElementChild;\n    let menubarItem;\n    let menuElement;\n    let textContent;\n    while (elem) {\n      menuElement = elem.firstElementChild;\n      if (elem && menuElement instanceof HTMLAnchorElement) {\n        menubarItem = new MenubarItem(menuElement, this);\n        this.menubarItems.push(menubarItem);\n        textContent = (_a = menuElement.textContent) === null || _a === void 0 ?\n            void 0 :\n            _a.trim();\n        if (textContent) {\n          this.firstChars.push(textContent.substring(0, 1).toLowerCase());\n        }\n      }\n      elem = elem.nextElementSibling;\n    }\n    const numItems = this.menubarItems.length;\n    if (numItems > 0) {\n      this.firstItem = this.menubarItems[0];\n      this.lastItem = this.menubarItems[numItems - 1];\n      this.firstItem.root.tabIndex = 0;\n    }\n  }\n  destroy() {\n    for (const item of this.menubarItems) {\n      item.destroy();\n    }\n  }\n  /**\n   * Sets focus to the specified menu item.\n   */\n  setFocusToItem(newItem) {\n    var _a;\n    let isExpanded = false;\n    for (const menubarItem of this.menubarItems) {\n      if (menubarItem.root.tabIndex === 0) {\n        isExpanded =\n            menubarItem.root.getAttribute(Attribute.ARIA_EXPANDED) === 'true';\n      }\n      menubarItem.root.tabIndex = -1;\n      (_a = menubarItem.popupMenu) === null || _a === void 0 ? void 0 :\n                                                               _a.close();\n    }\n    newItem.root.focus();\n    newItem.root.tabIndex = 0;\n    if (isExpanded && newItem.popupMenu) {\n      newItem.popupMenu.open();\n    }\n  }\n  setFocusToFirstItem() {\n    this.setFocusToItem(this.firstItem);\n  }\n  setFocusToLastItem() {\n    this.setFocusToItem(this.lastItem);\n  }\n  /**\n   * Sets focus to the previous menu item.\n   * If the current item is the first menu item, move focus to the last\n   * menu item.\n   */\n  setFocusToPreviousItem(currentItem) {\n    let index;\n    let newItem;\n    if (currentItem === this.firstItem) {\n      newItem = this.lastItem;\n    } else {\n      index = this.menubarItems.indexOf(currentItem);\n      newItem = this.menubarItems[index - 1];\n    }\n    this.setFocusToItem(newItem);\n  }\n  /**\n   * Sets focus to the next menu item.\n   * If the current item is the last menu item, move focus to the first\n   * menu item.\n   */\n  setFocusToNextItem(currentItem) {\n    let index;\n    let newItem;\n    if (currentItem === this.lastItem) {\n      newItem = this.firstItem;\n    } else {\n      index = this.menubarItems.indexOf(currentItem);\n      newItem = this.menubarItems[index + 1];\n    }\n    this.setFocusToItem(newItem);\n  }\n  /**\n   * Sets focus to the menu item based on the first Character.\n   * Search matching label from the current item, if it hits the end,\n   * start from the first item, vice versa.\n   */\n  setFocusByFirstCharacter(currentItem, char) {\n    let start;\n    let index;\n    char = char.toLowerCase();\n    start = this.menubarItems.indexOf(currentItem) + 1;\n    if (start === this.menubarItems.length) {\n      start = 0;\n    }\n    const findIndexFunc = (item, index) => {\n      return item === char && index >= start;\n    };\n    index = this.firstChars.findIndex(findIndexFunc);\n    if (index === -1) {\n      start = 0;\n      index = this.firstChars.findIndex(findIndexFunc);\n    }\n    if (index > -1) {\n      this.setFocusToItem(this.menubarItems[index]);\n    }\n  }\n}\nexport {Menubar};\n","import {Component} from '../../base';\nimport {Attribute, Role} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {PopupMenu} from '../popupmenu';\n/**\n * This class creates a menu item instance, which may control a dropdown menu.\n */\nclass MenubarItem extends Component {\n  /** The menu argument is the menu bar element that contains this menu item. */\n  constructor(root, parentMenu) {\n    super(root);\n    this.parentMenu = parentMenu;\n    /** A popup menu component, controlled by the menu item. */\n    this.popupMenu = null;\n    /** A flag to show menu bar item's focus status. */\n    this.hasFocus = false;\n    /** A flag to show menu bar item's hover status. */\n    this.hasHover = false;\n    /**\n     * This flag is used to determine if this controller is a menu bar item.\n     * This flag is set to false in other controllers such as site switcher and\n     * popup menu item.\n     */\n    this.isMenubarItem = true;\n    /**\n     * Handles keydown events.\n     * - When press the Space, Enter or Down keys, open the menu if able and\n     * focus to the first item.\n     * - When press the Up key, open the popup menu if able and focus to the\n     * last item.\n     * - When press the left key, move focus to the previous menu item.\n     * - When press the right key, move focus to the next menu item.\n     * - When press the Home or PageUp key, move focus to the first item.\n     * - When press the End or PageDown key, move focus to the last item.\n     * - When press the Tab key, close the popup menu, and move focus to the\n     * next focusable element.\n     * - When press the ESC key, close the popup menu, move focus to the\n     * controller.\n     */\n    this.handleKeydown = (event) => {\n      var _a, _b;\n      const char = event.key;\n      let preventDefault = false;\n      function isPrintableCharacter(str) {\n        return str.length === 1 && str.match(/\\S/);\n      }\n      switch (event.key) {\n        case Key.SPACE:\n        case Key.ENTER:\n        case Key.DOWN:\n          if (this.popupMenu) {\n            this.popupMenu.open();\n            this.popupMenu.setFocusToFirstItem();\n            preventDefault = true;\n          }\n          break;\n        case Key.LEFT:\n          this.parentMenu.setFocusToPreviousItem(this);\n          preventDefault = true;\n          break;\n        case Key.RIGHT:\n          this.parentMenu.setFocusToNextItem(this);\n          preventDefault = true;\n          break;\n        case Key.UP:\n          if (this.popupMenu) {\n            this.popupMenu.open();\n            this.popupMenu.setFocusToLastItem();\n            preventDefault = true;\n          }\n          break;\n        case Key.HOME:\n        case Key.PAGEUP:\n          this.parentMenu.setFocusToFirstItem();\n          preventDefault = true;\n          break;\n        case Key.END:\n        case Key.PAGEDOWN:\n          this.parentMenu.setFocusToLastItem();\n          preventDefault = true;\n          break;\n        case Key.TAB:\n          (_a = this.popupMenu) === null || _a === void 0 ? void 0 :\n                                                            _a.close(true);\n          break;\n        case Key.ESC:\n          (_b = this.popupMenu) === null || _b === void 0 ? void 0 :\n                                                            _b.close(true);\n          break;\n        default:\n          if (isPrintableCharacter(char)) {\n            this.parentMenu.setFocusByFirstCharacter(this, char);\n            preventDefault = true;\n          }\n          break;\n      }\n      if (preventDefault) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    };\n    /** Sets expanded attribute. */\n    this.setExpanded = (flag) => {\n      if (flag) {\n        this.root.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n      } else {\n        this.root.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n      }\n    };\n    /** Sets hasFocus to true when the menu item is in focus. */\n    this.handleFocus = () => {\n      this.parentMenu.hasFocus = true;\n    };\n    /** Sets hasFocus to false when the menu item is blurred. */\n    this.handleBlur = () => {\n      this.parentMenu.hasFocus = false;\n    };\n    /**\n     * When the menu item in hovered, set hasHover to true and open the\n     * popupmenu if able.\n     */\n    this.handleMouseenter = () => {\n      var _a;\n      this.hasHover = true;\n      (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.open();\n    };\n    /**\n     * When the mouse is moved away from the menu item, set hasHover to false\n     * and close the popupmenu after 300 mills.\n     */\n    this.handleMouseleave = () => {\n      this.hasHover = false;\n      setTimeout(() => {\n        var _a;\n        (_a = this.popupMenu) === null || _a === void 0 ? void 0 :\n                                                          _a.close(false);\n      }, 300);\n    };\n    this.init();\n  }\n  /**\n   * Initializes the menu item and the associated popup menu.\n   */\n  init() {\n    this.root.tabIndex = -1;\n    this.root.setAttribute(Attribute.ROLE, Role.MENUITEM);\n    const nextElement = this.root.nextElementSibling;\n    if (nextElement instanceof HTMLUListElement) {\n      this.popupMenu = new PopupMenu(nextElement, this);\n      this.root.setAttribute(Attribute.ARIA_HASPOPUP, 'true');\n      this.root.addEventListener(EventType.FOCUS, this.handleFocus);\n      this.root.addEventListener(EventType.BLUR, this.handleBlur);\n      this.root.addEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n      this.root.addEventListener(EventType.MOUSELEAVE, this.handleMouseleave);\n    }\n    this.root.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n  }\n  destroy() {\n    var _a;\n    (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.root.removeAttribute(Attribute.TAB_INDEX);\n    this.root.removeAttribute(Attribute.ARIA_HASPOPUP);\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.removeEventListener(EventType.FOCUS, this.handleFocus);\n    this.root.removeEventListener(EventType.BLUR, this.handleBlur);\n    this.root.removeEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.removeEventListener(EventType.MOUSELEAVE, this.handleMouseleave);\n  }\n}\nexport {MenubarItem};\n","/**\n * @fileoverview Constants used by the Header component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-header__drawer';\nCssClasses['DRAWER_IS_OPEN'] = 'glue-header__drawer--is-open';\nCssClasses['TOGGLE_BTN'] = 'glue-header__drawer-toggle-btn';\nCssClasses['IS_ANIMATING'] = 'glue-is-animating';\nCssClasses['GLUE_BUTTON'] = 'glue-button';\nCssClasses['NO_SCROLL'] = 'glue-no-scroll';\nCssClasses['BACKDROP'] = 'glue-header__drawer-backdrop';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['MISSING_DRAWER_ELEMENT'] =\n    'No element with \"glue-header__drawer\" class was found. Drawer component needs a root element.';\nStrings['MISSING_BACKDROP_ELEMENT'] =\n    'No element with \"glue-header__drawer-backdrop\" class was found.';\nStrings['OPEN'] = 'glueHeaderDrawerOpen';\nStrings['CLOSE'] = 'glueHeaderDrawerClose';\nStrings['TOGGLE_BTN'] = 'toggleBtn';\n})(Strings || (Strings = {}));\nexport {CssClasses, Strings};\n","import {Component} from '../../base/';\nimport {Attribute, TabIndex} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {getFocusableElements} from '../../focus';\nimport {Coordinate} from '../../math/coordinate';\n\nimport {CssClasses, Strings} from './constants';\n\nclass Drawer extends Component {\n  /**\n   * @param root The element that contains options object.\n   * @param toggleEl The element that toggles the drawer open and closed.\n   */\n  constructor(root, toggleEl) {\n    var _a;\n    super(root);\n    this.toggleEl = toggleEl;\n    this.closed = true;\n    this.isAnimating = false;\n    this.ariaHiddenElements = [];\n    this.focusableElements = [];\n    /** Start time of the drag movement */\n    this.startTime = 0;\n    /** Initial touch position */\n    this.initialTouchPos = null;\n    /** Last touch poistion */\n    this.lastTouchPos = null;\n    /** True when it is ready to call request animatino frame */\n    this.rafPending = false;\n    this.handleGestureStart = (event) => {\n      // Returns if there are multi touch points.\n      if (this.isTouchEvent(event) && event.touches.length > 1) {\n        return;\n      }\n      // Add the move and end listeners if PointerEvent is supported.\n      // Otherwise add mouse listeners.\n      if (this.isPointerEvent(event) && event.target instanceof Element) {\n        event.target.setPointerCapture(event.pointerId);\n      } else {\n        document.addEventListener(\n            EventType.MOUSEMOVE, this.handleGestureMove, true);\n        document.addEventListener(\n            EventType.MOUSEUP, this.handleGestureEnd, true);\n      }\n      this.initialTouchPos = this.getGesturePointFromEvent(event);\n      this.startTime = new Date().getTime();\n      // Overwrites the transition value set up in CSS\n      this.root.style.transition = 'initial';\n    };\n    this.handleGestureMove = (event) => {\n      event.preventDefault();\n      if (!this.initialTouchPos) {\n        return;\n      }\n      // Prevent small taps/etc triggering a dragging interaction\n      const currentTouchPos = this.getGesturePointFromEvent(event);\n      const distanceDragged = Math.abs(\n          Coordinate.difference(currentTouchPos, this.initialTouchPos).x);\n      if (distanceDragged < 10) {\n        return;\n      }\n      this.lastTouchPos = currentTouchPos;\n      // Returns if it is waiting for request animation frame callback.\n      if (this.rafPending) {\n        return;\n      }\n      this.rafPending = true;\n      window.requestAnimationFrame(() => {\n        this.onAnimFrame();\n      });\n    };\n    this.handleGestureEnd = (event) => {\n      var _a;\n      event.preventDefault();\n      if (this.isTouchEvent(event) &&\n          ((_a = event.touches) === null || _a === void 0 ? void 0 :\n                                                            _a.length) > 0) {\n        return;\n      }\n      this.rafPending = false;\n      // Remove Event Listeners\n      if (this.isPointerEvent(event) && event.target instanceof Element) {\n        event.target.releasePointerCapture(event.pointerId);\n      } else {\n        // Remove Mouse Listeners\n        document.removeEventListener(\n            EventType.MOUSEMOVE, this.handleGestureMove, true);\n        document.removeEventListener(\n            EventType.MOUSEUP, this.handleGestureEnd, true);\n      }\n      this.updateDrawerPosition();\n      // Resets drag status\n      this.startTime = 0;\n      this.initialTouchPos = null;\n      this.lastTouchPos = null;\n    };\n    // Check class names\n    if (!this.root.classList.contains(CssClasses.ROOT)) {\n      throw new Error(Strings.MISSING_DRAWER_ELEMENT);\n    }\n    this.setAttributes();\n    const element = (_a = this.root.parentElement) === null || _a === void 0 ?\n        void 0 :\n        _a.querySelector(`.${CssClasses.BACKDROP}`);\n    if (!element) {\n      throw new Error(Strings.MISSING_BACKDROP_ELEMENT);\n    }\n    this.backdrop = element;\n    this.transitionEndHandler = () => {\n      this.handleTransitionEndEvent();\n    };\n    this.handleKeydown = (event) => {\n      if (event.code === Key.TAB) {\n        // Move focus back to the root.\n        this.root.focus();\n        return;\n      }\n      event.preventDefault();\n      if (event.code === Key.ENTER) {\n        this.close();\n      }\n    };\n    this.handleOpen = () => {\n      document.body.classList.add(CssClasses.NO_SCROLL);\n      document.documentElement.classList.add(CssClasses.NO_SCROLL);\n      this.backdrop.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n    };\n    this.handleClose = () => {\n      document.body.classList.remove(CssClasses.NO_SCROLL);\n      document.documentElement.classList.remove(CssClasses.NO_SCROLL);\n      this.backdrop.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    };\n    // CSS Animation event handlers\n    this.root.addEventListener(\n        EventType.TRANSITIONEND, this.transitionEndHandler);\n    // Adding and removing body no scroll class\n    document.body.addEventListener(Strings.OPEN, this.handleOpen);\n    document.body.addEventListener(Strings.CLOSE, this.handleClose);\n  }\n  registerTouchEvents() {\n    if (window.PointerEvent) {\n      this.root.addEventListener(\n          EventType.POINTERDOWN, this.handleGestureStart, true);\n      this.root.addEventListener(\n          EventType.POINTERMOVE, this.handleGestureMove, true);\n      this.root.addEventListener(\n          EventType.POINTERUP, this.handleGestureEnd, true);\n      this.root.addEventListener(\n          EventType.POINTERCANCEL, this.handleGestureEnd, true);\n    } else {\n      // Add Touch Listener\n      this.root.addEventListener(\n          EventType.TOUCHSTART, this.handleGestureStart, true);\n      this.root.addEventListener(\n          EventType.TOUCHMOVE, this.handleGestureMove, true);\n      this.root.addEventListener(\n          EventType.TOUCHEND, this.handleGestureEnd, true);\n      this.root.addEventListener(\n          EventType.TOUCHCANCEL, this.handleGestureEnd, true);\n      // Add Mouse Listener\n      this.root.addEventListener(\n          EventType.MOUSEDOWN, this.handleGestureStart, true);\n    }\n  }\n  deregisterTouchEvents() {\n    if (window.PointerEvent) {\n      this.root.removeEventListener(\n          EventType.POINTERDOWN, this.handleGestureStart, true);\n      this.root.removeEventListener(\n          EventType.POINTERMOVE, this.handleGestureMove, true);\n      this.root.removeEventListener(\n          EventType.POINTERUP, this.handleGestureEnd, true);\n      this.root.removeEventListener(\n          EventType.POINTERCANCEL, this.handleGestureEnd, true);\n    } else {\n      this.root.removeEventListener(\n          EventType.TOUCHSTART, this.handleGestureStart, true);\n      this.root.removeEventListener(\n          EventType.TOUCHMOVE, this.handleGestureMove, true);\n      this.root.removeEventListener(\n          EventType.TOUCHEND, this.handleGestureEnd, true);\n      this.root.removeEventListener(\n          EventType.TOUCHCANCEL, this.handleGestureEnd, true);\n      this.root.removeEventListener(\n          EventType.MOUSEDOWN, this.handleGestureStart, true);\n    }\n  }\n  destroy() {\n    this.deregisterTouchEvents();\n    this.root.removeEventListener(\n        EventType.TRANSITIONEND, this.transitionEndHandler);\n    document.body.removeEventListener(Strings.OPEN, this.handleOpen);\n    document.body.removeEventListener(Strings.CLOSE, this.handleClose);\n  }\n  /** Determines whether the event is a TouchEvent. */\n  isTouchEvent(event) {\n    return window.TouchEvent && event instanceof TouchEvent;\n  }\n  /** Determines whether the event is a PointerEvent. */\n  isPointerEvent(event) {\n    return window.PointerEvent && event instanceof PointerEvent;\n  }\n  // Transits the drawer based on the last touch position.\n  // Drag to right should do nothing.\n  onAnimFrame() {\n    if (!this.rafPending || !this.initialTouchPos || !this.lastTouchPos) {\n      return;\n    }\n    const differenceInX =\n        Coordinate.difference(this.lastTouchPos, this.initialTouchPos).x;\n    // Do thing if move to right\n    if (differenceInX > 0) {\n      this.root.style.transform = '';\n    } else {\n      const transformStyle = `translate3d(${differenceInX}px, 0, 0)`;\n      this.root.style.transform = transformStyle;\n    }\n    this.rafPending = false;\n  }\n  getGesturePointFromEvent(event) {\n    const point = new Coordinate(0, 0);\n    if (this.isTouchEvent(event)) {\n      if (event.targetTouches) {\n        point.x = event.targetTouches[0].clientX;\n        point.y = event.targetTouches[0].clientY;\n      }\n    } else {\n      point.x = event.clientX;\n      point.y = event.clientY;\n    }\n    return point;\n  }\n  updateDrawerPosition() {\n    // Resets the inline styles so the CSS transition style takes in charge\n    // During the drag phase, inline transition style overwrites the CSS\n    // transition.\n    this.root.style.transition = '';\n    this.root.style.transform = '';\n    if (!this.lastTouchPos || !this.initialTouchPos) return;\n    const differenceInX =\n        Coordinate.difference(this.lastTouchPos, this.initialTouchPos).x;\n    const validDrag = Math.abs(differenceInX) >= this.root.clientWidth * 0.5;\n    const currentTime = new Date().getTime();\n    const duration = currentTime - this.startTime;\n    const validSwipe = duration < 300 && Math.abs(differenceInX) > 10;\n    if (validDrag || validSwipe) {\n      this.close();\n    }\n  }\n  /**\n   * Opens the drawer\n   */\n  open() {\n    if (this.closed && !this.isAnimating) {\n      this.isAnimating = true;\n      this.emit(Strings.OPEN, {}, true);\n      this.root.classList.add(CssClasses.DRAWER_IS_OPEN);\n      this.root.classList.add(CssClasses.IS_ANIMATING);\n      this.setDefaultAttrs();\n      // set aria-expanded property of button to true while opening drawer\n      this.toggleEl.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n      this.backdrop.setAttribute(Attribute.ROLE, 'button');\n      this.backdrop.tabIndex = TabIndex.TABBABLE;\n      this.removeAriaHidden();\n      this.ariaHideElements();\n      this.root.focus();\n      this.removeKeyboardFocus();\n      this.registerTouchEvents();\n    }\n  }\n  /**\n   * Removes keyboard focus from all the focusable elements outside the drawer.\n   */\n  removeKeyboardFocus() {\n    const focusable = getFocusableElements(window.document.body);\n    this.focusableElements = [];\n    for (const el of focusable) {\n      if (!this.root.contains(el) && !this.backdrop.contains(el) &&\n          el.tabIndex !== -1) {\n        this.focusableElements.push(el);\n        el.tabIndex = -1;\n      }\n    }\n  }\n  /**\n   * Adds keyboard focus for all the focusable elements outside the drawer.\n   */\n  addKeyboardFocus() {\n    for (const el of this.focusableElements) {\n      el.removeAttribute('tabindex');\n    }\n  }\n  /**\n   * Closes the drawer and sets the focus to the toggle btn.\n   */\n  close() {\n    if (!this.closed && !this.isAnimating) {\n      this.isAnimating = true;\n      this.emit(Strings.CLOSE, {}, true);\n      this.root.classList.add(CssClasses.IS_ANIMATING);\n      this.removeDefaultAttrs();\n      // set aria-expanded property of button  to false while closing drawer\n      this.toggleEl.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n      this.toggleEl.focus();\n      this.setAriaHidden();\n      this.ariaUnhideElements();\n      this.addKeyboardFocus();\n      if (this.backdrop) {\n        this.backdrop.removeAttribute(Attribute.TAB_INDEX);\n        this.backdrop.removeAttribute(Attribute.ROLE);\n      }\n      this.deregisterTouchEvents();\n    }\n  }\n  setAttributes() {\n    if (!this.root.id) {\n      const randomId = Math.round(Math.random() * 99999999).toString(16);\n      this.root.id = `glue-drawer-${randomId}`;\n    }\n    this.toggleEl.setAttribute(Attribute.ARIA_CONTROLS, this.root.id);\n    this.toggleEl.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n    this.toggleEl.setAttribute(Attribute.ARIA_HASPOPUP, 'true');\n  }\n  /**\n   * Check to see if drawer is open\n   */\n  isOpen() {\n    return this.root.classList.contains(CssClasses.DRAWER_IS_OPEN);\n  }\n  /**\n   * Check to see if the event target is a child element of the drawer component\n   */\n  containsElement(event) {\n    return event.target instanceof Node && this.root.contains(event.target);\n  }\n  /**\n   * Check to see if the event target is a child element of the drawer component\n   */\n  isCtaElement(event) {\n    return (\n        event.target instanceof Element &&\n        event.target.classList.contains(CssClasses.GLUE_BUTTON));\n  }\n  /**\n   * This method will take care of any logic that needs to run after the CSS\n   * transition has ended.\n   */\n  handleTransitionEndEvent() {\n    if (this.isAnimating) {\n      this.root.classList.remove(CssClasses.IS_ANIMATING);\n      if (this.closed) {\n        this.closed = false;\n      } else {\n        this.root.classList.remove(CssClasses.DRAWER_IS_OPEN);\n        this.closed = true;\n      }\n      this.isAnimating = false;\n    }\n  }\n  /**\n   * This method will remove applied aria attributes\n   */\n  removeAriaHidden() {\n    this.root.removeAttribute(Attribute.ARIA_HIDDEN);\n  }\n  /**\n   * This method will set aria attributes\n   */\n  setAriaHidden() {\n    this.root.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n  }\n  /**\n   * This method sets default attributes when the drawer is opened\n   */\n  setDefaultAttrs() {\n    this.root.setAttribute(Attribute.ARIA_LABEL, 'Navigation drawer');\n    this.root.tabIndex = TabIndex.TABBABLE;\n  }\n  /**\n   * This method removes default attributes when the drawer is closed\n   */\n  removeDefaultAttrs() {\n    this.root.removeAttribute(Attribute.ARIA_LABEL);\n    this.root.removeAttribute(Attribute.TAB_INDEX);\n  }\n  /**\n   * Set aria hidden to true for all other elements.\n   * This method provides complementary A11y support before aria-modal\n   * The code is referenced from\n   * https://source.corp.google.com/piper///depot/google3/googledata/html/external_content/scs_corp/ariablueprints/dialog/dialog-modal-1.0.html;l=81-101\n   * gets broader browser support.\n   */\n  ariaHideElements() {\n    let current = this.root;\n    while (current && current.parentNode) {\n      for (const child of Array.from(current.parentNode.children)) {\n        if (child !== current && child !== this.backdrop &&\n            child.getAttribute(Attribute.ARIA_HIDDEN) !== 'true') {\n          this.ariaHiddenElements.push(child);\n          child.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n        }\n      }\n      current = current.parentNode;\n    }\n  }\n  /**\n   * Remove aria hidden to false for all other elements.\n   */\n  ariaUnhideElements() {\n    this.ariaHiddenElements.forEach((el) => {\n      el.removeAttribute(Attribute.ARIA_HIDDEN);\n    });\n    this.ariaHiddenElements = [];\n  }\n}\nexport {Drawer};\n","import {Component} from '../base/';\nimport {Attribute} from '../constants/attribute';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\nimport {ResponsiveMonitor} from '../responsivemonitor/';\n\nimport {CssClasses, Numbers, Strings} from './constants';\nimport {Menubar} from './deepnav/';\nimport {Drawer} from './drawer/';\nimport {Strings as DrawerStrings} from './drawer/constants';\nimport {SiteSwitcher} from './siteswitcher/';\nimport {CssClasses as SiteSwitcherCssClasses} from './siteswitcher/constants';\nimport {SteppedNav} from './steppednav/';\n\n/**\n * Glue Header Component\n */\nclass Header extends Component {\n  constructor(root, headerOptions) {\n    super(root);\n    this.isAnimating = false;\n    this.scrolling = false;\n    this.lastPositionY = 0;\n    this.atTopOfPage = true;\n    this.allowTransitionEndEvent = false;\n    this.isTransparent = false;\n    /**\n     * This flag needs to be set to true. This is needed to block a scroll event\n     * on reload and adds box shadow to the header.\n     */\n    this.blockFalseScroll = true;\n    /**\n     * Handler for key down events\n     */\n    this.keydownHandler = (e) => {\n      var _a, _b;\n      const isEscape = e.key === Key.ESC;\n      if (this.options.drawer) {\n        if (((_a = this.drawer) === null || _a === void 0 ? void 0 :\n                                                            _a.isOpen()) &&\n            isEscape) {\n          (_b = this.drawer) === null || _b === void 0 ? void 0 : _b.close();\n        }\n      }\n    };\n    /**\n     * Handler for mouseover event. This will add an active class so we can put\n     * the default header styles back for transparent header.\n     */\n    this.handleMouseOver = (e) => {\n      if (this.root === e.target || this.containsElement(e)) {\n        this.root.classList.add(CssClasses.ACTIVE);\n      }\n    };\n    /**\n     * Handler for mouseleave event. This will remove active class, this is used\n     * only for the transparent header variation.\n     */\n    this.handleMouseLeave = (e) => {\n      !this.root.matches(':focus-within') &&\n          !this.activeBarElement.classList.contains(CssClasses.REWIND_SHADOW) &&\n          this.root.classList.remove(CssClasses.ACTIVE);\n    };\n    /**\n     * Handler for header focus event. This adds an acive class to the header\n     * it's currently focused. We have to add a class due to the face that, the\n     * peudo selector ':focus-within' doesn't work with :not(), this is a better\n     * solution.\n     */\n    this.handleFocus = () => {\n      if (this.root.matches(':focus-within')) {\n        this.root.classList.add(CssClasses.ACTIVE);\n      } else {\n        !this.activeBarElement.classList.contains(CssClasses.REWIND_SHADOW) &&\n            this.root.classList.remove(CssClasses.ACTIVE);\n      }\n    };\n    /**\n     * Handles focus within state. Used to reshow header for keyboard users are\n     * trying to navigate back to the header\n     */\n    this.handleFocusWithin = () => {\n      this.show();\n    };\n    if (!this.root.classList.contains(CssClasses.ROOT)) {\n      throw new Error(Strings.MISSING_ROOT_ELEMENT);\n    }\n    this.options = Object.assign(\n        {}, Header.defaultOptions, headerOptions, this.getOptions());\n    // Set up breakpoints array for responsive monitor\n    switch (this.options.breakpoint) {\n      case 'md':\n        this.breakpointsMobileNav = ['sm'];\n        break;\n      case 'lg':\n        this.breakpointsMobileNav = ['sm', 'md'];\n        break;\n      case 'xl':\n        this.breakpointsMobileNav = ['sm', 'md', 'lg'];\n        break;\n      default:  // unknown breakpoint value\n        throw new Error(Strings.UNKNOWN_CUSTOM_BREAKPOINT);\n    }\n    this.initialize();\n    this.initializeNavigationSubcomponents();\n    this.responsiveMonitorInit();\n  }\n  /**\n   * Default Header options.\n   */\n  static get defaultOptions() {\n    return {\n      breakpoint: 'lg',\n      drawer: true,\n      hideOnScroll: true,\n      steppedNav: false,\n    };\n  }\n  /**\n   * Initialize Drawer and Bar\n   */\n  initialize() {\n    var _a, _b;\n    this.headerBar = this.getHeaderBarElement();\n    this.headerBarMobile = this.getHeaderBarElement(true);\n    this.activeBarElement = this.getActiveBarElement();\n    if (this.options.drawer) {\n      const drawerEl = this.root.querySelector(`.${CssClasses.DRAWER_EL}`);\n      const linkBarEl = (_a = this.headerBar) === null || _a === void 0 ?\n          void 0 :\n          _a.querySelector(`.${CssClasses.LINK_BAR}`);\n      // Throw exception if element is missing\n      if (drawerEl === null) {\n        throw new Error(Strings.MISSING_DRAWER_ELEMENT);\n      } else if (linkBarEl === null) {\n        throw new Error(Strings.MISSING_LINK_BAR_ELEMENT);\n      }\n      this.toggleBtnEl = this.root.querySelector(`.${CssClasses.TOGGLE_BTN}`);\n      // Throw exception if element is missing\n      if (this.toggleBtnEl === null) {\n        throw new Error(Strings.MISSING_TOGGLE_BTN_ELEMENT);\n      }\n      this.drawer = new Drawer(drawerEl, this.toggleBtnEl);\n    } else {\n      this.root.classList.add(CssClasses.NO_DRAWER);\n    }\n    this.setPositionStyle();\n    this.setActiveBarPosition(this.headerBar.style.position);\n    // Set required attributes\n    // Add aria attrs\n    this.root.setAttribute(Attribute.ARIA_EXPANDED, `false`);\n    // Bind handlers\n    this.handleClick = (e) => {\n      this.clickHandler(e);\n    };\n    this.handleKeydown = (e) => {\n      this.keydownHandler(e);\n    };\n    this.handleScroll = () => {\n      this.scrollThrottlerHandler();\n    };\n    this.handleDrawOpen = () => {\n      this.handleDrawerOpenEvent();\n    };\n    this.handleDrawClose = () => {\n      this.handleDrawerCloseEvent();\n    };\n    this.handleTransitionEnd = () => {\n      this.handleTransitionEndEvent();\n    };\n    // Event listeners\n    this.root.addEventListener(EventType.CLICK, this.handleClick);\n    this.root.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.addEventListener(EventType.FOCUS_IN, this.handleFocusWithin);\n    // DRAWER\n    this.options.drawer &&\n        this.root.addEventListener(DrawerStrings.OPEN, this.handleDrawOpen);\n    this.options.drawer &&\n        this.root.addEventListener(DrawerStrings.CLOSE, this.handleDrawClose);\n    window.addEventListener(EventType.SCROLL, this.handleScroll);\n    this.headerBar.addEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n    this.headerBarMobile.addEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n    if (this.root.classList.contains(CssClasses.TRANSPARENT)) {\n      this.isTransparent = true;\n      this.root.classList.contains(CssClasses.DOUBLE) &&\n          ((_b = this.root.querySelector(`.${CssClasses.ACTIVE_MENU} > a`)) ===\n                       null ||\n                   _b === void 0 ?\n               void 0 :\n               _b.appendChild(document.createElement('div')));\n      this.root.addEventListener(EventType.MOUSEOVER, this.handleMouseOver);\n      this.root.addEventListener(EventType.MOUSELEAVE, this.handleMouseLeave);\n      this.root.addEventListener(EventType.FOCUS_IN, this.handleFocus);\n      this.root.addEventListener(EventType.FOCUS_OUT, this.handleFocus);\n    }\n    this.injectVersion();\n  }\n  injectVersion() {\n    document.documentElement.dataset['glue'] = 'glue@28.2.0';\n  }\n  /**\n   * Initialize SteppedNav, DeepNav and SiteSwitcher.\n   */\n  initializeNavigationSubcomponents() {\n    // Init the popovers for deep nav and site switcher if present.\n    const siteSwitcherElem =\n        this.root.querySelector(`.${SiteSwitcherCssClasses.COMPONENT}`);\n    if (siteSwitcherElem) {\n      this.siteSwitcher = new SiteSwitcher(siteSwitcherElem);\n    }\n    const menuBar = this.root.querySelector(`.${CssClasses.DEEP_NAV}`);\n    if (menuBar) {\n      this.deepNav = new Menubar(menuBar);\n    }\n    // Init the Stepped Nav if the option is on and the element is present.\n    if (this.options.steppedNav) {\n      const steppedNavElem = SteppedNav.getSteppedNavElement(this.root);\n      if (steppedNavElem) {\n        this.root.classList.add(CssClasses.STEPPED_NAV_ENABLE);\n        // If there is a failure to init the stepped nav, just fail back to\n        // the standard nav.\n        try {\n          this.steppedNav = new SteppedNav(steppedNavElem);\n        } catch (error) {\n          this.root.classList.remove(CssClasses.STEPPED_NAV_ENABLE);\n          throw error;\n        }\n      }\n    }\n  }\n  destroy() {\n    var _a, _b, _c;\n    this.root.removeEventListener(EventType.CLICK, this.handleClick);\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.removeEventListener(EventType.FOCUS_IN, this.handleFocusWithin);\n    this.headerBar.removeEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n    this.headerBarMobile.removeEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n    window.removeEventListener(EventType.SCROLL, this.handleScroll);\n    // Cancel the animation frame\n    window.cancelAnimationFrame(this.animationsFrameId);\n    this.rm.unlisten((size) => {\n      if (this.breakpointsMobileNav.includes(size)) {\n        this.setActiveBarPosition();\n      }\n    });\n    this.rm.destroy();\n    if (this.options.drawer) {\n      this.root.removeEventListener(DrawerStrings.OPEN, this.handleDrawOpen);\n      this.root.removeEventListener(DrawerStrings.CLOSE, this.handleDrawClose);\n      (_a = this.drawer) === null || _a === void 0 ? void 0 : _a.destroy();\n    }\n    (_b = this.siteSwitcher) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this.deepNav) === null || _c === void 0 ? void 0 : _c.destroy();\n    if (this.steppedNav) this.steppedNav.destroy();\n    if (this.root.classList.contains(CssClasses.TRANSPARENT)) {\n      this.root.removeEventListener(EventType.MOUSEOVER, this.handleMouseOver);\n      this.root.removeEventListener(\n          EventType.MOUSELEAVE, this.handleMouseLeave);\n      this.root.removeEventListener(EventType.FOCUS_IN, this.handleFocus);\n      this.root.removeEventListener(EventType.FOCUS_OUT, this.handleFocus);\n    }\n  }\n  /**\n   * Get the options passed or returns the default options\n   */\n  getOptions() {\n    const options = {};\n    for (const option of Object.keys(Header.defaultOptions)) {\n      const attr =\n          `glueHeader${option.toUpperCase().slice(0, 1)}${option.slice(1)}`;\n      if (this.root.dataset[attr] === 'true' ||\n          this.root.dataset[attr] === 'false') {\n        options[option] = this.root.dataset[attr] === 'true';\n      } else {\n        if (this.root.dataset[attr]) {\n          options[option] = this.root.dataset[attr];\n        }\n      }\n    }\n    return options;\n  }\n  /**\n   * Handles the event delegation for the click handlers on the root element.\n   */\n  clickHandler(e) {\n    var _a, _b, _c, _d, _e, _f;\n    if (this.options.drawer) {\n      if ((_a = this.drawer) === null || _a === void 0 ? void 0 : _a.isOpen()) {\n        if (!((_b = this.drawer) === null || _b === void 0 ?\n                  void 0 :\n                  _b.containsElement(e))) {\n          (_c = this.drawer) === null || _c === void 0 ? void 0 : _c.close();\n        } else if (\n            (_d = this.drawer) === null || _d === void 0 ? void 0 :\n                                                           _d.isCtaElement(e)) {\n          (_e = this.drawer) === null || _e === void 0 ? void 0 : _e.close();\n        }\n      } else {\n        if (this.toggleBtnEl.contains(e.target)) {\n          (_f = this.drawer) === null || _f === void 0 ? void 0 : _f.open();\n        }\n      }\n    }\n  }\n  /**\n   * Checks to see if the event target is a child of the root element.\n   */\n  containsElement(event) {\n    return event.target instanceof Node && this.root.contains(event.target);\n  }\n  /**\n   * This is to throttle the scrolling logic with window.requestAnimationFrame.\n   * this is also using a requestAnimationFrame to help with performance.\n   */\n  scrollThrottlerHandler() {\n    if (!this.scrolling) {\n      this.animationsFrameId = window.requestAnimationFrame(() => {\n        this.scrollHandler();\n        this.scrolling = false;\n      });\n      this.scrolling = true;\n    }\n  }\n  /**\n   * Called via window.requestAnimationFrame, this helps check state\n   * in a more accurate way and helps avoid getting lock in an incorrect\n   * position.\n   */\n  scrollHandler() {\n    const hasScrolledClass =\n        this.activeBarElement.classList.contains(CssClasses.WHOLLY_SCROLLED);\n    // Get the direction\n    const direction = this.getScrollDirection();\n    // Need to set a threshold to avoid browser elastic scrolling triggering\n    // nav hide\n    const nearBottom =\n        document.body.clientHeight - window.scrollY - window.innerHeight <=\n        Numbers.SCROLL_THRESHOLD;\n    const scrollingDown = direction === Strings.SCROLL_DOWN;\n    const scrollingUp = direction === Strings.SCROLL_UP;\n    // Will hide the nav once it haves the scroll class and scrolling down\n    if (!this.atTopOfPage && scrollingDown && !hasScrolledClass &&\n        !this.isAnimating) {\n      // Hide the nav after scrolling down to pass the nav element.\n      if (window.scrollY > this.activeBarElement.clientHeight) {\n        this.hide();\n      }\n      // This is for scrolling up and not at the top of the page. We also block\n      // the elastic recoil causing a scroll up to fire.\n    } else if (\n        !this.atTopOfPage && scrollingUp && hasScrolledClass &&\n        !this.isAnimating && !nearBottom) {\n      // This fix a bug in some mobile safari browsers. It randomly causes\n      // this block to run while scrolling down\n      if (this.lastPositionY - window.scrollY !== 0) {\n        this.show();\n      }\n      // This is for preventing the nav from getting lock in a hidden state.\n    } else if (this.atTopOfPage && !this.isAnimating && hasScrolledClass) {\n      this.show();\n    }\n    this.atTopOfPage = window.scrollY <= 0;\n    this.lastPositionY = window.scrollY;\n    // There is still a bug where scroll events are incorrectly being fired. We\n    // need to block this from causing rewind shadow being added\n    this.blockFalseScroll = false;\n    // Apply box shadow on header bar element.\n    this.rewindBoxShadow();\n    // This ensures that the position is correct when at the top of the page.\n    // Because of fast resizing and scrolling the Nav gets stuck with the wrong\n    // position.\n    this.atTopOfPage && this.setActiveBarPosition();\n    this.isTransparent && this.setTransparentActiveClass();\n    // This is a fail-safe, last check to see if that state has changed whilst\n    // animating. This is the main cause of header issues.\n    if (this.isAnimating && window.scrollY <= Numbers.MAX_PAGE_OFFSET) {\n      window.requestAnimationFrame(() => {\n        this.scrollThrottlerHandler();\n      });\n    }\n  }\n  /**\n   * Need to reset the position of the desktop header bar. This needs to be\n   * reset to avoid issues with the drawer.\n   */\n  resetDesktopHeaderPosition() {\n    const {display} = window.getComputedStyle(this.headerBarMobile);\n    // Reset drawer\n    if (display === 'block') {\n      this.headerBar.style.top = '0';\n      this.headerBar.style.position = 'fixed';\n    } else {\n      this.headerBar.style.position = 'static';\n    }\n  }\n  /**\n   * Set initial headerBar position style based on the scroll position.\n   */\n  setPositionStyle() {\n    if (window.scrollY > this.activeBarElement.clientHeight) {\n      this.headerBar.style.position = 'fixed';\n    } else {\n      this.headerBar.style.position = 'static';\n    }\n  }\n  /**\n   * The active class adds the normal styles back to the header, which is\n   * anytime the header is not at the top of the page. So when the @root element\n   * has position set to 'static' and atthe top of the page is the only time it\n   * will be transparent.\n   */\n  setTransparentActiveClass() {\n    if (window.scrollY > this.activeBarElement.clientHeight) {\n      this.root.classList.add(CssClasses.ACTIVE);\n    } else {\n      !this.root.matches(':focus-within') &&\n          this.root.classList.remove(CssClasses.ACTIVE);\n    }\n  }\n  /**\n   * Update the position of the active header element, needed for animation.\n   * position should be 'static' at the top of the page and 'fixed' once\n   * scrolled\n   * @param pos position to be set on the active bar element\n   */\n  setActiveBarPosition(pos = 'static') {\n    if (!this.options.hideOnScroll) {\n      pos = 'fixed';\n    }\n    const activeEl = this.activeBarElement;\n    const {display} = window.getComputedStyle(this.headerBarMobile);\n    display === 'block' && this.resetDesktopHeaderPosition();\n    if (pos === 'static') {\n      activeEl.style.top = `-${activeEl.clientHeight}px`;\n    } else {\n      setTimeout(() => {\n        activeEl.style.top = (0).toString();\n      }, Numbers.POSITION_CHANGE_BUFFER);\n    }\n    activeEl.style.position = pos;\n  }\n  /**\n   * Check if root has the correct child element, which is required for\n   * animations. There are two bar elements for desktop and mobile\n   */\n  getHeaderBarElement(isMobile = false) {\n    const filterByStr =\n        isMobile ? CssClasses.BAR_MOBILE : CssClasses.BAR_DESKTOP;\n    const headerBarEl =\n        Array.from(this.root.querySelectorAll(`.${CssClasses.BAR}`))\n            .filter((item) => item.classList.contains(filterByStr));\n    if (!headerBarEl) {\n      throw new Error(Strings.MISSING_HEADER_BAR_ELEMENT);\n    }\n    return headerBarEl[0];\n  }\n  /**\n   * Some classes need to be removed form the DOM when the close event is\n   * emitted from the Drawer component\n   */\n  handleDrawerCloseEvent() {\n    this.root.classList.remove(CssClasses.DRAWER_IS_SHOWN);\n    this.root.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n  }\n  /**\n   * Some classes need to be added to the DOM when the open event is emitted\n   * from the drawer component\n   */\n  handleDrawerOpenEvent() {\n    this.root.classList.add(CssClasses.DRAWER_IS_SHOWN);\n    this.root.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n  }\n  /**\n   * This method will take care of any logic that needs to run after the CSS\n   * transition has ended\n   */\n  handleTransitionEndEvent() {\n    if (this.allowTransitionEndEvent) {\n      this.isAnimating = false;\n      this.allowTransitionEndEvent = false;\n      this.activeBarElement.classList.remove(CssClasses.IS_ANIMATING);\n    }\n  }\n  /**\n   * The drawer needs to be closed if the window is resized to desktop and\n   * drawer is left open\n   */\n  responsiveMonitorInit() {\n    this.rm = new ResponsiveMonitor({\n      breakpoint: this.breakpointsMobileNav,\n      enter: () => {\n        var _a, _b, _c;\n        this.activeBarElement = this.getActiveBarElement();\n        this.setActiveBarPosition();\n        (_a = this.drawer) === null || _a === void 0 ? void 0 :\n                                                       _a.setAriaHidden();\n        (_b = this.siteSwitcher) === null || _b === void 0 ? void 0 :\n                                                             _b.destroy();\n        (_c = this.deepNav) === null || _c === void 0 ? void 0 : _c.destroy();\n      },\n      leave: () => {\n        var _a, _b, _c, _d, _e;\n        if (this.options.drawer &&\n            ((_a = this.drawer) === null || _a === void 0 ? void 0 :\n                                                            _a.isOpen())) {\n          (_b = this.drawer) === null || _b === void 0 ? void 0 : _b.close();\n        }\n        (_c = this.drawer) === null || _c === void 0 ? void 0 :\n                                                       _c.removeAriaHidden();\n        this.activeBarElement = this.getActiveBarElement();\n        this.setActiveBarPosition();\n        (_d = this.siteSwitcher) === null || _d === void 0 ? void 0 : _d.init();\n        (_e = this.deepNav) === null || _e === void 0 ? void 0 : _e.init();\n      },\n    });\n    // RM needs to trigger on resize, not just on enter.\n    this.rm.listen((size) => {\n      if (this.breakpointsMobileNav.includes(size)) {\n        this.setActiveBarPosition();\n      }\n    });\n  }\n  /**\n   * Get scroll direction\n   */\n  getScrollDirection() {\n    return this.lastPositionY >= window.scrollY ? Strings.SCROLL_UP :\n                                                  Strings.SCROLL_DOWN;\n  }\n  /**\n   * Will hide the nav and add the animation class.\n   */\n  hide() {\n    if (!this.options.hideOnScroll) return;\n    this.isAnimating = true;\n    this.allowTransitionEndEvent = true;\n    this.activeBarElement.classList.add(\n        CssClasses.WHOLLY_SCROLLED, CssClasses.IS_ANIMATING);\n    this.setActiveBarPosition('fixed');\n    this.emit(Strings.HIDE_EVENT, {});\n  }\n  /**\n   * Will show the nav and add the animation class. Will also remove the\n   * scroll class\n   */\n  show() {\n    if (!this.options.hideOnScroll) return;\n    this.isAnimating = true;\n    this.allowTransitionEndEvent = true;\n    // Add animation class to header-bar elements\n    this.activeBarElement.classList.add(CssClasses.IS_ANIMATING);\n    // Remove Scrolled class to header-bar elements\n    this.activeBarElement.classList.remove(CssClasses.WHOLLY_SCROLLED);\n    this.emit(Strings.SHOW_EVENT, {});\n  }\n  /**\n   * On rewind add the box shadow class but remove it once you reach the top of\n   * the page\n   */\n  rewindBoxShadow() {\n    if (this.atTopOfPage) {\n      this.activeBarElement.classList.remove(CssClasses.REWIND_SHADOW);\n    } else if (\n        !this.atTopOfPage && !this.isAnimating && !this.blockFalseScroll) {\n      // Header must but out of view before adding box shadow\n      if (window.scrollY > this.activeBarElement.clientHeight) {\n        this.activeBarElement.classList.add(CssClasses.REWIND_SHADOW);\n      }\n    }\n  }\n  /**\n   * Checks to see if Mobile navbar is visible. This will be set in init method\n   * and again with @type {ResponsiveMonitor}\n   */\n  getActiveBarElement() {\n    const {display} = window.getComputedStyle(this.headerBarMobile);\n    return display === 'block' ? this.headerBarMobile : this.headerBar;\n  }\n}\nexport {Header};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['MENU_OPEN'] = 'glue-header__menu--open';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['NO_CHILDREN'] =\n    'PopupMenu constructor argument el has no element children.';\n})(Strings || (Strings = {}));\nexport {CssClasses, Strings};\n","import {Component} from '../../base';\nimport {Attribute, Role} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Coordinate} from '../../math/coordinate';\nimport {CssClasses as HeaderCssClasses} from '../constants';\n\nimport {CssClasses, Strings} from './constants';\nimport {MenuItem} from './menuitem';\n\n/**\n * This class creates a PopupMenu instance, which uses a controller to\n * show and hide the menu.\n */\nclass PopupMenu extends Component {\n  constructor(root, controller) {\n    super(root);\n    this.menuItemCollection = [];\n    this.firstChars = [];\n    this.firstItem = null;\n    this.lastItem = null;\n    this.hasFocus = false;\n    this.hasHover = false;\n    /**\n     * Sets hasHover to true when the menu is hovered.\n     */\n    this.handleMouseenter = () => {\n      this.hasHover = true;\n    };\n    /**\n     * Waits for 300 mills to close the menu after moving mouse out of the menu.\n     */\n    this.handleMouseleave = (event) => {\n      this.hasHover = false;\n      const mousePos = new Coordinate(event.clientX, event.clientY);\n      if (this.isInController(mousePos)) return;\n      setTimeout(() => {\n        this.close(false);\n      }, 300);\n    };\n    /**\n     * Sets focus to the item based on the first key that users press.\n     */\n    this.setFocusByFirstCharacter = (currentItem, char) => {\n      char = char.toLowerCase();\n      // Gets the search start point.\n      let start = this.menuItemCollection.indexOf(currentItem) + 1;\n      if (start === this.menuItemCollection.length) {\n        start = 0;\n      }\n      const findIndexFunc = (item, index) => {\n        return item === char && index >= start;\n      };\n      let index = this.firstChars.findIndex(findIndexFunc);\n      if (index === -1) {\n        start = 0;\n        index = this.firstChars.findIndex(findIndexFunc);\n      }\n      if (index > -1) {\n        this.menuItemCollection[index].root.focus();\n      }\n    };\n    this.open = () => {\n      this.root.classList.add(CssClasses.MENU_OPEN);\n      this.controller.root.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n      this.controller.setExpanded(true);\n    };\n    if (this.root.childElementCount === 0) {\n      throw new Error(`${Strings.NO_CHILDREN}`);\n    }\n    this.menuItems = Array.from(\n        this.root.querySelectorAll(`.${HeaderCssClasses.LIST_ITEM}`));\n    this.controller = controller;\n    this.init();\n  }\n  init() {\n    let menuItem;\n    this.root.tabIndex = -1;\n    this.root.setAttribute(Attribute.ROLE, Role.MENU);\n    this.root.addEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.addEventListener(EventType.MOUSELEAVE, this.handleMouseleave);\n    for (const item of this.menuItems) {\n      item.setAttribute(Attribute.ROLE, Role.NONE);\n    }\n    const menuLinks = Array.from(this.root.querySelectorAll(\n        `:scope > .glue-header__item > .glue-header__link`));\n    // Initiates the popup menu attached to the menu item\n    for (const link of menuLinks) {\n      menuItem = new MenuItem(link, this);\n      const nextElement = menuItem.root.nextElementSibling;\n      if (nextElement instanceof HTMLUListElement) {\n        menuItem.popupMenu = new PopupMenu(nextElement, menuItem);\n      }\n      this.menuItemCollection.push(menuItem);\n      this.addFirstChar(link);\n    }\n    // Sets the first and last item in the menu.\n    const numItems = this.menuItemCollection.length;\n    if (numItems > 0) {\n      this.firstItem = this.menuItemCollection[0];\n      this.lastItem = this.menuItemCollection[numItems - 1];\n    }\n  }\n  destroy() {\n    var _a;\n    this.root.removeAttribute(Attribute.ROLE);\n    this.root.removeAttribute(Attribute.TAB_INDEX);\n    for (const item of this.menuItems) {\n      item.removeAttribute(Attribute.ROLE);\n    }\n    for (const menuItem of this.menuItemCollection) {\n      (_a = menuItem.popupMenu) === null || _a === void 0 ? void 0 :\n                                                            _a.destroy();\n      menuItem.destroy();\n    }\n    this.root.removeEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.removeEventListener(EventType.MOUSELEAVE, this.handleMouseleave);\n  }\n  /**\n   * Add first charector of each link text to the collection.\n   */\n  addFirstChar(link) {\n    var _a;\n    const textContent = (_a = link.textContent) === null || _a === void 0 ?\n        void 0 :\n        _a.trim().charAt(0).toLowerCase();\n    this.firstChars.push(\n        textContent !== null && textContent !== void 0 ? textContent : '');\n  }\n  /**\n   * Checks whether the cursor is in the controller area,\n   */\n  isInController(mousePos) {\n    const rect = this.controller.root.getBoundingClientRect();\n    return (\n        mousePos.x >= rect.left && mousePos.x <= rect.right &&\n        mousePos.y >= rect.top && mousePos.y <= rect.bottom);\n  }\n  /** Assert this is a MenuItem */\n  isMenuItem(controller) {\n    return controller.parentMenu !== null && controller.isMenubarItem === false;\n  }\n  /**\n   * Sets focus to the menubar item.\n   * Looks for the parent node if the current node is a menu item.\n   */\n  setFocusToMenubarItem(controller) {\n    while (controller) {\n      if (controller.isMenubarItem) {\n        controller.root.focus();\n        return controller;\n      } else if (this.isMenuItem(controller)) {\n        controller.parentMenu.hasFocus = false;\n        controller = controller.parentMenu.controller;\n      }\n    }\n    return null;\n  }\n  /**\n   * Sets focus to the controller depending on the keys.\n   * Sets focus to the controller element if no argument is passed.\n   * Sets focus to the next or previous menubar item when command is passed.\n   */\n  setFocusToController(command) {\n    var _a, _b, _c, _d, _e;\n    if (command === undefined) {\n      (_b = (_a = this.controller) === null || _a === void 0 ?\n           void 0 :\n           _a.root) === null ||\n              _b === void 0 ?\n          void 0 :\n          _b.focus();\n      return;\n    }\n    // If the controller is a menuBar item, set focus to the previous\n    // or next menuBar item.\n    if (this.controller.isMenubarItem) {\n      if (command === 'previous') {\n        (_c = this.controller.parentMenu) === null || _c === void 0 ?\n            void 0 :\n            _c.setFocusToPreviousItem(this.controller);\n      } else if (command === 'next') {\n        (_d = this.controller.parentMenu) === null || _d === void 0 ?\n            void 0 :\n            _d.setFocusToNextItem(this.controller);\n      }\n      // If the controller is a popup menu item, set the focus to its\n      // controller. If the command is next, set the focus to the next menubar\n      // item.\n    } else {\n      this.controller.root.focus();\n      this.close();\n      if (command === 'next') {\n        const menubarItem = this.setFocusToMenubarItem(this.controller);\n        (_e = menubarItem === null || menubarItem === void 0 ?\n             void 0 :\n             menubarItem.parentMenu) === null ||\n                _e === void 0 ?\n            void 0 :\n            _e.setFocusToNextItem(menubarItem);\n      }\n    }\n  }\n  setFocusToFirstItem() {\n    var _a;\n    (_a = this.firstItem) === null || _a === void 0 ? void 0 : _a.root.focus();\n  }\n  setFocusToLastItem() {\n    var _a;\n    (_a = this.lastItem) === null || _a === void 0 ? void 0 : _a.root.focus();\n  }\n  setFocusToPreviousItem(currentItem) {\n    var _a;\n    if (currentItem === this.firstItem) {\n      (_a = this.lastItem) === null || _a === void 0 ? void 0 : _a.root.focus();\n    } else {\n      const index = this.menuItemCollection.indexOf(currentItem);\n      this.menuItemCollection[index - 1].root.focus();\n    }\n  }\n  setFocusToNextItem(currentItem) {\n    var _a;\n    if (currentItem === this.lastItem) {\n      (_a = this.firstItem) === null || _a === void 0 ? void 0 :\n                                                        _a.root.focus();\n    } else {\n      const index = this.menuItemCollection.indexOf(currentItem);\n      this.menuItemCollection[index + 1].root.focus();\n    }\n  }\n  /**\n   * Closes the menu only when:\n   *  - A true force flag is passed in.\n   *  - The menu or its chlid menus do not have focus, and the menu does not\n   *    have hover, and when its controller is a menubar item, it is not\n   *    hovered.\n   */\n  close(force = false) {\n    var _a;\n    // True if the controller is a menubar item and it is hovered.\n    let controllerHasHover = false;\n    // True when this popup menu or any child popup menu is focused.\n    let hasFocus = this.hasFocus;\n    // Updates controllerHasHover flag for the menubar item.\n    if (this.controller.isMenubarItem) {\n      controllerHasHover = this.controller.hasHover;\n    }\n    if (!hasFocus) {\n      for (const item of this.menuItemCollection) {\n        hasFocus = hasFocus ||\n            !!((_a = item.popupMenu) === null || _a === void 0 ? void 0 :\n                                                                 _a.hasFocus);\n      }\n    }\n    if (force || (!hasFocus && !this.hasHover && !controllerHasHover)) {\n      this.root.classList.remove(CssClasses.MENU_OPEN);\n      this.controller.setExpanded(false);\n    }\n  }\n}\nexport {PopupMenu};\n","import {Component} from '../../base';\nimport {Attribute, Role} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\n/**\n * This class creates a child menu item component in a menu.\n * This menu item may/not control a popup menu.\n */\nclass MenuItem extends Component {\n  constructor(root, parentMenu) {\n    super(root);\n    this.parentMenu = parentMenu;\n    this.isMenubarItem = false;\n    /** The  popopMenu is the menu controlled by the menu item. */\n    this.popupMenu = null;\n    /**\n     * Handles keydown event on the menu item.\n     *\n     */\n    this.handleKeydown = (event) => {\n      let preventDefault = false;\n      const char = event.key;\n      function isPrintableCharacter(str) {\n        return str.length === 1 && str.match(/\\S/);\n      }\n      switch (event.key) {\n        case Key.SPACE:\n        case Key.ENTER:\n          if (this.popupMenu) {\n            this.popupMenu.open();\n            this.popupMenu.setFocusToFirstItem();\n          }\n          // Allows default behavior so it can trigger links.\n          preventDefault = false;\n          break;\n        case Key.UP:\n          this.parentMenu.setFocusToPreviousItem(this);\n          preventDefault = true;\n          break;\n        case Key.DOWN:\n          this.parentMenu.setFocusToNextItem(this);\n          preventDefault = true;\n          break;\n        case Key.LEFT:\n          // Returns if the controller does not have a parent menu\n          if (this.controllerWithoutParentMenu(this.parentMenu.controller)) {\n            return;\n          }\n          this.parentMenu.setFocusToController('previous');\n          this.parentMenu.close(true);\n          preventDefault = true;\n          break;\n        case Key.RIGHT:\n          // Returns if the controller does not have a parent menu\n          if (this.controllerWithoutParentMenu(this.parentMenu.controller)) {\n            return;\n          }\n          if (this.popupMenu) {\n            this.popupMenu.open();\n            this.popupMenu.setFocusToFirstItem();\n          } else {\n            this.parentMenu.setFocusToController('next');\n            this.parentMenu.close(true);\n          }\n          preventDefault = true;\n          break;\n        case Key.HOME:\n        case Key.PAGEUP:\n          this.parentMenu.setFocusToFirstItem();\n          preventDefault = true;\n          break;\n        case Key.END:\n        case Key.PAGEDOWN:\n          this.parentMenu.setFocusToLastItem();\n          preventDefault = true;\n          break;\n        case Key.ESC:\n          this.parentMenu.setFocusToController();\n          this.parentMenu.close(true);\n          preventDefault = true;\n          break;\n        case Key.TAB:\n          this.parentMenu.setFocusToController();\n          this.parentMenu.close(true);\n          break;\n        default:\n          if (isPrintableCharacter(char)) {\n            this.parentMenu.setFocusByFirstCharacter(this, char);\n            preventDefault = true;\n          }\n          break;\n      }\n      if (preventDefault) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    };\n    this.handleClick = () => {\n      this.parentMenu.setFocusToController();\n      this.parentMenu.close(true);\n    };\n    this.handleFocus = () => {\n      this.parentMenu.hasFocus = true;\n    };\n    this.handleBlur = () => {\n      this.parentMenu.hasFocus = false;\n      setTimeout(() => {\n        this.parentMenu.close(false);\n      }, 300);\n    };\n    this.handleMouseenter = () => {\n      var _a;\n      this.parentMenu.hasHover = true;\n      this.parentMenu.open();\n      if (this.popupMenu) {\n        this.popupMenu.hasHover = true;\n      }\n      (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.open();\n    };\n    this.handleMouseleave = () => {\n      var _a;\n      if (this.popupMenu) {\n        this.popupMenu.hasHover = false;\n      }\n      (_a = this.popupMenu) === null || _a === void 0 ? void 0 : _a.close(true);\n    };\n    this.init();\n  }\n  init() {\n    this.root.tabIndex = -1;\n    if (!this.root.getAttribute(Attribute.ROLE)) {\n      this.root.setAttribute(Attribute.ROLE, Role.MENUITEM);\n    }\n    this.root.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.addEventListener(EventType.CLICK, this.handleClick);\n    this.root.addEventListener(EventType.FOCUS, this.handleFocus);\n    this.root.addEventListener(EventType.BLUR, this.handleBlur);\n    this.root.addEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.addEventListener(EventType.MOUSELEAVE, this.handleMouseleave);\n  }\n  destroy() {\n    this.root.removeAttribute(Attribute.ROLE);\n    this.root.removeAttribute(Attribute.TAB_INDEX);\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.removeEventListener(EventType.CLICK, this.handleClick);\n    this.root.removeEventListener(EventType.FOCUS, this.handleFocus);\n    this.root.removeEventListener(EventType.BLUR, this.handleBlur);\n    this.root.removeEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.removeEventListener(EventType.MOUSELEAVE, this.handleMouseleave);\n  }\n  /** Assert this is a MenuItem */\n  controllerWithoutParentMenu(controller) {\n    return controller.parentMenu === null;\n  }\n  setExpanded(flag) {\n    if (flag) {\n      this.root.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n    } else {\n      this.root.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n    }\n  }\n}\nexport {MenuItem};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['COMPONENT'] = 'glue-header__site-switcher';\nCssClasses['MENU'] = 'glue-header__site-switcher-menu';\nCssClasses['MENU_ITEM'] = 'glue-header__item';\nCssClasses['MENU_LINK'] = 'glue-header__link';\nCssClasses['MENU_ITEM_DESCRIPTION'] =\n    'glue-header__site-switcher-item-description';\nCssClasses['MORE_PRODUCTS'] = 'glue-header__site-switcher-more-products';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['NO_ARIA_CONTROL'] =\n    'aria-control value is not set on the site switcher element.';\nStrings['NO_MENU'] = 'Header Site Switcher could not find a menu element.';\n})(Strings || (Strings = {}));\nexport {CssClasses, Strings};\n","import {Component} from '../../base/';\nimport {Attribute, Role} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {CssClasses as HeaderCssClasses} from '../constants';\nimport {CssClasses as DraweCssClasses, Strings as DrawerStrings,} from '../drawer/constants';\nimport {PopupMenu} from '../popupmenu';\n\nimport {Strings} from './constants';\n\n/**\n * This class creates a Site Switcher instance, it is triggered to show\n * a list of micro sites options.\n */\nclass SiteSwitcher extends Component {\n  constructor(root) {\n    super(root);\n    this.parentMenu = null;\n    /** A flag to show the switcher's focus status. */\n    this.hasFocus = false;\n    /** A flag to show switcher's hover status. */\n    this.hasHover = false;\n    /**\n     * A flag to indicate whether this element is a menubar item. Both the\n     * menubar item and site switcher can be dropdown trigger.\n     */\n    this.isMenubarItem = false;\n    /**\n     * Handles keydown events.\n     * When press the Space, Enter or Down keys, open the popup menu and focus\n     * to the first item. When press the Up key, open the popup menu and focus\n     * to the last item.\n     */\n    this.handleKeydown = (event) => {\n      let flag = false;\n      switch (event.key) {\n        case Key.SPACE:\n        case Key.ENTER:\n        case Key.DOWN:\n          this.popupMenu.open();\n          this.popupMenu.setFocusToFirstItem();\n          flag = true;\n          break;\n        case Key.UP:\n          this.popupMenu.open();\n          this.popupMenu.setFocusToLastItem();\n          flag = true;\n          break;\n        default:\n          break;\n      }\n      if (flag) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    };\n    /**\n     * Handles the click event.\n     * Toggles the menu when users click the site switcher.\n     */\n    this.handleClick = () => {\n      if (this.root.getAttribute(Attribute.ARIA_EXPANDED) === 'true') {\n        this.popupMenu.close(true);\n      } else {\n        this.popupMenu.open();\n        this.popupMenu.setFocusToFirstItem();\n      }\n    };\n    /**\n     * Sets hasFocus to true when the switcher is focused.\n     */\n    this.handleFocus = () => {\n      this.popupMenu.hasFocus = true;\n    };\n    /**\n     * Sets hasFocus to false when the switcher is blurred.\n     */\n    this.handleBlur = () => {\n      this.popupMenu.hasFocus = false;\n    };\n    /**\n     * Opens the menu and set hasHover to true when it is hovered.\n     */\n    this.handleMouseenter = (e) => {\n      this.hasHover = true;\n      this.popupMenu.open();\n    };\n    /**\n     * Waits for 300 mills to close the menu after moving mouse out of the\n     * switcher.\n     */\n    this.handleMouseLeave = () => {\n      this.hasHover = false;\n      setTimeout(() => {\n        this.popupMenu.close(false);\n      }, 300);\n    };\n    if (!this.root.getAttribute(Attribute.ARIA_CONTROLS)) {\n      throw new Error(Strings.NO_ARIA_CONTROL);\n    }\n    const menu = this.root.closest(`.${HeaderCssClasses.BAR_DESKTOP}`)\n                     .querySelector(\n                         '#' + this.root.getAttribute(Attribute.ARIA_CONTROLS));\n    if (!menu) {\n      throw new Error(Strings.NO_MENU);\n    }\n    this.popupMenu = new PopupMenu(menu, this);\n    this.init();\n  }\n  init() {\n    this.root.setAttribute(Attribute.ARIA_HASPOPUP, 'true');\n    this.root.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.addEventListener(EventType.CLICK, this.handleClick);\n    this.root.addEventListener(EventType.FOCUS, this.handleFocus);\n    this.root.addEventListener(EventType.BLUR, this.handleBlur);\n    this.root.addEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.addEventListener(EventType.MOUSELEAVE, this.handleMouseLeave);\n    this.root.setAttribute(Attribute.ROLE, Role.BUTTON);\n    this.root.tabIndex = 0;\n    const drawer = this.root.closest(`.${DraweCssClasses.ROOT}`);\n    drawer === null || drawer === void 0 ?\n        void 0 :\n        drawer.addEventListener(DrawerStrings.OPEN, () => {\n          for (const link of this.popupMenu.menuItemCollection) {\n            link.destroy();\n          }\n        });\n    drawer === null || drawer === void 0 ?\n        void 0 :\n        drawer.addEventListener(DrawerStrings.CLOSE, () => {\n          for (const link of this.popupMenu.menuItemCollection) {\n            link.init();\n          }\n        });\n  }\n  destroy() {\n    this.root.removeAttribute(Attribute.ARIA_HASPOPUP);\n    this.root.removeAttribute(Attribute.ROLE);\n    this.root.removeAttribute(Attribute.TAB_INDEX);\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.root.removeEventListener(EventType.CLICK, this.handleClick);\n    this.root.removeEventListener(EventType.FOCUS, this.handleFocus);\n    this.root.removeEventListener(EventType.BLUR, this.handleBlur);\n    this.root.removeEventListener(EventType.MOUSEENTER, this.handleMouseenter);\n    this.root.removeEventListener(EventType.MOUSELEAVE, this.handleMouseLeave);\n  }\n  /** Sets the expanded attribute when the menu is open. */\n  setExpanded(flag) {\n    this.root.setAttribute(Attribute.ARIA_EXPANDED, flag.toString());\n  }\n}\nexport {SiteSwitcher};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-header__stepped-nav';\nCssClasses['CONTROLS_CONTAINER'] =\n    'glue-header__stepped-nav-controls-container';\nCssClasses['CONTROLS'] = 'glue-header__stepped-nav-controls';\nCssClasses['CONTROLS_ARROW'] = 'glue-header__stepped-nav-controls-arrow';\nCssClasses['CONTROLS_TITLE'] = 'glue-header__stepped-nav-controls-title';\nCssClasses['MENU_CONTAINER'] = 'glue-header__stepped-nav-menus';\nCssClasses['SUBNAV_ICON'] = 'glue-header__stepped-nav-subnav-icon';\nCssClasses['PARENT_POSITION'] = 'glue-header__stepped-nav-parent-position';\nCssClasses['PAGE'] = 'glue-stepped-page';\nCssClasses['PAGES'] = 'glue-stepped-pages';\n})(CssClasses || (CssClasses = {}));\nvar Attributes;\n(function(Attributes) {\nAttributes['PARENT_INDEX'] = 'data-glue-stepped-nav-parent-index';\nAttributes['PARENT_INDEX_CAMEL'] = 'glueSteppedNavParentIndex';\nAttributes['STEPPED_PAGE'] = 'data-glue-stepped-page';\nAttributes['STEPPED_PAGE_CAMEL'] = 'glueSteppedPage';\nAttributes['STEPPEDNAV_LABEL'] = 'glueSteppednavLabel';\n})(Attributes || (Attributes = {}));\nvar Strings;\n(function(Strings) {\nStrings['CURRENT_PAGE'] = 'currentPage';\nStrings['TOTAL_PAGES'] = 'totalPages';\nStrings['NEXT_EVENT'] = 'nextPage';\nStrings['CONTROLS_MODEL_ID'] = 'stepped-nav-controls';\nStrings['MISSING_CONTROLS'] =\n    'Some of the Stepped Nav controls elements are missing.';\nStrings['MISSING_PAGES_CONT'] =\n    'The container element for Stepped Nav Pages is missing.';\nStrings['MISSING_LINK_BAR'] =\n    'Stepped Nav can\\'t find the Link Bar Header element.';\nStrings['STEPPED_PAGE'] = 'glue-stepped-page';\nStrings['STEPPED_NAV_LABEL_VAR_NAME'] = '$glue_steppednav_label$';\nStrings['STEPPEDNAV_LABEL'] =\n    '$glue_steppednav_label$, Navigate back to parent menu, $glue_steppednav_label$ opened';\n})(Strings || (Strings = {}));\nexport {Attributes, CssClasses, Strings};\n","import {Component} from '../../base/';\nimport {Attribute, Attribute as GlueAttribute, Role, TabIndex,} from '../../constants/attribute';\nimport {EventType} from '../../events/eventtype';\nimport {Key} from '../../events/key';\nimport {Observer} from '../../observer';\nimport {CssClasses as HeaderCssClasses} from '../constants';\n\nimport {Attributes, CssClasses, Strings} from './constants';\nimport {Pages} from './pages';\n\nclass SteppedNav extends Component {\n  /**\n   * Get the element for the Stepped Nav. Useful in detemining if the\n   * element is present.\n   * @param root The element in which to look.\n   * @return A stepped nav root element if present.\n   */\n  static getSteppedNavElement(root) {\n    return root.querySelector(`.${CssClasses.ROOT}`);\n  }\n  constructor(root) {\n    super(root);\n    this.activeInitPageIndex = 1;\n    this.modelDefaults = {\n      currentPage: 1,\n      totalPages: 0,\n    };\n    this.handleKeyPress = (evt) => {\n      this.keyPress(evt);\n    };\n    this.handleClick = (evt) => {\n      var _a;\n      if (evt.target instanceof Element) this.selectPage(evt.target);\n      // When the user clicks on a link that is a pointer to anther page, do not\n      // follow the link href.\n      if (evt.target instanceof HTMLAnchorElement &&\n          ((_a = evt.target.parentElement) === null || _a === void 0 ?\n               void 0 :\n               _a.hasAttribute(Attributes.STEPPED_PAGE))) {\n        evt.preventDefault();\n      }\n    };\n    this.updateHandler = () => {\n      // Set the active element to the container so event listeners will pick\n      // up events.\n      this.root.focus();\n    };\n    // Set up the data model.\n    this.observer = new Observer(Object.assign({}, this.modelDefaults));\n    this.model = this.observer.data;\n    // Sets up the oage containers that will be used for the Menus.\n    this.initMenuPages();\n    // Sets up the controls containers.\n    this.initControls();\n    // Build a menu list out of the existing menu structure. Must be called\n    // after the controls and menu pages are initialized.\n    this.buildPagesFromNav();\n    // Init the active page if it's not the default first page.\n    // This must happen after the Pages is created because\n    // the page model needs to know how many pages there are.\n    this.model.currentPage = this.activeInitPageIndex;\n    // Designate this as a navigation element.\n    this.root.setAttribute(GlueAttribute.ROLE, Role.NAVIGATION);\n    this.root.tabIndex = Number(TabIndex.TABBABLE);\n    this.root.addEventListener(EventType.CLICK, this.handleClick);\n    this.root.addEventListener(EventType.KEYDOWN, this.handleKeyPress);\n    this.observer.listen(Strings.CURRENT_PAGE, this.updateHandler);\n  }\n  /**\n   * Initialize the menu Page containers.\n   */\n  initMenuPages() {\n    // Set the page attributes of the stepped menu container.\n    this.pagesContainer =\n        this.root.querySelector(`.${CssClasses.MENU_CONTAINER}`);\n    if (!this.pagesContainer) throw new Error(Strings.MISSING_PAGES_CONT);\n    this.pagesContainer.classList.add(CssClasses.PAGES);\n  }\n  /**\n   * Initialize the controls over the Pages.\n   */\n  initControls() {\n    this.steppedControlsContainer =\n        this.root.querySelector(`.${CssClasses.CONTROLS_CONTAINER}`);\n    this.steppedControls = this.root.querySelector(`.${CssClasses.CONTROLS}`);\n    this.steppedControlsTitle =\n        this.root.querySelector(`.${CssClasses.CONTROLS_TITLE}`);\n    if (!this.steppedControlsContainer || !this.steppedControls ||\n        !this.steppedControlsTitle) {\n      throw new Error(Strings.MISSING_CONTROLS);\n    }\n    this.steppedControls.remove();\n    // Grab the subnav icon from the controls for later use - and remove it.\n    this.subnavIcon =\n        this.steppedControls.querySelector(`.${CssClasses.SUBNAV_ICON}`);\n    if (this.subnavIcon) this.subnavIcon.remove();\n    this.steppedControls.classList.add(CssClasses.PAGE);\n  }\n  /**\n   * Initialize all the menu pages. This adds them to the menu container and\n   * sets up page and controls for UI actions.\n   * @return activePageIndex {number}\n   */\n  buildPagesFromNav() {\n    var _a, _b;\n    // Clone the existing menu structure.\n    const linkBar = (_a = this.root.parentElement) === null || _a === void 0 ?\n        void 0 :\n        _a.querySelector(`.${HeaderCssClasses.LINK_BAR}`);\n    if (!linkBar) throw new Error(Strings.MISSING_LINK_BAR);\n    const rootMenu =\n        (_b = linkBar.firstElementChild) === null || _b === void 0 ?\n        void 0 :\n        _b.cloneNode(true);\n    // Start the recursive search with the root menu.\n    if (rootMenu instanceof HTMLElement) this.harvestMenu(rootMenu);\n    // Create Pages from the pages and controls containers. This\n    // must be done after the pages are built.\n    this.menuPages = new Pages(this.pagesContainer, this.observer);\n    this.controlsPages =\n        new Pages(this.steppedControlsContainer, this.observer);\n    this.model.totalPages = this.pagesContainer.children.length;\n  }\n  /**\n   * Harvest a menu element. Creates a new page in the stepped nav.\n   * @param menuElement The menu Element to look in.\n   * @param menuParentTitle  The title of the menu parent.\n   * @return The index of this menu page.\n   */\n  harvestMenu(menuElement, parentIndex, menuParentTitle = '') {\n    // Set Page properties of the new menu clone, make it a page\n    // and add it to the menu container as a new page.\n    menuElement.classList.add(CssClasses.PAGE);\n    this.pagesContainer.appendChild(menuElement);\n    // Build and add the controls for this menu.\n    this.steppedControlsTitle.textContent = menuParentTitle;\n    const controlsElem = this.steppedControls.cloneNode(true);\n    controlsElem.classList.add(HeaderCssClasses.LINK_ITEM);\n    if (menuElement.classList.contains(CssClasses.PARENT_POSITION)) {\n      controlsElem.classList.add(CssClasses.PARENT_POSITION);\n    }\n    if (parentIndex) {\n      // Set the controls page to the index of the parent menu.\n      controlsElem.dataset[Attributes.PARENT_INDEX_CAMEL] = String(parentIndex);\n      // Set the parent index of the stepped page for positioning.\n      menuElement.dataset[Attributes.PARENT_INDEX_CAMEL] = String(parentIndex);\n    }\n    // Set the tab index so this element is focusable.\n    controlsElem.tabIndex = Number(TabIndex.NOT_TABBABLE);\n    this.steppedControlsContainer.appendChild(controlsElem);\n    // Harvest the menu children to look for more menus.\n    const thisMenuPageIndex = this.pagesContainer.children.length;\n    for (const menuItem of Array.from(menuElement.children)) {\n      if (menuItem instanceof HTMLElement) {\n        this.harvestListItem(thisMenuPageIndex, menuItem);\n      }\n      // Put this menu in the right position if the list item is active.\n      if (menuItem.classList.contains(HeaderCssClasses.ACTIVE_MENU)) {\n        menuElement.classList.add(CssClasses.PARENT_POSITION);\n        controlsElem.classList.add(CssClasses.PARENT_POSITION);\n      }\n    }\n    // Set role and aria-label for accessibility purposes.\n    if (menuParentTitle) {\n      const labelTemplate = controlsElem.dataset[Attributes.STEPPEDNAV_LABEL] ||\n          Strings.STEPPEDNAV_LABEL;\n      const navLabel = labelTemplate.replaceAll(\n          Strings.STEPPED_NAV_LABEL_VAR_NAME, menuParentTitle);\n      controlsElem.setAttribute(Attribute.ARIA_LABEL, navLabel);\n      controlsElem.setAttribute(Attribute.ROLE, Role.BUTTON);\n    }\n    // Return the index of this menu.\n    return thisMenuPageIndex;\n  }\n  /**\n   * Harvest a menu list item element. If it finds a menu, it is harvested\n   * via harvestMenu();\n   * @param parentMenuPageIndex The index of the parent menu.\n   * @param listItemElement The menu list item element.\n   */\n  harvestListItem(parentMenuPageIndex, listItemElement) {\n    var _a;\n    const subMenuElement = this.getChildOfNodeType(listItemElement, 'UL');\n    const linkElement = this.getChildOfNodeType(listItemElement, 'A');\n    // See if this is a leaf node (i.e. if it doesn't have a submenu.)\n    // If it's active, we've found the currently active page.\n    if (!subMenuElement &&\n        listItemElement.classList.contains(HeaderCssClasses.ACTIVE_LINK)) {\n      this.activeInitPageIndex = parentMenuPageIndex;\n    }\n    // Make the link not tabbable.\n    if (linkElement) {\n      linkElement.tabIndex = Number(TabIndex.NOT_TABBABLE);\n    }\n    if (!subMenuElement || !linkElement) return;\n    // Take this submenu out of the li so it doesn't appear in the UI.\n    subMenuElement.remove();\n    // Since this is a submenu node, get the anchor element and submenu\n    // and make a new page out of it.\n    const menuElementPageIndex = this.harvestMenu(\n        subMenuElement, parentMenuPageIndex,\n        (_a = linkElement.textContent) === null || _a === void 0 ? void 0 :\n                                                                   _a.trim());\n    // Set the pointer to the page this link points to.\n    listItemElement.dataset[Attributes.STEPPED_PAGE_CAMEL] =\n        String(menuElementPageIndex);\n    // Remove any svg that was there from the deep nav. Add the correct svg.\n    const existingArrow = this.getChildOfNodeType(linkElement, 'svg');\n    existingArrow === null || existingArrow === void 0 ? void 0 :\n                                                         existingArrow.remove();\n    if (this.subnavIcon) {\n      linkElement.appendChild(this.subnavIcon.cloneNode(true));\n    }\n  }\n  /**\n   * Moves the page model to the next or previous page when the user uses\n   * the enter, space or directional keys.\n   */\n  keyPress(evt) {\n    const target = evt.target;\n    const isRtl = !!this.root.closest('[dir=rtl]');\n    // Selectable Elements are whichever elements are selectable via arrow\n    // navigation in each of the groups of pages.\n    const selectableElements = this.controlsPages.selectableElements.concat(\n        this.menuPages.selectableElements);\n    const selectedIndex = selectableElements.indexOf(document.activeElement);\n    switch (evt.key) {\n      case Key.ENTER:\n      case Key.SPACE:\n        this.selectPage(target);\n        break;\n      case Key.LEFT:\n        isRtl ? this.selectSubPage(target) : this.selectParentPage();\n        break;\n      case Key.RIGHT:\n        isRtl ? this.selectParentPage() : this.selectSubPage(target);\n        break;\n      case Key.UP:\n        selectedIndex > 0 ?\n            selectableElements[selectedIndex - 1].focus() :\n            selectableElements[selectableElements.length - 1].focus();\n        break;\n      case Key.DOWN:\n        selectedIndex >= selectableElements.length - 1 ?\n            selectableElements[0].focus() :\n            selectableElements[selectedIndex + 1].focus();\n        break;\n      case Key.HOME:\n        selectableElements[0].focus();\n        break;\n      case Key.END:\n        selectableElements[selectableElements.length - 1].focus();\n        break;\n      default:\n    }\n  }\n  /**\n   * Handle a select action without a forward/back direction.\n   */\n  selectPage(elem) {\n    // If it's in the controls container, then it's a parent page select action.\n    if (this.steppedControlsContainer.contains(elem)) {\n      this.selectParentPage();\n    } else {\n      this.selectSubPage(elem);\n    }\n  }\n  /**\n   * Handle when a new page has been selected from a submenu element action.\n   */\n  selectSubPage(elem) {\n    // Find parent elem that is either a controls element or a subnav element.\n    const dataElem = elem.closest(`[${Attributes.STEPPED_PAGE}]`);\n    if (dataElem) {\n      const pageIndex = Number(\n          dataElem === null || dataElem === void 0 ?\n              void 0 :\n              dataElem.dataset[Attributes.STEPPED_PAGE_CAMEL]);\n      this.model.currentPage = pageIndex;\n    }\n  }\n  /**\n   * Handle when we should go to the parent page of an elem.\n   */\n  selectParentPage() {\n    // Find parent element where the attribute is either parent or a stepped\n    // page.\n    const parentPageIndex = this.controlsPages.getCurrentPageParentIndex();\n    this.model.currentPage = parentPageIndex;\n  }\n  /**\n   * Get a child element from a parent of a specified type.\n   * @param parent The element to look in.\n   * @param type The type of node to get e.g. 'UL'\n   * @return The first child of that type or undefined if not found.\n   */\n  getChildOfNodeType(parent, type) {\n    return Array.from(parent.children).find((el) => el.nodeName === type);\n  }\n  destroy() {\n    if (this.menuPages) this.menuPages.destroy();\n    if (this.controlsPages) this.controlsPages.destroy();\n    this.observer.unlisten(Strings.CURRENT_PAGE, this.updateHandler);\n    this.root.removeEventListener(EventType.CLICK, this.handleClick);\n    this.root.removeEventListener(EventType.KEYDOWN, this.handleKeyPress);\n    for (const node of this.pagesContainer.childNodes) {\n      this.pagesContainer.removeChild(node);\n    }\n    for (const node of this.steppedControlsContainer.childNodes) {\n      this.steppedControlsContainer.removeChild(node);\n    }\n    this.steppedControls.removeEventListener(EventType.CLICK, this.handleClick);\n    this.steppedControls.removeEventListener(\n        EventType.KEYDOWN, this.handleKeyPress);\n  }\n}\nexport {SteppedNav};\n","import {Component} from '../../base/';\nimport {Attribute as AttributeConst} from '../../constants/attribute';\nimport {CssClasses as GlueCssClasses} from '../../constants/classes';\nimport {CssClasses as HeaderCssClasses} from '../constants';\n\nimport {Attributes, CssClasses, Strings} from './constants';\n\n/**\n * Glue Page component\n */\nclass Pages extends Component {\n  /**\n   * @param root Root element that contains options object\n   * @param model A shared model for paginating.\n   */\n  constructor(root, observer) {\n    super(root);\n    this.observer = observer;\n    this.pageEls = Array.from(this.root.children);\n    this.elementIds = [];\n    this.selectableElements = [];\n    this.handleUpdate = () => {\n      this.update();\n    };\n    this.initialize();\n  }\n  /**\n   * Initialize the component.\n   */\n  initialize() {\n    this.observer.listen(Strings.CURRENT_PAGE, this.handleUpdate);\n    this.model = this.observer.data;\n    this.initPageElementIDs();\n    this.update();\n  }\n  /**\n   * Set IDs for all elements.\n   */\n  initPageElementIDs() {\n    let pageElementId;\n    for (const [index, pageEl] of this.pageEls.entries()) {\n      pageElementId =\n          `${Strings.STEPPED_PAGE}-${Math.round(Math.random() * 99999999)}`;\n      pageEl.id = pageElementId;\n      pageEl.classList.add(`${Strings.STEPPED_PAGE}-${index + 1}`);\n      if (!this.elementIds[index + 1]) {\n        this.elementIds[index + 1] = pageElementId;\n      }\n    }\n  }\n  /**\n   * Updates CSS classes, ARIA properties and event handlers on page elements.\n   */\n  update() {\n    // Recursively positions page elements based on parent page indexes.\n    const positionPage = (elem) => {\n      // A page will either have a parent index or page index attr that points\n      // to the page that ought to be in the parent position in the UI.\n      const parentPageIndex = elem.hasAttribute(Attributes.STEPPED_PAGE) ?\n          Number(elem.dataset[Attributes.STEPPED_PAGE_CAMEL]) :\n          Number(elem.dataset[Attributes.PARENT_INDEX_CAMEL]);\n      if (isNaN(parentPageIndex)) return;\n      const parentElem = this.pageEls[parentPageIndex - 1];\n      parentElem === null || parentElem === void 0 ?\n          void 0 :\n          parentElem.classList.add(CssClasses.PARENT_POSITION);\n      positionPage(parentElem);\n    };\n    const currentElem = this.pageEls[this.model.currentPage - 1];\n    for (const pageElem of this.pageEls) {\n      const selected = pageElem === currentElem;\n      if (selected) {\n        pageElem.classList.add(GlueCssClasses.SHOW);\n        pageElem.removeAttribute(AttributeConst.ARIA_HIDDEN);\n      } else {\n        pageElem.classList.remove(\n            GlueCssClasses.SHOW, CssClasses.PARENT_POSITION);\n        pageElem.setAttribute(AttributeConst.ARIA_HIDDEN, 'true');\n      }\n      this.updatePageElements(pageElem);\n    }\n    // Get all the page elements that might be selectable for key-based nav.\n    if (currentElem.classList.contains(CssClasses.CONTROLS)) {\n      this.selectableElements =\n          currentElem.hasAttribute(Attributes.PARENT_INDEX) ? [currentElem] :\n                                                              [];\n    } else {\n      this.selectableElements = Array.from(\n          currentElem.querySelectorAll(`.${HeaderCssClasses.LINK_ITEM}`));\n    }\n    // Set the positions of the pages that are parents of the current page.\n    positionPage(currentElem);\n  }\n  /**\n   * Updates the DOM attributes.\n   */\n  updatePageElements(pageElem) {\n    const children = Array.from(pageElem.children);\n    // Set attributes of the links or submenu elements in the page.\n    for (const elem of children) {\n      if (!elem.hasAttribute(Attributes.STEPPED_PAGE)) continue;\n      // The 'haspopup' aria attribute marks an item that has a sub-menu to\n      // to differentiate it from the simple link elements.\n      elem.setAttribute(AttributeConst.ARIA_HASPOPUP, 'true');\n      // The 'selected' aria attribute indicates it's the active page.\n      elem.setAttribute(\n          AttributeConst.ARIA_SELECTED,\n          String(elem.classList.contains(HeaderCssClasses.ACTIVE_MENU)));\n      // Connect the aria controls attr with the controls index.\n      if (elem instanceof HTMLElement) {\n        const pageId = Number(elem.dataset[Attributes.STEPPED_PAGE_CAMEL]);\n        elem.setAttribute(\n            AttributeConst.ARIA_CONTROLS, this.elementIds[pageId]);\n      }\n    }\n  }\n  /**\n   * Gets current page parent page index.\n   */\n  getCurrentPageParentIndex() {\n    const pageElem = this.pageEls[this.model.currentPage - 1];\n    const index = Number(pageElem.dataset[Attributes.PARENT_INDEX_CAMEL]);\n    return isNaN(index) ? 1 : index;\n  }\n  destroy() {\n    for (const pageElem of this.pageEls) {\n      pageElem.classList.remove(\n          GlueCssClasses.SHOW, CssClasses.PARENT_POSITION);\n      pageElem.id = '';\n    }\n    this.observer.unlisten(Strings.CURRENT_PAGE, this.handleUpdate);\n  }\n}\nexport {Pages};\n","/**\n * @fileoverview Constants used by the Jumplinks component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['BUTTON'] = 'glue-jumplinks__button';\nCssClasses['BUTTON_LEFT'] = 'glue-jumplinks__button--prev';\nCssClasses['BUTTON_RIGHT'] = 'glue-jumplinks__button--next';\nCssClasses['BUTTON_ACTIVE'] = 'glue-jumplinks__button--active';\nCssClasses['LIST'] = 'glue-jumplinks__list';\nCssClasses['ITEMS'] = 'glue-jumplinks__list-item';\nCssClasses['LINK'] = 'glue-jumplinks__link';\nCssClasses['LINK_ACTIVE'] = 'glue-jumplinks__link--active';\nCssClasses['VIEWPORT'] = 'glue-jumplinks__viewport';\nCssClasses['REWIND'] = 'glue-jumplinks--rewind';\nCssClasses['ROOT'] = 'glue-jumplinks';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['LI_WIDTH'] = 'liWidth';\nStrings['VIEWPORT'] = 'viewport';\nStrings['PAGE_X'] = 'pageX';\nStrings['SLIDES'] = 'slides';\nStrings['ACTIVE_LINK'] = 'activeLink';\nStrings['RTL'] = 'rtl';\nStrings['TRANSFORM'] = 'transform';\nStrings['BLOCK'] = 'block';\nStrings['FIXED'] = 'fixed';\nStrings['JUMPLINK_DEFAULT_LABEL'] = 'Jump to section within page';\nStrings['NOT_FIXED'] = 'absolute';\nStrings['NO_ANIMATION'] = 'none';\n})(Strings || (Strings = {}));\nvar Numbers;\n(function(Numbers) {\nNumbers[Numbers['DEFAULT_OFFSET'] = 144] = 'DEFAULT_OFFSET';\nNumbers[Numbers['JUMPLINKS_MARGIN'] = 16] = 'JUMPLINKS_MARGIN';\nNumbers[Numbers['JUMPLINKS_HEIGHT'] = 48] = 'JUMPLINKS_HEIGHT';\nNumbers[Numbers['SCROLL_THRESHOLD'] = 130] = 'SCROLL_THRESHOLD';\n})(Numbers || (Numbers = {}));\nvar DataAttr;\n(function(DataAttr) {\nDataAttr['JUMPLINK_LABEL'] = 'glueJumplinkLabel';\n})(DataAttr || (DataAttr = {}));\nexport {CssClasses, DataAttr, Numbers, Strings};\n","import {Component} from '../base/index';\nimport {Attribute, TabIndex} from '../constants/attribute';\nimport {easeInOutQuart} from '../easing/';\nimport {EventType} from '../events/eventtype';\nimport * as focusUtil from '../focus/';\nimport {Observer} from '../observer';\nimport {ScrollEventType} from '../smoothscroll/constants';\nimport {ScrollManager} from '../smoothscroll/scrollmanager';\n\nimport {CssClasses, DataAttr, Numbers, Strings} from './constants';\n\nclass Jumplinks extends Component {\n  constructor(root, options) {\n    super(root);\n    this.linkTargets = [];\n    this.lastScrollPosition = 0;\n    this.isScrolling = false;\n    this.handleClick = (e) => {\n      this.clickHandler(e);\n    };\n    this.handleActiveLinkChange = () => {\n      this.activeLinkChangeHandler();\n    };\n    this.handleScroll = () => {\n      this.scrollHandler();\n    };\n    this.handleResize = () => {\n      this.resizeHandler();\n    };\n    this.handleLinkFocus = (e) => {\n      this.focusLinkHandler(e);\n    };\n    this.handleHorizontalScroll = () => {\n      this.updateButtons();\n    };\n    let element = this.root.querySelector(`.${CssClasses.LIST}`);\n    if (!element) {\n      throw new Error('Jumplinks List element is missing.');\n    } else {\n      this.list = element;\n    }\n    element = this.root.querySelector(`.${CssClasses.BUTTON_LEFT}`);\n    if (!element) {\n      throw new Error('Jumplinks left button element is missing.');\n    } else {\n      this.prevButton = element;\n    }\n    element = this.root.querySelector(`.${CssClasses.BUTTON_RIGHT}`);\n    if (!element) {\n      throw new Error('Jumplinks right button element is missing.');\n    } else {\n      this.nextButton = element;\n    }\n    this.listItems =\n        Array.from(this.root.querySelectorAll(`.${CssClasses.ITEMS}`));\n    if (this.listItems.length === 0) {\n      throw new Error('Jumplinks list item is missing.');\n    }\n    this.links = Array.from(this.root.querySelectorAll(`.${CssClasses.LINK}`));\n    if (this.links.length === 0) {\n      throw new Error('Jumplinks link item is missing.');\n    }\n    this.options = Object.assign(\n        {}, {\n          offset: Numbers.DEFAULT_OFFSET,\n          belowHeader: false,\n        },\n        options);\n    this.smoothScroll = new ScrollManager();\n    this.observer = new Observer({\n      activeLink: '',\n    });\n    this.leftWatchPoint =\n        this.root.getBoundingClientRect().x + this.prevButton.offsetWidth;\n    this.rightWatchPoint = this.leftWatchPoint + this.list.offsetWidth;\n    this.initialize();\n  }\n  initialize() {\n    this.setAttributes();\n    this.updateButtons();\n    this.getLinkTargets();\n    this.registerListeners();\n    this.createIntersectionObserver();\n  }\n  createIntersectionObserver() {\n    const options = {\n      root: null,\n      rootMargin: `-${Math.floor(window.innerHeight / 2)}px 0px`,\n      threshold: 0,\n    };\n    const observer = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting) {\n          this.setActiveLink(entry.target.id);\n        } else {\n          if (entry.target.id === this.getActiveLink()) {\n            this.reset();\n          }\n        }\n      }\n    }, options);\n    for (const element of this.linkTargets) {\n      observer.observe(element);\n    }\n  }\n  /**\n   */\n  destroy() {\n    this.deregisterListeners();\n  }\n  setAttributes() {\n    /**\n     * Gets localized text to be appended to jump links 'aria label'\n     * if it exists or else uses default string.\n     */\n    const jumplinkList = this.root.querySelector(`.${CssClasses.LIST}`);\n    const labelText = jumplinkList.dataset[DataAttr.JUMPLINK_LABEL] ||\n        Strings.JUMPLINK_DEFAULT_LABEL;\n    this.root.setAttribute(Attribute.ROLE, 'navigation');\n    for (const link of this.links) {\n      link.setAttribute(Attribute.ARIA_LABEL, `${link.text} - ${labelText}`);\n    }\n    for (const button of [this.prevButton, this.nextButton]) {\n      button.tabIndex = TabIndex.NOT_TABBABLE;\n      button.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    }\n  }\n  setActiveLink(id) {\n    this.observer.data['activeLink'] = id;\n  }\n  getActiveLink() {\n    return this.observer.data['activeLink'];\n  }\n  getLinkTargets() {\n    for (const link of this.links) {\n      const hash = link.hash.substring(1);\n      const target = document.querySelector(`#${hash}`);\n      if (!target) {\n        throw new Error(`Element with id \"${hash}\" does not exist.`);\n      }\n      this.linkTargets.push(target);\n    }\n  }\n  registerListeners() {\n    this.root.addEventListener(EventType.CLICK, this.handleClick);\n    const throttle = (func, limit) => {\n      let inThrottle;\n      return (...args) => {\n        if (!inThrottle) {\n          func.apply(this, args);\n          inThrottle = true;\n          setTimeout(() => (inThrottle = false), limit);\n        }\n      };\n    };\n    this.list.addEventListener(EventType.SCROLL, this.handleHorizontalScroll);\n    document.addEventListener(\n        EventType.SCROLL, throttle(this.handleScroll, 16));\n    window.addEventListener(EventType.RESIZE, this.handleResize);\n    this.observer.listen(Strings.ACTIVE_LINK, this.handleActiveLinkChange);\n    document.addEventListener(ScrollEventType.ENDSCROLL, () => {\n      this.isScrolling = false;\n      this.updateTopOffset();\n    });\n    for (const link of this.links) {\n      link.addEventListener(EventType.FOCUS, this.handleLinkFocus);\n    }\n  }\n  deregisterListeners() {\n    this.root.removeEventListener(EventType.CLICK, this.handleClick);\n    this.list.removeEventListener(\n        EventType.SCROLL, this.handleHorizontalScroll);\n    window.removeEventListener(EventType.SCROLL, this.handleScroll);\n    window.removeEventListener(EventType.RESIZE, this.handleResize);\n    this.observer.unlisten(Strings.ACTIVE_LINK, this.handleActiveLinkChange);\n    for (const link of this.links) {\n      link.removeEventListener(EventType.FOCUS, this.handleLinkFocus);\n    }\n  }\n  focusLinkHandler(e) {\n    if (e.target && e.target instanceof Element) {\n      this.updateButtons();\n    }\n  }\n  /**\n   * Click handler for all component buttons, via event delegation\n   */\n  clickHandler(e) {\n    e.preventDefault();\n    const clickTarget = e.target;\n    let target;\n    if (clickTarget === this.prevButton) {\n      target = this.isRTL() ? this.getPartialLink('next') :\n                              this.getPartialLink('prev');\n      target.scrollIntoView({\n        behavior: 'auto',\n        block: 'nearest',\n        inline: 'end',\n      });\n    } else if (clickTarget === this.nextButton) {\n      target = this.isRTL() ? this.getPartialLink('prev') :\n                              this.getPartialLink('next');\n      target.scrollIntoView({\n        behavior: 'auto',\n        block: 'nearest',\n        inline: 'start',\n      });\n    } else if (\n        clickTarget instanceof HTMLAnchorElement &&\n        this.links.includes(clickTarget)) {\n      target = clickTarget;\n      const hash = target.hash.substring(1);\n      const defaultScrollY = this.options.offset + Numbers.JUMPLINKS_HEIGHT +\n          Numbers.JUMPLINKS_MARGIN;\n      const midHeight = Math.floor(window.innerHeight / 2);\n      const scrollY = defaultScrollY > midHeight ? midHeight : defaultScrollY;\n      const targetElement = document.querySelector(`#${hash}`);\n      this.smoothScroll.startScroll(targetElement, {\n        'duration': 600,\n        'easing': easeInOutQuart,\n        'direction': 'both',\n        'hash': true,\n        'offset': {\n          'x': 0,\n          'y': scrollY,\n        },\n      });\n      this.isScrolling = true;\n      const isFocusable = focusUtil.isElementFocusable(targetElement);\n      // Set tabindex = -1 to non-focusable element, so focus() is able to\n      // move focus to the element.\n      if (!isFocusable) {\n        targetElement.tabIndex = TabIndex.NOT_TABBABLE;\n      }\n      targetElement.focus();\n    }\n    this.updateButtons();\n  }\n  /*\n   * Return the link element that is partially visible.\n   */\n  getPartialLink(direction) {\n    let watchPoint;\n    direction === 'prev' ? (watchPoint = this.leftWatchPoint) :\n                           (watchPoint = this.rightWatchPoint);\n    for (const link of this.links) {\n      const bounding = link.getBoundingClientRect();\n      if (bounding.x < watchPoint && bounding.x + bounding.width > watchPoint) {\n        return link;\n      }\n    }\n    return this.links[0];\n  }\n  reset() {\n    this.setActiveLink('');\n  }\n  activeLinkChangeHandler() {\n    this.renderActiveLink();\n    const hash = this.getActiveLink();\n    if (hash !== '') {\n      const activeEl = this.links.find((link) => link.hash === `#${hash}`);\n      // Scroll the link element into view\n      activeEl === null || activeEl === void 0 ? void 0 :\n                                                 activeEl.scrollIntoView({\n                                                   behavior: 'auto',\n                                                   block: 'nearest',\n                                                   inline: 'center',\n                                                 });\n    }\n    this.updateButtons();\n  }\n  scrollHandler() {\n    if (this.isScrolling === true) {\n      return;\n    }\n    this.updateTopOffset();\n  }\n  resizeHandler() {\n    /**\n     * TODO: add test case to verify whether the active class is applied to the\n     * prev or next button on resize.\n     */\n    this.leftWatchPoint =\n        this.root.getBoundingClientRect().x + this.prevButton.offsetWidth;\n    this.rightWatchPoint = this.leftWatchPoint + this.list.offsetWidth;\n    this.updateButtons();\n  }\n  // Show and hide prev/next buttons\n  updateButtons() {\n    this.prevButton.classList.remove(CssClasses.BUTTON_ACTIVE);\n    this.nextButton.classList.remove(CssClasses.BUTTON_ACTIVE);\n    if (this.isRTL()) {\n      if (this.list.scrollLeft < 0) {\n        this.prevButton.classList.add(CssClasses.BUTTON_ACTIVE);\n      }\n      if (this.list.scrollWidth + this.list.scrollLeft - this.list.clientWidth >\n          10) {\n        this.nextButton.classList.add(CssClasses.BUTTON_ACTIVE);\n      }\n    } else {\n      if (this.list.scrollLeft > 0) {\n        this.prevButton.classList.add(CssClasses.BUTTON_ACTIVE);\n      }\n      if (this.list.scrollWidth - this.list.scrollLeft - this.list.clientWidth >\n          10) {\n        this.nextButton.classList.add(CssClasses.BUTTON_ACTIVE);\n      }\n    }\n  }\n  /**\n   * Set active link via hash\n   */\n  renderActiveLink() {\n    const id = this.getActiveLink();\n    const currentActiveLink = this.links.find((link) => link.hash === `#${id}`);\n    const prevActiveLink =\n        this.root.querySelector(`.${CssClasses.LINK_ACTIVE}`);\n    prevActiveLink === null || prevActiveLink === void 0 ?\n        void 0 :\n        prevActiveLink.classList.remove(CssClasses.LINK_ACTIVE);\n    prevActiveLink === null || prevActiveLink === void 0 ?\n        void 0 :\n        prevActiveLink.removeAttribute(Attribute.ARIA_CURRENT);\n    currentActiveLink === null || currentActiveLink === void 0 ?\n        void 0 :\n        currentActiveLink.classList.add(CssClasses.LINK_ACTIVE);\n    currentActiveLink === null || currentActiveLink === void 0 ?\n        void 0 :\n        currentActiveLink.setAttribute(Attribute.ARIA_CURRENT, 'true');\n  }\n  /**\n   * Updates vertical offset of the Jumplinks.\n   */\n  updateTopOffset() {\n    if (this.lastScrollPosition === window.scrollY) {\n      return;\n    }\n    // Remove rewind if it is near the page buttom, resolves the bouncing issue\n    // on mobile.\n    const nearBottom =\n        document.body.clientHeight - window.scrollY - window.innerHeight <=\n        Numbers.SCROLL_THRESHOLD;\n    if (nearBottom) {\n      this.root.classList.remove(CssClasses.REWIND);\n      this.unsetOffset();\n      return;\n    }\n    // It is 128px by default\n    const headerHeight = this.options.offset - Numbers.JUMPLINKS_MARGIN;\n    // Remove rewind if it scrolls to top\n    if (window.scrollY <= headerHeight) {\n      this.root.classList.remove(CssClasses.REWIND);\n      this.unsetOffset();\n      return;\n    }\n    // Rewind if it scrolls up\n    if (window.scrollY > headerHeight) {\n      if (window.scrollY < this.lastScrollPosition) {\n        this.root.classList.add(CssClasses.REWIND);\n        if (this.options.belowHeader) {\n          const header = document.querySelector('header');\n          this.setOffset(\n              ((header === null || header === void 0 ? void 0 :\n                                                       header.clientHeight) ||\n               0) +\n              Numbers.JUMPLINKS_MARGIN);\n        } else {\n          this.setOffset(this.options.offset);\n        }\n      } else {\n        this.root.classList.remove(CssClasses.REWIND);\n        this.unsetOffset();\n      }\n    }\n    this.lastScrollPosition = window.scrollY;\n  }\n  setOffset(top) {\n    this.root.style.top = `${top}px`;\n  }\n  unsetOffset() {\n    this.root.style.top = '';\n  }\n  isRTL() {\n    return document.documentElement.dir === Strings.RTL;\n  }\n}\nexport {Jumplinks};\n","/**\n * @fileoverview A utility class for representing two-dimensional positions.\n */\n/**\n * Class for representing coordinates and positions.\n */\nclass Coordinate {\n  constructor(leftCoordinate = 0, topCoordinate = 0) {\n    this.x = leftCoordinate;\n    this.y = topCoordinate;\n  }\n  /**\n   * Returns the difference between two coordinates as a new\n   * Coordinate.\n   */\n  static difference(dimOne, dimTwo) {\n    return new Coordinate(dimOne.x - dimTwo.x, dimOne.y - dimTwo.y);\n  }\n}\nexport {Coordinate};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-modal';\nCssClasses['CLOSE_BTN'] = 'glue-modal__close-btn';\nCssClasses['CLOSING'] = 'glue-modal-closing';\nCssClasses['OPEN'] = 'glue-modal-open';\nCssClasses['NO_SCROLL'] = 'glue-no-scroll';\nCssClasses['DARK'] = 'glue-modal--dark';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['OPENED_EVENT'] = 'GlueModal:opened';\nStrings['CLOSED_EVENT'] = 'GlueModal:closed';\nStrings['CLOSE_MODAL_LABEL'] = 'Close the modal';\n})(Strings || (Strings = {}));\nexport {CssClasses, Strings};\n","import {Component} from '../base';\nimport {Attribute, Role} from '../constants/attribute';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\nimport {isElementFocusable} from '../focus/';\n\nimport {CssClasses, Strings} from './constants';\n\nclass Modal extends Component {\n  /**\n   * Modal object providing focus management.\n   * The element is present in the DOM and hidden.\n   * The modal has role='dialog'.\n   * @param el the element serving as the modal dialog.\n   * @param focusAfterClosed The element to focus when the modal closes.\n   * @param focusFirst The first element will receive focus after modal opens.\n   */\n  constructor(el, focusAfterClosed, focusFirst = null) {\n    super(el);\n    this.lastFocus = document.activeElement;\n    this.ignoreFocusChange = false;\n    this.ariaHiddenElements = [];\n    /** Handle modal transition ends. */\n    this.handleTransitionEnds = () => {\n      this.root.classList.remove(CssClasses.CLOSING);\n      this.focusAfterClosed.focus();\n      this.root.removeEventListener(\n          EventType.TRANSITIONEND, this.handleTransitionEnds);\n    };\n    this.closeBtn = this.root.querySelector(`.${CssClasses.CLOSE_BTN}`);\n    this.focusAfterClosed = focusAfterClosed;\n    this.focusFirst = focusFirst;\n    this.handleCloseBtnClick = (e) => {\n      e.stopPropagation();\n      this.close();\n    };\n    this.handleKeyDown = (e) => {\n      e.stopPropagation();\n      const isEscape = e.code === Key.ESC;\n      if (isEscape) {\n        this.close();\n      }\n    };\n    this.handleFocus = (e) => {\n      this.trapFocus(e);\n    };\n    this.init();\n  }\n  /**\n   * Throw an error if close button does not exist.\n   */\n  init() {\n    this.root.setAttribute(Attribute.ROLE, Role.DIALOG);\n    this.root.setAttribute(Attribute.ARIA_MODAL, 'true');\n  }\n  /**\n   * Set focus on descendant nodes until the first focusable element is\n   * found.\n   * @param element DOM node for which to find the first focusable descendant.\n   * @return true if a focusable element is found and focus is set.\n   */\n  focusFirstDescendant(element) {\n    for (let i = 0; i < element.children.length; i++) {\n      const child = element.children[i];\n      if (this.attemptFocus(child) || this.focusFirstDescendant(child)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Find the last descendant node that is focusable.\n   * @param element DOM node for which to find the last focusable descendant.\n   * @return true if a focusable element is found and focus is set.\n   */\n  focusLastDescendant(element) {\n    for (let i = element.children.length - 1; i >= 0; i--) {\n      const child = element.children[i];\n      if (this.attemptFocus(child) || this.focusLastDescendant(child)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Attempt to set focus on the current node.\n   * @param element The node to attempt to focus on.\n   * @return true if element is focused.\n   */\n  attemptFocus(element) {\n    if (!isElementFocusable(element)) {\n      return false;\n    }\n    this.ignoreFocusChange = true;\n    try {\n      element.focus();\n    } catch (e) {\n      throw new Error(`${e}`);\n    }\n    this.ignoreFocusChange = false;\n    return element === document.activeElement;\n  }\n  /**\n   * Trap focus inside the modal dialog.\n   * @param e focus event.\n   */\n  trapFocus(e) {\n    // Ignore the focus change so lastFocus does not get updated.\n    if (this.ignoreFocusChange) {\n      return;\n    }\n    // Move the focus to the element if it is inside of the Modal dialog,\n    // otherwise, it moves to the first or last focusable element.\n    if (this.root.contains(e.target)) {\n      this.lastFocus = e.target;\n    } else {\n      this.focusFirstDescendant(this.root);\n      if (this.lastFocus === document.activeElement) {\n        this.focusLastDescendant(this.root);\n      }\n      this.lastFocus = document.activeElement;\n    }\n  }\n  /**\n   * Open the modal dialog.\n   */\n  open() {\n    var _a;\n    this.root.classList.add(CssClasses.OPEN);\n    this.emit(Strings.OPENED_EVENT, {});\n    (_a = this.closeBtn) === null || _a === void 0 ?\n        void 0 :\n        _a.addEventListener(EventType.CLICK, this.handleCloseBtnClick);\n    // Disable background scrolling\n    document.body.classList.add(CssClasses.NO_SCROLL);\n    // Close modal on escape key\n    document.addEventListener(EventType.KEYDOWN, this.handleKeyDown);\n    // Trap focus in the modal when it catches a focus event.\n    document.addEventListener(EventType.FOCUS, this.handleFocus, true);\n    // Focus on the first focusable element if it is not specified.\n    if (this.focusFirst) {\n      this.focusFirst.focus();\n    } else {\n      this.focusFirstDescendant(this.root);\n    }\n    this.ariaHideElements();\n  }\n  /**\n   * Close the modal dialog and deregister event listeners.\n   */\n  close() {\n    var _a;\n    this.root.classList.remove(CssClasses.OPEN);\n    this.root.classList.add(CssClasses.CLOSING);\n    this.emit(Strings.CLOSED_EVENT, {});\n    // Deregister event listeners and add end modal\n    document.body.classList.remove(CssClasses.NO_SCROLL);\n    document.removeEventListener(EventType.FOCUS, this.handleFocus, true);\n    (_a = this.closeBtn) === null || _a === void 0 ?\n        void 0 :\n        _a.removeEventListener(EventType.CLICK, this.handleCloseBtnClick);\n    document.removeEventListener(EventType.KEYDOWN, this.handleKeyDown);\n    this.root.addEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnds);\n    this.ariaUnhideElements();\n  }\n  /**\n   * Set aria hidden to true for all other elements.\n   * This method provides complementary A11y support before aria-modal\n   * The code is referenced from\n   * https://source.corp.google.com/piper///depot/google3/googledata/html/external_content/scs_corp/ariablueprints/dialog/dialog-modal-1.0.html;l=81-101\n   * gets broader browser support.\n   */\n  ariaHideElements() {\n    let current = this.root;\n    while (current && current.parentNode) {\n      [...current.parentNode.children].forEach((child) => {\n        if (child !== current && child.getAttribute('aria-hidden') !== 'true') {\n          this.ariaHiddenElements.push(child);\n          child.setAttribute('aria-hidden', 'true');\n        }\n      });\n      current = current.parentNode;\n    }\n  }\n  /**\n   * Remove aria hidden to false for all other elements.\n   */\n  ariaUnhideElements() {\n    this.ariaHiddenElements.forEach((el) => {\n      el.removeAttribute('aria-hidden');\n    });\n    this.ariaHiddenElements = [];\n  }\n  setFocusAfterClosed(el) {\n    this.focusAfterClosed = el;\n  }\n  destroy() {\n    this.root.removeAttribute(Attribute.ROLE);\n    this.root.removeAttribute(Attribute.ARIA_MODAL);\n  }\n}\nexport {Modal};\n","/**\n * @fileoverview An Observer class to create observables.\n */\n/**\n * Observer generates observables for data tracking.\n */\nclass Observer {\n  constructor(data) {\n    this.data = data;\n    // Create a map for keys and callbacks.\n    this.watchers = new Map();\n    // Generate an observable.\n    this.walk(this.data);\n  }\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n      this.defineReactive(obj, keys[i]);\n    }\n  }\n  /**\n   * Define a reactive property on an object.\n   */\n  defineReactive(obj, key, val) {\n    const property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n    // Use pre-defined getter/setters if they exist.\n    const getter = property && property.get;\n    const setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: () => {\n        const value = getter ? getter.call(obj) : val;\n        if (!this.watchers.has(key)) {\n          this.watchers.set(key, []);\n        }\n        return value;\n      },\n      set: (newVal) => {\n        const value = getter ? getter.call(obj) : val;\n        if (newVal === value) {\n          return;\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        this.notify(key);\n      },\n    });\n  }\n  /**\n   * Add callback to the watchers list.\n   * @param key The key or object that the model listens to\n   *     changes on.\n   */\n  listen(key, callback) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((prop) => {\n        if (!this.watchers.has(prop)) {\n          this.watchers.set(prop, []);\n        }\n        const callbacks = this.watchers.get(prop);\n        if (callbacks) callbacks.push(callback);\n      });\n    } else {\n      if (!this.watchers.has(key)) {\n        this.watchers.set(key, []);\n      }\n      const callbacks = this.watchers.get(key);\n      if (callbacks) callbacks.push(callback);\n    }\n  }\n  /**\n   * Remove callback from the watchers list.\n   * @param key The key or object that the model listens to\n   *     changes on.\n   */\n  unlisten(key, callback) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((prop) => {\n        if (this.watchers.has(prop)) {\n          this.watchers.set(\n              prop, this.watchers.get(prop).filter((val) => val !== callback));\n        }\n      });\n    } else if (this.watchers.get(key)) {\n      this.watchers.set(\n          key, this.watchers.get(key).filter((val) => val !== callback));\n    }\n  }\n  /**\n   * Notify subscribers.\n   */\n  notify(key) {\n    if (this.watchers.get(key)) {\n      this.watchers.get(key).forEach((subscriber) => {\n        subscriber.call(null);\n      });\n    }\n  }\n}\nexport {Observer};\n","/**\n * Custom popover placements\n */\nvar PlacementOptions;\n(function(PlacementOptions) {\nPlacementOptions['LEFT'] = 'left';\nPlacementOptions['RIGHT'] = 'right';\nPlacementOptions['TOP'] = 'top';\nPlacementOptions['BOTTOM'] = 'bottom';\n})(PlacementOptions || (PlacementOptions = {}));\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['PREFIX'] = 'data-glue-popover';\nCssClasses['ROOT'] = 'glue-popover';\nCssClasses['TRIGGER'] = 'glue-popover__trigger';\nCssClasses['DIALOG'] = 'glue-popover__dialog';\nCssClasses['CLOSE_BTN'] = 'glue-popover__close-btn';\nCssClasses['IS_SHOWN'] = 'glue-is-shown';\nCssClasses['COPY'] = 'glue-copy';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['TRIGGER'] = 'trigger';\nStrings['PLACEMENT'] = 'placement';\nStrings['FOCUS'] = 'takeFocus';\nStrings['ROOT'] = 'root';\nStrings['MISSING_ID'] = 'Missing or invalid ID. Popover requires a unique ID';\nStrings['MISSING_TRIGGER'] = 'Popover trigger element is missing';\nStrings['MISSING_DIALOG'] = 'Popover dialog element is missing';\nStrings['INCORRECT_PLACEMENT'] =\n    'Placement value needs to be one of these: left, right, top, bottom.';\n})(Strings || (Strings = {}));\nvar DataAttr;\n(function(DataAttr) {\nDataAttr['TRIGGER'] = 'gluePopoverTrigger';\n})(DataAttr || (DataAttr = {}));\n/**\n * Custom popover events\n */\nvar CustomEvent;\n(function(CustomEvent) {\nCustomEvent['OPEN_EVENT'] = 'gluepopovershow';\nCustomEvent['CLOSE_EVENT'] = 'gluepopoverclose';\n})(CustomEvent || (CustomEvent = {}));\n/** Debounce timing for resize events */\nconst RESIZE_DEBOUNCE_TIMING = 250;\nexport {\n  CssClasses,\n  CustomEvent,\n  DataAttr,\n  PlacementOptions,\n  RESIZE_DEBOUNCE_TIMING,\n  Strings,\n};\n","import {Component} from '../base/';\nimport {getOverlayAutoPosition} from '../base/utils';\nimport {Attribute, Role, TabIndex} from '../constants/attribute';\nimport {Debounce} from '../debounce';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\n\nimport {CssClasses, CustomEvent, PlacementOptions, RESIZE_DEBOUNCE_TIMING, Strings,} from './constants';\n\n/**\n * A components that shows a popover component by toggling a button.\n *\n * Responsibilities:\n *  - Attach component instance to root element\n *  - Initialize options object\n *  - Provide public methods for open, close and destroy\n *  - Set attributes and aria tags to elements.\n *  - Access all DOM api needs directly\n *  - Set and remove all event listeners\n *  - Controls and sets focus to elements\n *\n * Design doc: https://goto.google.com/glue-popover-mdc-dd\n *\n */\nclass Popover extends Component {\n  /**\n   * @param rootElement The element that contains the popover.\n   * @param options Popover options object.\n   * @param buttonEl The element that opens the popover.\n   * @param dialogEl The element for the popover dialog.\n   */\n  constructor(rootElement, options = {}, buttonEl, dialogEl) {\n    super(rootElement);\n    /**\n     * Resize handler for the Popover.\n     * Recalculate the position of the Popover when the window resizes.\n     */\n    this.handleResize = () => {\n      this.setPopoverPosition();\n    };\n    /**\n     * Resize debounce handler for the Popover.\n     */\n    this.handleResizeDebounce = () => {\n      this.resizeDebounce.debounce();\n    };\n    // Compile the final set of options.\n    this.options = Object.assign(\n        {}, Popover.defaults, options, this.getAttributeOptions());\n    if (!['top', 'bottom', 'left', 'right'].includes(this.options.placement)) {\n      throw new Error(Strings.INCORRECT_PLACEMENT);\n    }\n    this.clickOutsideDialogHandler = (evt) => {\n      this.handleClickOutsideDialog(evt);\n    };\n    this.initInteractiveElements(buttonEl, dialogEl);\n    this.resizeDebounce =\n        new Debounce(this.handleResize, RESIZE_DEBOUNCE_TIMING);\n  }\n  /**\n   * Set up the button interactive elements.\n   */\n  initInteractiveElements(buttonEl, dialogEl) {\n    // Get Button and Dialog elements if not already provided.\n    if (buttonEl) {\n      this.buttonEl = buttonEl;\n    } else {\n      this.buttonEl = this.root.querySelector(`.${CssClasses.TRIGGER}`);\n    }\n    if (!this.buttonEl) {\n      throw new Error(Strings.MISSING_TRIGGER);\n    }\n    if (dialogEl) {\n      this.dialogEl = dialogEl;\n    } else {\n      this.dialogEl = this.root.querySelector(`.${CssClasses.DIALOG}`);\n      if (!this.dialogEl) {\n        throw new Error(Strings.MISSING_DIALOG);\n      }\n    }\n    this.closeEl = this.dialogEl.querySelector(`.${CssClasses.CLOSE_BTN}`);\n    // Bind to event handlers.\n    this.buttonClickHandler = (evt) => {\n      this.handleButtonClick(evt);\n    };\n    this.keyDownHandler = (evt) => {\n      this.handleKeyDown(evt);\n    };\n    // Add events to trigger element for key and trigger events (set in opts).\n    this.buttonEl.addEventListener(EventType.CLICK, this.buttonClickHandler);\n    this.buttonEl.addEventListener(EventType.KEYDOWN, this.keyDownHandler);\n    // Set listeners to handle an ESC key press or close btn when dialog open.\n    this.dialogEl.addEventListener(EventType.KEYDOWN, this.keyDownHandler);\n    this.dialogEl.addEventListener(EventType.CLICK, this.buttonClickHandler);\n    // Automatically resize the Popover when the window resizes.\n    window.addEventListener(EventType.RESIZE, this.handleResizeDebounce);\n    // Sets element attrs mainly for a11y.\n    this.setDefaultElAttr();\n  }\n  /**\n   * Destroys the popover instance.\n   */\n  destroy() {\n    this.close();\n    // Remove event listeners\n    this.buttonEl.removeEventListener(EventType.CLICK, this.buttonClickHandler);\n    document.removeEventListener(\n        EventType.CLICK, this.clickOutsideDialogHandler);\n    this.dialogEl.removeEventListener(EventType.KEYDOWN, this.keyDownHandler);\n    this.buttonEl.removeEventListener(EventType.KEYDOWN, this.keyDownHandler);\n    this.dialogEl.removeEventListener(EventType.CLICK, this.buttonClickHandler);\n    if (this.mouseLeaveHandler) {\n      this.buttonEl.removeEventListener(\n          EventType.MOUSELEAVE, this.mouseLeaveHandler);\n      this.dialogEl.removeEventListener(\n          EventType.MOUSELEAVE, this.mouseLeaveHandler);\n    }\n    if (this.blurHandler) {\n      window.removeEventListener(EventType.BLUR, this.blurHandler);\n    }\n    window.removeEventListener(EventType.RESIZE, this.handleResizeDebounce);\n  }\n  /**\n   * If an event is from the specified element.\n   */\n  checkEventFromChild(element, event) {\n    return event.target instanceof Node && element.contains(event.target);\n  }\n  /**\n   * Get attributes from target element and constructor an options object.\n   */\n  getAttributeOptions() {\n    const {PREFIX} = CssClasses;\n    const {PLACEMENT, FOCUS} = Strings;\n    const options = {};\n    const placement = this.root.getAttribute(`${PREFIX}-${PLACEMENT}`);\n    const focus = this.root.getAttribute(`${PREFIX}-${FOCUS}`);\n    if (placement) options[PLACEMENT] = placement;\n    if (focus) options[FOCUS] = placement;\n    return options;\n  }\n  /**\n   *  Adds default attributes to the corresponding elements\n   */\n  setDefaultElAttr() {\n    this.dialogEl.setAttribute(Attribute.ROLE, Role.DIALOG);\n    this.dialogEl.tabIndex = TabIndex.NOT_TABBABLE;\n    this.dialogEl.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    this.buttonEl.setAttribute(Attribute.ROLE, Role.BUTTON);\n    this.buttonEl.tabIndex = TabIndex.TABBABLE;\n    this.buttonEl.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n    if (!this.dialogEl.id || this.dialogEl.id.length === 0) {\n      this.dialogEl.id = `glue-popover-${Math.round(Math.random() * 99999999)}`;\n    }\n    // Set aria-controls (extend value if it already exists)\n    const ariaControlsElements = [\n      this.dialogEl.id,\n      this.buttonEl.getAttribute(Attribute.ARIA_CONTROLS),\n    ];\n    this.buttonEl.setAttribute(\n        Attribute.ARIA_CONTROLS, ariaControlsElements.join(' ').trim());\n    if (this.closeEl) {\n      this.closeEl.setAttribute(Attribute.ROLE, Role.BUTTON);\n      this.closeEl.tabIndex = TabIndex.TABBABLE;\n    }\n  }\n  /**\n   * Set focus to element based on status\n   */\n  setElementFocus() {\n    var _a;\n    if (!this.options.takeFocus) return;\n    (_a = this.buttonEl) === null || _a === void 0 ? void 0 : _a.focus();\n  }\n  /**\n   * Shows popover and sets the pending flag.\n   */\n  open() {\n    if (this.isOpen()) return;\n    this.setPopoverPosition();\n    this.dialogEl.setAttribute(Attribute.ARIA_HIDDEN, 'false');\n    this.buttonEl.setAttribute(Attribute.ARIA_EXPANDED, 'true');\n    this.root.classList.add(CssClasses.IS_SHOWN);\n    document.addEventListener(EventType.CLICK, this.clickOutsideDialogHandler);\n    this.setElementFocus();\n    this.emit(CustomEvent.OPEN_EVENT, {}, true);\n  }\n  /**\n   * Close popover and sets the pending flag\n   */\n  close() {\n    if (!this.isOpen()) return;\n    this.dialogEl.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    this.buttonEl.setAttribute(Attribute.ARIA_EXPANDED, 'false');\n    this.root.classList.remove(CssClasses.IS_SHOWN);\n    if (this.closeEl) this.closeEl.classList.remove(CssClasses.IS_SHOWN);\n    this.setElementFocus();\n    this.emit(CustomEvent.CLOSE_EVENT, {}, true);\n    document.removeEventListener(\n        EventType.CLICK, this.clickOutsideDialogHandler);\n  }\n  /**\n   * If the Dialog is currently open.\n   */\n  isOpen() {\n    return this.root.classList.contains(CssClasses.IS_SHOWN);\n  }\n  /**\n   * The handler is attached to the root element and handles a few cases\n   * 1. Opens and closes the dialog via clicking trigger button.\n   * 1. Closes the dialog via clicking close button.\n   */\n  handleButtonClick(event) {\n    if (!this.isOpen()) {\n      this.open();\n    } else if (this.checkEventFromChild(this.buttonEl, event)) {\n      this.close();\n    } else if (\n        this.closeEl && this.checkEventFromChild(this.closeEl, event) &&\n        (!event.key || event.key === Key.ENTER || event.key === Key.SPACE)) {\n      this.close();\n    }\n  }\n  /**\n   * Event handler for Escape key and Enter key.\n   */\n  handleKeyDown(event) {\n    var _a, _b;\n    event.stopPropagation();\n    if (event.key === Key.ESC) {\n      this.close();\n    } else if (this.closeEl && this.checkEventFromChild(this.closeEl, event)) {\n      // To prevent the mouseclick when pressing return key\n      event.preventDefault();\n      this.close();\n    } else if (\n        this.isOpen() && this.checkEventFromChild(this.buttonEl, event) &&\n        event.shiftKey && event.key === Key.TAB) {\n      event.preventDefault();\n      this.close();\n    } else if (\n        !this.isOpen() && this.checkEventFromChild(this.buttonEl, event) &&\n        (event.key === Key.ENTER || event.key === Key.SPACE)) {\n      event.preventDefault();\n      (_a = this.closeEl) === null || _a === void 0 ?\n          void 0 :\n          _a.classList.add(CssClasses.IS_SHOWN);\n      this.open();\n    }\n    // Show close button when press TAB key.\n    if (event.key === Key.TAB &&\n        this.checkEventFromChild(this.dialogEl, event)) {\n      (_b = this.closeEl) === null || _b === void 0 ?\n          void 0 :\n          _b.classList.add(CssClasses.IS_SHOWN);\n    }\n  }\n  /**\n   * Click handler for closing window if user clicks outside the open\n   * dialog window.\n   */\n  handleClickOutsideDialog(event) {\n    const containsTarget =\n        event.target instanceof Node && this.root.contains(event.target);\n    if (!this.checkEventFromChild(this.dialogEl, event) &&\n        !this.checkEventFromChild(this.buttonEl, event) && !containsTarget &&\n        event.type === EventType.CLICK) {\n      this.close();\n    }\n  }\n  /**\n   * Calculate the position of the Popover.\n   */\n  setPopoverPosition() {\n    const pos = getOverlayAutoPosition(\n        this.root, this.dialogEl, this.buttonEl, this.options.placement);\n    if (pos) {\n      const [left, top] = pos;\n      this.dialogEl.style.left = `${left}px`;\n      this.dialogEl.style.top = `${top}px`;\n    }\n  }\n  /**\n   * Default popover options\n   */\n  static get defaults() {\n    return {\n      placement: PlacementOptions.BOTTOM,\n      takeFocus: true,\n    };\n  }\n}\nexport {PlacementOptions, Popover};\n","import {EventType} from '../events/eventtype';\n/**\n * Calls handler functions when the document object matches a media query, or\n * when a CSS-injected named breakpoint is included in a list of strings. Can\n * also call another handler when one of the condition above does not apply\n * anymore.\n *\n * This typically can be used to enable or disable a UI component based on the\n * viewport size.\n *\n * Example:\n *\n * new ResponsiveMonitor({\n *   breakpoint: ['medium', 'large'],\n *   enter: (size) => component.start(),\n *   leave: (size) => component.stop(),\n * });\n *\n * new ResponsiveMonitor({\n *   media: '(min-width: 600px)',\n *   transform: (mql) => component.start(),\n *   revert: (mql) => component.stop(),\n * });\n *\n * new ResponsiveMonitor([{\n *   media: '(max-width: 400px)',\n *   transform: (mql) => component1.start(),\n * }, {\n *   media: '(min-width: 501px) and (max-width: 800px)',\n *   transform: component2.start(),\n * }]);\n *\n * For simpler use cases, it is also possible to have a function called every\n * time the current breakpoint changes.\n *\n * const rm = new ResponsiveMonitor();\n * rm.listen((size) => {\n *   if (size == 'medium') {\n *     component.start();\n *   }\n * });\n */\nclass ResponsiveMonitor {\n  /**\n   * Returns unique monitor instance.\n   */\n  static getInstance() {\n    if (!ResponsiveMonitor.instance) {\n      ResponsiveMonitor.instance = new ResponsiveMonitor();\n    }\n    return ResponsiveMonitor.instance;\n  }\n  /**\n   * @param configRules One or several media queries associated with callbacks\n   *     to trigger when their result changes.\n   */\n  constructor(configRules = []) {\n    this.vpUpdateHandler = () => {\n      this.handleViewportUpdate();\n    };\n    /**\n     * Registered media query rules;\n     */\n    this.mqRuleHandlerMaps = [];\n    /**\n     * Callback functions used to listen to breakpoint changes.\n     */\n    this.bpChangeHandlers = [];\n    /**\n     * Registered breakpoint rules.\n     */\n    this.bpRuleHandlerMaps = [];\n    /**\n     * The current named breakpoint.\n     */\n    this.currentBreakpoint = this.readBreakpoint();\n    /**\n     * The previous named breakpoint.\n     */\n    this.previousBreakpoint = '';\n    // Setup media query rules\n    if (!Array.isArray(configRules)) {\n      configRules = [configRules];\n    }\n    configRules.forEach(this.addRule.bind(this));\n    // Setup named breakpoints listening\n    window.addEventListener(EventType.DOM_CONTENT_READY, this.vpUpdateHandler);\n    window.addEventListener(EventType.RESIZE, this.vpUpdateHandler);\n    window.addEventListener(EventType.ORIENTATION_CHANGE, this.vpUpdateHandler);\n  }\n  /**\n   * Listens to media query or breakpoint changes.\n   */\n  listen(handler) {\n    if (typeof handler === 'function') {\n      this.bpChangeHandlers.push(handler);\n    } else {\n      this.addRule(handler);\n    }\n  }\n  /**\n   * Stops listening to media query or breakpoint changes.\n   */\n  unlisten(handler) {\n    if (typeof handler === 'function') {\n      let handler;\n      for (let i = 0; (handler = this.bpChangeHandlers[i]); i++) {\n        if (handler === handler) {\n          this.bpChangeHandlers.splice(i, 1);\n          return;\n        }\n      }\n    } else {\n      this.removeRule(handler);\n    }\n  }\n  /**\n   * Stops listening to all media query and breakpoint rules.\n   */\n  destroy() {\n    this.currentBreakpoint = '';\n    for (const mq of this.mqRuleHandlerMaps) {\n      // tslint:disable-next-line:deprecation\n      mq.mql.removeEventListener(EventType.CHANGE, mq.handler);\n    }\n    this.mqRuleHandlerMaps = [];\n    this.bpRuleHandlerMaps = [];\n    this.bpChangeHandlers = [];\n    window.removeEventListener(\n        EventType.DOM_CONTENT_READY, this.vpUpdateHandler);\n    window.removeEventListener(EventType.RESIZE, this.vpUpdateHandler);\n    window.removeEventListener(\n        EventType.ORIENTATION_CHANGE, this.vpUpdateHandler);\n  }\n  /**\n   * Returns the last known named breakpoint.\n   */\n  getCurrentBreakpoint() {\n    return this.currentBreakpoint;\n  }\n  isBreakpointRule(rule) {\n    return rule.breakpoint !== undefined;\n  }\n  isMediaQueryRuleRule(rule) {\n    return rule.media !== undefined;\n  }\n  /**\n   * Setup callback functions on a media query or a set of named breakpoints.\n   * @param rule Configuration properties.\n   */\n  addRule(rule) {\n    if (this.isBreakpointRule(rule)) {\n      this.addBreakpointRule(rule);\n      return;\n    } else if (this.isMediaQueryRuleRule(rule)) {\n      this.addMediaQueryRule(rule);\n      return;\n    }\n  }\n  /**\n   * Disable callback functions on a media query or a set of named breakpoints.\n   * @param rule Configuration properties.\n   */\n  removeRule(rule) {\n    if (this.isBreakpointRule(rule)) {\n      this.removeBreakpointRule(rule);\n      return;\n    } else if (this.isMediaQueryRuleRule(rule)) {\n      this.removeMediaQueryRule(rule);\n      return;\n    }\n  }\n  /**\n   * Setup callback functions on a set of named breakpoints.\n   */\n  addBreakpointRule(rule) {\n    const checkBreakpoint = (size) => {\n      const bps = rule.breakpoint;\n      if (bps.indexOf(this.previousBreakpoint) === -1 &&\n          bps.indexOf(this.currentBreakpoint) !== -1) {\n        rule.enter(size);\n        return;\n      }\n      if (rule.leave && bps.indexOf(this.previousBreakpoint) !== -1 &&\n          bps.indexOf(this.currentBreakpoint) === -1) {\n        rule.leave(size);\n      }\n    };\n    // Keeps references for later unregistration purposes\n    this.bpRuleHandlerMaps.push({\n      rule,\n      handler: checkBreakpoint,\n    });\n    checkBreakpoint(this.getCurrentBreakpoint());\n    this.listen(checkBreakpoint);\n  }\n  /**\n   * Disable callback functions on a set of named breakpoints.\n   */\n  removeBreakpointRule(rule) {\n    let bpMap;\n    for (let i = 0; (bpMap = this.bpRuleHandlerMaps[i]); i++) {\n      if (bpMap.rule === rule) {\n        this.unlisten(bpMap.handler);\n      }\n    }\n  }\n  /**\n   * Setup callback functions on a media query.\n   */\n  addMediaQueryRule(rule) {\n    const callback = this.handleMediaQueryChange(rule.transform, rule.revert);\n    const mql = window.matchMedia(rule.media);\n    // tslint:disable-next-line:no-any.\n    const handler = () => {\n      callback(mql);\n    };\n    // tslint:disable-next-line:deprecation\n    mql.addEventListener(EventType.CHANGE, handler);\n    // Keeps references for later unregistration purposes\n    this.mqRuleHandlerMaps.push({\n      rule,\n      mql,\n      handler,\n    });\n    // Triggers callback at once if the media query result is true.\n    if (mql.matches) {\n      callback(mql);\n    }\n  }\n  /**\n   * Disable callback functions on a media query.\n   */\n  removeMediaQueryRule(rule) {\n    for (const mqMap of this.mqRuleHandlerMaps) {\n      if (mqMap.rule === rule) {\n        // tslint:disable-next-line:deprecation\n        mqMap.mql.removeEventListener(EventType.CHANGE, mqMap.handler);\n      }\n    }\n  }\n  /**\n   * Creates a function that will trigger callbacks based on the media\n   * query's result.\n   * @param transformFunc Function to call if the media query result is true.\n   * @param revertFunc Function to call if the media query result reverts to\n   *     false.\n   * @return A function used as handler of a media query list.\n   */\n  handleMediaQueryChange(transformFunc, revertFunc) {\n    return (mql) => {\n      if (mql.matches) {\n        transformFunc(mql);\n      } else if (revertFunc) {\n        revertFunc(mql);\n      }\n    };\n  }\n  /**\n   * Fires breakpoint callbacks if the current named breakpoint parsed from the\n   * DOM has changed since the previous call.\n   */\n  handleViewportUpdate() {\n    const breakpoint = this.readBreakpoint();\n    if (this.currentBreakpoint === breakpoint) {\n      return;\n    }\n    this.previousBreakpoint = this.currentBreakpoint;\n    this.currentBreakpoint = breakpoint;\n    for (const handler of this.bpChangeHandlers) {\n      handler(this.currentBreakpoint);\n    }\n  }\n  /**\n   * Retrieves the named breakpoint currently injected in DOM.\n   */\n  readBreakpoint() {\n    const styles = window.getComputedStyle(document.body, ':after');\n    const content = styles.getPropertyValue('content');\n    const breakpoint = content.replace(/[\"']/g, '');\n    return breakpoint;\n  }\n}\nexport {\n  ResponsiveMonitor,\n};\n","/**\n * @fileoverview Config typedef and event enum for SmoothScroll.\n */\nimport {easeInOutQuart,} from '../easing/';\nvar ScrollEventType;\n(function(ScrollEventType) {\nScrollEventType['STARTSCROLL'] = 'glue.smoothScroll.start';\nScrollEventType['ENDSCROLL'] = 'glue.smoothScroll.end';\n})(ScrollEventType || (ScrollEventType = {}));\nvar Strings;\n(function(Strings) {\nStrings['MISSING_PAGE_ELEMENT'] =\n    'Smooth Scrolling requires a valid page element.';\nStrings['DIRECTION_MALFORMED'] =\n    'Scroll direction value only accepts \"x\", \"y\" or \"both\"';\n})(Strings || (Strings = {}));\nconst defaultOptions = {\n  'duration': 600,\n  'offset': {\n    'x': 0,\n    'y': 0,\n  },\n  'easing': easeInOutQuart,\n  'hash': true,\n  'direction': 'both',\n};\nexport {\n  defaultOptions,\n  ScrollEventType,\n  Strings,\n};\n","/**\n * @fileoverview The SmoothScroll module allows an animated smooth scroll from\n * one location within the document to another. It broadcasts events when\n * scrolling starts and ends. Configurable parameters include duration of the\n * scroll, offset of the target element, the easing function and URL hash.\n *\n * For documentation and demo see\n * https://glue-docs.appspot.com/docs/components/raw/smoothscroll\n */\nimport {defaultOptions} from './constants';\nimport {ScrollManager} from './scrollmanager';\nclass SmoothScroll {\n  constructor(config) {\n    this.currentScrollElementId = '';\n    this.scrollManager = new ScrollManager();\n    this.globalConfig = Object.assign({}, defaultOptions, config);\n  }\n  /**\n   * Allows an animated smooth scroll from one location within the\n   * document to another.\n   * @param id Element id.\n   * @param elementConfig The config object to use for the scroll.\n   */\n  scrollToId(id = '', elementConfig) {\n    let element;\n    // If asked to scroll to a non-fragment, just scroll to the first page\n    // element, which is typically the top of the page. Otherwise, scroll to\n    // a real element in the page.\n    if (id === '' || id === '#') {\n      element = document.body.firstElementChild;\n    } else {\n      element = document.getElementById(id);\n      if (!element) {\n        throw new Error(`The target element for id \"${id}\" does not exist.`);\n      }\n    }\n    this.currentScrollElementId = id;\n    this.currentScrollElement = element;\n    // Build the config out of the element config and global config.\n    elementConfig = Object.assign({}, this.globalConfig, elementConfig);\n    // Ask the scroll manager to start the scroll.\n    this.scrollManager.startScroll(this.currentScrollElement, elementConfig);\n    const temp = window.scrollY;\n    if (elementConfig['hash'] &&\n        window.location.hash !== `#${this.currentScrollElementId}`) {\n      window.location.hash = `#${this.currentScrollElementId}`;\n    }\n    document.documentElement.scrollTop = temp;\n  }\n  /**\n   * Destroy the component. Removes listeners.\n   */\n  destroy() {\n    this.scrollManager.destroy();\n  }\n}\nexport {defaultOptions, SmoothScroll};\n","/**\n * @fileoverview Manages the scrolling animation operations for SmoothScroll.\n * Can be used independently of the SmoothScroll component to actuate scrolling.\n */\nimport {easingFunctions} from '../easing/';\nimport {EventType} from '../events/eventtype';\n\nimport {defaultOptions, ScrollEventType, Strings,} from './constants';\n\nclass ScrollManager {\n  constructor() {\n    this.elapsedTime = 0;\n    this.startTime = 0;\n    this.animationFrame = 0;\n    this.position = {'x': 0, 'y': 0};\n    this.distance = this.position;\n    this.startPosition = this.position;\n    this.endPosition = this.position;\n    this.config = defaultOptions;\n    this.mousewheelHandlerFunc = () => {\n      this.mousewheelHandler();\n    };\n  }\n  /**\n   * Starts scroll, broadcasts 'start scroll' event and attaches mousewheel\n   * event listener to window object.\n   * @param element The element to scroll to.\n   * @param config The config object for this scroll.\n   */\n  startScroll(element, config) {\n    var _a;\n    // Bail out if the scroll is in progress.\n    if (this.animationFrame !== 0) return;\n    if (!(element instanceof Element)) {\n      throw new Error(Strings.MISSING_PAGE_ELEMENT);\n    }\n    // Broadcasts start scroll event globally.\n    document.dispatchEvent(new Event(ScrollEventType.STARTSCROLL, {\n      bubbles: true,\n      cancelable: false,\n    }));\n    if (config) this.config = config;\n    this.scrollElement = element;\n    // Figure out the animation settings.\n    this.startPosition = this.getScrollPosition();\n    this.endPosition = this.getEndPosition(this.scrollElement);\n    this.distance = {\n      'x': this.endPosition.x - this.startPosition.x - this.config.offset.x,\n      'y': this.endPosition.y - this.startPosition.y - this.config.offset.y,\n    };\n    this.easingFunction = typeof this.config.easing === 'string' ?\n        easingFunctions[this.config.easing] :\n        (_a = this.config.easing) !== null && _a !== void 0 ?\n        _a :\n        easingFunctions.linear;\n    this.elapsedTime = 0;\n    this.position = {'x': 0, 'y': 0};\n    window.addEventListener(EventType.MOUSEWHEEL, this.mousewheelHandlerFunc);\n    this.animateScroll();\n  }\n  /**\n   * Stops smooth scroll.\n   */\n  stopScroll() {\n    // Broadcasts ENDSCROLL event globally.\n    document.dispatchEvent(new Event(ScrollEventType.ENDSCROLL, {\n      bubbles: true,\n      cancelable: false,\n    }));\n    window.cancelAnimationFrame(this.animationFrame);\n    this.animationFrame = 0;\n    this.startTime = 0;\n    this.removeMousewheelListener();\n    this.config = defaultOptions;\n  }\n  /**\n   * Recursively scrolls the page until it reaches the element.\n   */\n  animateScroll() {\n    // If there is no config, then quit. Fixes an issue where this\n    // would be called one last time when cancelling mid-scroll.\n    if (!this.startTime) {\n      this.startTime = Date.now();\n    }\n    const now = Date.now();\n    this.elapsedTime = now - this.startTime;\n    this.calculatePosition();\n    this.updatePosition();\n    // Continues the animation until the timer reaches the end.\n    if (this.elapsedTime < this.config.duration) {\n      this.animationFrame = window.requestAnimationFrame(() => {\n        this.animateScroll();\n      });\n    } else {\n      this.stopScroll();\n    }\n  }\n  /**\n   * Calculates the position based on elapsed time.\n   */\n  calculatePosition() {\n    var _a, _b;\n    if (this.config.duration > 0) {\n      const percentage = Math.min(this.elapsedTime / this.config.duration, 1);\n      const value = this.easingFunction(percentage);\n      this.position.x = this.startPosition.x +\n          ((_a = this.distance) === null || _a === void 0 ? void 0 : _a.x) *\n              value;\n      this.position.y = this.startPosition.y +\n          ((_b = this.distance) === null || _b === void 0 ? void 0 : _b.y) *\n              value;\n    } else {\n      this.position = this.endPosition;\n    }\n  }\n  /**\n   * Gets the page scroll position.\n   * @return Page scroll position.\n   */\n  getScrollPosition() {\n    if (window.pageYOffset) {\n      return {\n        'x': window.pageXOffset,\n        'y': window.pageYOffset,\n      };\n    } else {\n      return {\n        'x': document.documentElement.scrollLeft,\n        'y': document.documentElement.scrollTop,\n      };\n    }\n  }\n  /**\n   * Gets the scroll position of the element.\n   * @return The scroll position of the element.\n   */\n  getEndPosition(el) {\n    let rect = {left: 0, top: 0};\n    if (el && 'getBoundingClientRect' in el) {\n      rect = el.getBoundingClientRect();\n    }\n    return {\n      'x': rect.left + this.getScrollPosition().x,\n      'y': rect.top + this.getScrollPosition().y,\n    };\n  }\n  /**\n   * Updates scroll position.\n   */\n  updatePosition() {\n    switch (this.config.direction) {\n      case 'x':\n        this.updateScrollLeft();\n        break;\n      case 'y':\n        this.updateScrollTop();\n        break;\n      case 'both':\n        this.updateScrollLeft();\n        this.updateScrollTop();\n        break;\n      default:\n        throw new Error();\n    }\n  }\n  /**\n   * Updates scroll left position.\n   */\n  updateScrollLeft() {\n    // Scrolls to the element if requestAnimationFrame is not supported.\n    const position = this.position.x;\n    document.body.scrollLeft = position;\n    document.documentElement.scrollLeft = position;\n  }\n  /**\n   * Updates scroll top position.\n   */\n  updateScrollTop() {\n    // Scrolls to the element if requestAnimationFrame is not supported.\n    const position = this.position.y;\n    document.body.scrollTop = position;\n    document.documentElement.scrollTop = position;\n  }\n  /**\n   * Handler function for mousewheel event.\n   */\n  mousewheelHandler() {\n    if (this.animationFrame) {\n      this.stopScroll();\n    }\n  }\n  /**\n   * Remove the moisewheel event listener.\n   */\n  removeMousewheelListener() {\n    window.removeEventListener(\n        EventType.MOUSEWHEEL, this.mousewheelHandlerFunc);\n  }\n  /**\n   * Stopp the scrolling action and Destroy the component.\n   */\n  destroy() {\n    this.stopScroll();\n  }\n}\nexport {ScrollManager};\n","/**\n * @fileoverview Constants used by the Social component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['SOCIAL_ROOT'] = 'glue-social';\nCssClasses['PERSISTENT_VARIANT'] = 'glue-social--persistent';\nCssClasses['COLOR_VARIANT'] = 'glue-social--color';\nCssClasses['MONOCHROME_VARIANT'] = 'glue-social--monochrome';\nCssClasses['PARTIAL_MONOCHROME_VARIANT'] = 'glue-social--partialmonochrome';\nCssClasses['PANELS_VARIANT'] = 'glue-social--zippy';\nCssClasses['PANELS_OPPOSITE_VARIANT'] = 'glue-social--zippy-opposite';\nCssClasses['SOCIAL_GROUP'] = 'glue-social__group';\nCssClasses['SOCIAL_LIST'] = 'glue-social__list';\nCssClasses['SOCIAL_TITLE'] = 'glue-social__title';\nCssClasses['SOCIAL_TITLE_INLINE'] = 'glue-social__title--inline';\nCssClasses['SOCIAL_TITLE_ZIPPY'] = 'glue-social__title--zippy';\nCssClasses['SOCIAL_ITEM'] = 'glue-social__item';\nCssClasses['COPY_ROOT'] = 'glue-social__copy';\nCssClasses['COPY_BUTTON'] = 'glue-social__copy-btn';\nCssClasses['COPY_INPUT'] = 'glue-social__copy-input';\nCssClasses['PANELS_SHARE_ICON'] = 'glue-social__share-icon';\nCssClasses['LINK_ROOT'] = 'glue-social__link';\nCssClasses['ICON_CLASSES'] = 'glue-icon glue-icon--social glue-icon--24px';\nCssClasses['POPOVER_ROOT'] = 'glue-social__popover';\nCssClasses['POPOVER_CLOSE'] = 'glue-social__close-btn';\nCssClasses['POPOVER_DIALOG'] = 'glue-social__dialog';\nCssClasses['POPOVER_TRIGGER'] = 'glue-social__icon-trigger';\nCssClasses['TOOLTIP_ROOT'] = 'glue-social__tooltip';\nCssClasses['TOOLTIP_TRIGGER'] = 'glue-social__tooltip-trigger';\nCssClasses['TOOLTIP_CONTENT'] = 'glue-social__tooltip-content';\nCssClasses['VISUALLY_HIDDEN'] = 'glue-visually-hidden';\n})(CssClasses || (CssClasses = {}));\nexport {CssClasses};\n","/**\n * @fileoverview Glue Social component\n * Initializes available subcomponents (popover, copy, expansion panels)\n */\nimport {Component} from '../base';\nimport {Attribute, Role} from '../constants/attribute';\nimport {Copy} from '../copy';\nimport {CssClasses as CopyCssClasses} from '../copy/constants';\nimport {ExpansionPanels} from '../expansionpanels';\nimport {CssClasses as ExpanelsCssClasses, DataAttr as ExpanelsDataAttr,} from '../expansionpanels/constants';\nimport {Popover} from '../popover';\nimport {CssClasses as PopoverCssClasses, DataAttr as PopoverDataAttr,} from '../popover/constants';\nimport {Tooltip} from '../tooltip';\nimport {CssClasses as TooltipCssClasses, DataAttrs as TooltipDataAttr,} from '../tooltip/constants';\n\nimport {CssClasses} from './constants';\n\nclass Social extends Component {\n  /**\n   * @param root The social element container.\n   */\n  constructor(root) {\n    super(root);\n    this.tooltipComponents = [];\n    // Grabs subcomponent elements if they exist\n    this.copyEl = this.root.querySelector(`.${CssClasses.COPY_ROOT}`);\n    this.popoverEl = this.root.querySelector(`.${CssClasses.POPOVER_ROOT}`);\n    this.panelsEl = this.root.querySelector(`.${CssClasses.SOCIAL_GROUP}`);\n    this.panelTitleEl = this.root.querySelector(`.${CssClasses.SOCIAL_TITLE}`);\n    this.socialListEl = this.root.querySelector(`.${CssClasses.SOCIAL_LIST}`);\n    this.tooltipEls =\n        Array.from(this.root.querySelectorAll(`.${CssClasses.TOOLTIP_ROOT}`));\n    this.initialize();\n  }\n  /** Initializes the component. */\n  initialize() {\n    this.addCopy();\n    this.addPopover();\n    this.addPanels();\n    this.addTooltips();\n  }\n  /**\n   * Destroys the social instance and any subcomponents.\n   */\n  destroy() {\n    this.removeCopy();\n    this.removePopover();\n    this.removePanels();\n    this.removeTooltips();\n  }\n  /**\n   * Sets up copy component if elements are present\n   */\n  addCopy() {\n    var _a, _b;\n    const copyInput = (_a = this.copyEl) === null || _a === void 0 ?\n        void 0 :\n        _a.querySelector(`.${CssClasses.COPY_INPUT}`);\n    const copyButton = (_b = this.copyEl) === null || _b === void 0 ?\n        void 0 :\n        _b.querySelector(`.${CssClasses.COPY_BUTTON}`);\n    if (!this.copyEl || !copyInput || !copyButton) {\n      return;\n    }\n    // Add classes and attributes to the various sub elements\n    this.copyEl.classList.add(CopyCssClasses.ROOT);\n    copyInput.classList.add(CopyCssClasses.VALUE);\n    copyButton.classList.add(CopyCssClasses.BUTTON);\n    copyButton.setAttribute(Attribute.ARIA_LIVE, 'polite');\n    // Initialize the component\n    this.copyComponent = new Copy(this.copyEl);\n  }\n  /**\n   * Removes copy component if present\n   */\n  removeCopy() {\n    var _a, _b, _c;\n    const copyInput = (_a = this.copyEl) === null || _a === void 0 ?\n        void 0 :\n        _a.querySelector(`.${CssClasses.COPY_INPUT}`);\n    const copyButton = (_b = this.copyEl) === null || _b === void 0 ?\n        void 0 :\n        _b.querySelector(`.${CssClasses.COPY_BUTTON}`);\n    if (!this.copyEl || !copyInput || !copyButton) {\n      return;\n    }\n    // Destroy the component\n    (_c = this.copyComponent) === null || _c === void 0 ? void 0 : _c.destroy();\n    // Remove classes and attributes\n    this.copyEl.classList.remove(CopyCssClasses.ROOT);\n    copyInput.classList.remove(CopyCssClasses.VALUE);\n    copyButton.classList.remove(CopyCssClasses.BUTTON);\n    copyButton.removeAttribute(Attribute.ARIA_LIVE);\n  }\n  /**\n   * Sets up popover component if elements are present\n   */\n  addPopover() {\n    var _a, _b, _c;\n    const popoverTrigger = (_a = this.popoverEl) === null || _a === void 0 ?\n        void 0 :\n        _a.querySelector(`.${CssClasses.POPOVER_TRIGGER}`);\n    const popoverDialog = (_b = this.popoverEl) === null || _b === void 0 ?\n        void 0 :\n        _b.querySelector(`.${CssClasses.POPOVER_DIALOG}`);\n    const popoverClose = (_c = this.popoverEl) === null || _c === void 0 ?\n        void 0 :\n        _c.querySelector(`.${CssClasses.POPOVER_CLOSE}`);\n    if (!this.popoverEl || !popoverTrigger || !popoverDialog || !popoverClose) {\n      return;\n    }\n    // Add classes and attributes to the various sub elements\n    this.popoverEl.classList.add(PopoverCssClasses.ROOT);\n    this.popoverEl.dataset[PopoverDataAttr.TRIGGER] = 'click';\n    popoverTrigger.classList.add(PopoverCssClasses.TRIGGER);\n    popoverDialog.classList.add(PopoverCssClasses.DIALOG);\n    popoverClose.classList.add(PopoverCssClasses.CLOSE_BTN);\n    // Initialize the component\n    this.popoverComponent = new Popover(this.popoverEl, {placement: 'right'});\n  }\n  /**\n   * Removes popover component if present\n   */\n  removePopover() {\n    var _a, _b, _c, _d;\n    const popoverTrigger = (_a = this.popoverEl) === null || _a === void 0 ?\n        void 0 :\n        _a.querySelector(`.${CssClasses.POPOVER_TRIGGER}`);\n    const popoverDialog = (_b = this.popoverEl) === null || _b === void 0 ?\n        void 0 :\n        _b.querySelector(`.${CssClasses.POPOVER_DIALOG}`);\n    const popoverClose = (_c = this.popoverEl) === null || _c === void 0 ?\n        void 0 :\n        _c.querySelector(`.${CssClasses.POPOVER_CLOSE}`);\n    if (!this.popoverEl || !popoverTrigger || !popoverDialog || !popoverClose) {\n      return;\n    }\n    // Destroy the component\n    (_d = this.popoverComponent) === null || _d === void 0 ? void 0 :\n                                                             _d.destroy();\n    // Remove classes and attributes\n    this.popoverEl.classList.remove(PopoverCssClasses.ROOT);\n    delete this.popoverEl.dataset[PopoverDataAttr.TRIGGER];\n    popoverTrigger.classList.remove(PopoverCssClasses.TRIGGER);\n    popoverDialog.classList.remove(PopoverCssClasses.DIALOG);\n    popoverClose.classList.remove(PopoverCssClasses.CLOSE_BTN);\n  }\n  /**\n   * Sets up expansion panels component if elements are present\n   */\n  addPanels() {\n    if (!this.root.classList.contains(CssClasses.PANELS_VARIANT) ||\n        !this.panelsEl || !this.panelTitleEl || !this.socialListEl) {\n      return;\n    }\n    // Add classes and attributes to the various sub elements\n    const panelsId = this.root.id ? this.root.id : 'social-panels';\n    this.root.classList.add(`${ExpanelsCssClasses.GROUP}`);\n    this.root.dataset[ExpanelsDataAttr.KEY] = panelsId;\n    this.panelsEl.classList.add(`${ExpanelsCssClasses.PANEL}`);\n    // Set up panel title/button\n    const panelsButtonEl = document.createElement('button');\n    panelsButtonEl.className = this.panelTitleEl.className;\n    panelsButtonEl.classList.add(`${ExpanelsCssClasses.BUTTON}`);\n    panelsButtonEl.id = panelsId + '-toggle';\n    panelsButtonEl.dataset[ExpanelsDataAttr.TOGGLEFOR] = panelsId + '-content';\n    panelsButtonEl.replaceChildren(...this.panelTitleEl.childNodes);\n    this.panelTitleEl.replaceChildren();\n    this.panelTitleEl.className = '';\n    this.panelTitleEl.appendChild(panelsButtonEl);\n    this.panelTitleEl.classList.add(`${ExpanelsCssClasses.TOGGLE}`);\n    // Set up panel content\n    const panelContentEl = document.createElement('div');\n    panelContentEl.classList.add(`${ExpanelsCssClasses.CONTENT}`);\n    this.panelsEl.appendChild(panelContentEl);\n    panelContentEl.appendChild(this.socialListEl);\n    panelContentEl.id = panelsId + '-content';\n    // Initialize the component\n    this.expanelsComponent = new ExpansionPanels(this.root);\n  }\n  /**\n   * Removes expansion panels component if present\n   */\n  removePanels() {\n    var _a;\n    if (!this.root.classList.contains(CssClasses.PANELS_VARIANT) ||\n        !this.panelsEl || !this.panelTitleEl || !this.socialListEl) {\n      return;\n    }\n    // Destroy the component\n    (_a = this.expanelsComponent) === null || _a === void 0 ? void 0 :\n                                                              _a.destroy();\n    // Remove panel content\n    const panelContentEl =\n        this.panelsEl.querySelector(`.${ExpanelsCssClasses.CONTENT}`);\n    this.panelsEl.appendChild(this.socialListEl);\n    panelContentEl === null || panelContentEl === void 0 ?\n        void 0 :\n        panelContentEl.remove();\n    const panelsButtonEl =\n        this.panelTitleEl.querySelector(`.${ExpanelsCssClasses.BUTTON}`);\n    if (panelsButtonEl) {\n      panelsButtonEl.classList.remove(`${ExpanelsCssClasses.BUTTON}`);\n      this.panelTitleEl.className = panelsButtonEl.className;\n      this.panelTitleEl.replaceChildren(...panelsButtonEl.childNodes);\n      panelsButtonEl.remove();\n    }\n    // remove panels classes/attributes\n    this.root.classList.remove(`${ExpanelsCssClasses.GROUP}`);\n    delete this.root.dataset[ExpanelsDataAttr.KEY];\n    this.panelsEl.classList.remove(`${ExpanelsCssClasses.PANEL}`);\n  }\n  /**\n   * Sets up tooltip components if elements are present\n   */\n  addTooltips() {\n    for (const tooltipEl of this.tooltipEls) {\n      const tooltipTrigger =\n          tooltipEl.querySelector(`.${CssClasses.TOOLTIP_TRIGGER}`);\n      const tooltipContent =\n          tooltipEl.querySelector(`.${CssClasses.TOOLTIP_CONTENT}`);\n      if (tooltipTrigger && tooltipContent) {\n        tooltipEl.classList.add(`${TooltipCssClasses.ROOT}`);\n        if (this.root.classList.contains(CssClasses.PERSISTENT_VARIANT)) {\n          // Use manual positioning for persistent variant tooltips\n          tooltipEl.dataset[TooltipDataAttr.AUTO_POSITION] = 'false';\n        }\n        tooltipTrigger.classList.add(`${TooltipCssClasses.TRIGGER}`);\n        tooltipContent.classList.add(`${TooltipCssClasses.CONTENT}`);\n        tooltipContent.setAttribute(Attribute.ROLE, Role.TOOLTIP);\n        // Initialize tooltip Component\n        this.tooltipComponents.push(new Tooltip(tooltipEl));\n      }\n    }\n  }\n  /**\n   * Removes tooltip components if present\n   */\n  removeTooltips() {\n    while (this.tooltipComponents.length > 0) {\n      const tooltipComponent = this.tooltipComponents.pop();\n      tooltipComponent === null || tooltipComponent === void 0 ?\n          void 0 :\n          tooltipComponent.destroy();\n    }\n    for (const tooltipEl of this.tooltipEls) {\n      const tooltipTrigger =\n          tooltipEl.querySelector(`.${CssClasses.TOOLTIP_TRIGGER}`);\n      const tooltipContent =\n          tooltipEl.querySelector(`.${CssClasses.TOOLTIP_CONTENT}`);\n      tooltipEl.classList.remove(`${TooltipCssClasses.ROOT}`);\n      delete tooltipEl.dataset[TooltipDataAttr.AUTO_POSITION];\n      tooltipTrigger === null || tooltipTrigger === void 0 ?\n          void 0 :\n          tooltipTrigger.classList.remove(`${TooltipCssClasses.TRIGGER}`);\n      tooltipContent === null || tooltipContent === void 0 ?\n          void 0 :\n          tooltipContent.classList.remove(`${TooltipCssClasses.CONTENT}`);\n      tooltipContent === null || tooltipContent === void 0 ?\n          void 0 :\n          tooltipContent.removeAttribute(Attribute.ROLE);\n    }\n  }\n}\nexport {Social};\n","/**\n * @fileoverview Constants used in Tab panels component.\n */\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['TABPANEL_CONTAINER'] = 'glue-tabpanels';\nCssClasses['TABPANEL_CENTERED'] = 'glue-tabpanels--centeredtabs';\nCssClasses['TABPANEL_ICON'] = 'glue-tabpanels__heading-icon';\nCssClasses['TABPANEL_PAGE_LIST'] = 'glue-tabpanels__page-list';\nCssClasses['TABPANEL_PANEL_LIST'] = 'glue-tabpanels__panel-list';\nCssClasses['TABPANEL_PANEL_TOGGLE'] = 'glue-tabpanels__panel-toggle';\nCssClasses['TABPANEL_PANEL_BUTTON'] = 'glue-tabpanels__panel-button';\nCssClasses['TABPANEL_PANEL_TITLE'] = 'glue-tabpanels__panel-title';\nCssClasses['TABPANEL_PANEL_CONTENT'] = 'glue-tabpanels__panel-content';\nCssClasses['TABPANEL_ELEMENT_SCOPE'] = 'glue-tabpanels__scope';\nCssClasses['PANELS_TOGGLE_HEADER'] = 'glue-expansion-panel__button-header';\nCssClasses['TABSET_ROOT'] = 'glue-tabs';\nCssClasses['TABSET_TABLIST'] = 'glue-tabs__tablist';\nCssClasses['TABSET_TAB'] = 'glue-tab';\nCssClasses['TABSET_BUTTON'] = 'glue-tabs__button';\nCssClasses['TABSET_PANELCONTAINER'] = 'glue-tabs__panelgroup';\nCssClasses['TABSET_PAGE'] = 'glue-tabs__panel';\n})(CssClasses || (CssClasses = {}));\nvar DataAttr;\n(function(DataAttr) {\nDataAttr['PANELS_KEY'] = 'glueExpansionPanelsKey';\nDataAttr['TOGGLEFOR'] = 'glueExpansionPanelToggleFor';\nDataAttr['INITIAL'] = 'glueExpansionPanelInitial';\n})(DataAttr || (DataAttr = {}));\nvar Strings;\n(function(Strings) {\nStrings['MISSING_PAGE_LIST'] =\n    'No element with glue-tabpanels__page-list class was found. TabPanels requires a Panels Page List';\nStrings['MISSING_PANEL_LIST'] =\n    'No element with glue-tabpanels__panel-list class was found. TabPanels requires a Panel List';\n})(Strings || (Strings = {}));\nexport {CssClasses, DataAttr, Strings};\n","import {Component} from '../base/index';\nimport {Attribute} from '../constants/attribute';\nimport {ExpansionPanels} from '../expansionpanels';\nimport {CssClasses as ExpansionPanelsClasses} from '../expansionpanels/constants';\nimport {ResponsiveMonitor} from '../responsivemonitor/';\nimport {Tabs} from '../tabs';\n\nimport {CssClasses, DataAttr, Strings} from './constants';\n\nclass TabPanels extends Component {\n  constructor(root, options) {\n    super(root);\n    this.options = Object.assign({}, TabPanels.defaults, options);\n    // Set up expansion panel options\n    this.panelsoptions = {\n      isAnimated: this.options.isPanelsAnimated,\n      panelsCount: this.options.panelsCount,\n    };\n    this.tablistEl =\n        this.root.querySelector(`.${CssClasses.TABPANEL_PAGE_LIST}`);\n    this.panelsEl =\n        this.root.querySelector(`.${CssClasses.TABPANEL_PANEL_LIST}`);\n    this.initialize();\n  }\n  /** Init the component. */\n  initialize() {\n    // Bail out if there are no elements for the panel and tabs.\n    if (!this.tablistEl) {\n      throw new Error(Strings.MISSING_PAGE_LIST);\n    }\n    if (!this.panelsEl) {\n      throw new Error(Strings.MISSING_PANEL_LIST);\n    }\n    // Initially set up as tabs\n    this.configureTabs(true);\n    this.tabsComponent = new Tabs(this.root);\n    this.currentTab = this.tabsComponent.observer.data['currentTab'];\n    if (this.options.isResponsive) {\n      // Set up rules for Responsive Monitor\n      this.responsiveTabsMonitor = new ResponsiveMonitor({\n        breakpoint: this.options.panelsBreakpoints,\n        enter: () => {\n          // Entering x-small/mobile breakpoint. Use expansion panels\n          if (this.tabsComponent) {\n            this.currentTab = this.tabsComponent.observer.data['currentTab'];\n            this.tabsComponent.destroy();\n            this.tabsComponent = undefined;\n          }\n          this.configureTabs(false);\n          this.configureExpansionPanels(true, this.currentTab);\n          this.panelsComponent =\n              new ExpansionPanels(this.panelsEl, this.panelsoptions);\n        },\n        leave: () => {\n          // Leaving x-small/mobile breakpoint. Use tabs\n          if (this.panelsComponent) {\n            this.panelsComponent.destroy();\n            this.panelsComponent = undefined;\n          }\n          this.configureExpansionPanels(false, 0);\n          this.configureTabs(true);\n          this.tabsComponent = new Tabs(this.root);\n          this.tabsComponent.observer.data['currentTab'] = this.currentTab;\n        },\n      });\n    }\n  }\n  /**\n   * Default responsive tabs options.\n   */\n  static get defaults() {\n    return {\n      panelsBreakpoints: ['sm'],\n      isPanelsAnimated: true,\n      isResponsive: true,\n      panelsCount: 2,\n    };\n  }\n  /**\n   * Set up the Tabs Component.\n   */\n  configureTabs(isTabs) {\n    // Group settings\n    this.root.classList.toggle(CssClasses.TABSET_ROOT, isTabs);\n    // Tab list\n    this.tablistEl.classList.toggle(CssClasses.TABSET_TABLIST, isTabs);\n    // Temporarily set scope class for query selector scoping\n    // This approximates :scope in the query selector\n    this.tablistEl.classList.add(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n    const tabsEls = Array.from(this.tablistEl.querySelectorAll(\n        `.${CssClasses.TABPANEL_ELEMENT_SCOPE} > div`));\n    for (const el of tabsEls) {\n      el.classList.toggle(CssClasses.TABSET_TAB, isTabs);\n    }\n    // Remove scope class\n    this.tablistEl.classList.remove(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n    // Tabs (shared with Panels group element)\n    this.panelsEl.classList.toggle(CssClasses.TABSET_PANELCONTAINER, isTabs);\n    // Temporarily set scope class for query selector scoping\n    this.panelsEl.classList.add(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n    const panelsEls = Array.from(this.panelsEl.querySelectorAll(\n        `.${CssClasses.TABPANEL_ELEMENT_SCOPE} > div`));\n    for (const panelEl of panelsEls) {\n      panelEl.classList.toggle(CssClasses.TABSET_PAGE, isTabs);\n    }\n    // Remove scope class\n    this.panelsEl.classList.remove(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n  }\n  /**\n   * Set up the Expansion Panels Component.\n   */\n  configureExpansionPanels(isPanels, currentTab) {\n    // Group settings\n    this.panelsEl.classList.toggle(ExpansionPanelsClasses.GROUP, isPanels);\n    // Individual panel settings\n    let panelCount = 1;\n    // Temporarily set scope class for query selector scoping\n    // This approximates :scope in the query selector\n    this.panelsEl.classList.add(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n    const panelsEls = Array.from(this.panelsEl.querySelectorAll(\n        `.${CssClasses.TABPANEL_ELEMENT_SCOPE} > div`));\n    for (const panelEl of panelsEls) {\n      // Temporarily set scope class for query selector scoping\n      panelEl.classList.add(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n      panelEl.classList.toggle(ExpansionPanelsClasses.PANEL, isPanels);\n      panelEl.removeAttribute(Attribute.ARIA_HIDDEN);\n      const panelToggleEl =\n          panelEl.querySelector(`.${CssClasses.TABPANEL_ELEMENT_SCOPE} > .${\n              CssClasses.TABPANEL_PANEL_TOGGLE}`);\n      panelToggleEl.classList.toggle(ExpansionPanelsClasses.TOGGLE, isPanels);\n      const panelButtonEl = panelToggleEl.querySelector(\n          `.${CssClasses.TABPANEL_ELEMENT_SCOPE} > .${\n              CssClasses.TABPANEL_PANEL_TOGGLE} > :first-child`);\n      panelButtonEl.classList.toggle(ExpansionPanelsClasses.BUTTON, isPanels);\n      const panelTitleEl =\n          panelToggleEl.querySelector(`.${CssClasses.TABPANEL_ELEMENT_SCOPE} .${\n              CssClasses.TABPANEL_PANEL_TITLE}`);\n      panelTitleEl.classList.toggle(\n          ExpansionPanelsClasses.HEADER_TEXT, isPanels);\n      const panelContentEl =\n          panelEl.querySelector(`.${CssClasses.TABPANEL_ELEMENT_SCOPE} > .${\n              CssClasses.TABPANEL_PANEL_CONTENT}`);\n      panelContentEl.classList.toggle(ExpansionPanelsClasses.CONTENT, isPanels);\n      if (isPanels) {\n        panelButtonEl.dataset[DataAttr.TOGGLEFOR] = panelContentEl.id;\n        if (panelCount === currentTab) {\n          // Set current tab to render as expanded\n          panelContentEl.dataset[DataAttr.INITIAL] = 'expanded';\n        }\n        panelCount++;\n      } else {\n        delete panelButtonEl.dataset[DataAttr.TOGGLEFOR];\n        delete panelContentEl.dataset[DataAttr.INITIAL];\n      }\n      // Remove scope class\n      panelEl.classList.remove(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n    }\n    // Remove scope class\n    this.panelsEl.classList.remove(`${CssClasses.TABPANEL_ELEMENT_SCOPE}`);\n  }\n  /**\n   * @see {Component.destroy}\n   */\n  destroy() {\n    // Destroy subcomponents if set\n    if (this.panelsComponent) {\n      this.panelsComponent.destroy();\n      this.panelsComponent = undefined;\n      this.configureExpansionPanels(false, 0);\n    }\n    if (this.tabsComponent) {\n      this.tabsComponent.destroy();\n      this.tabsComponent = undefined;\n      this.configureTabs(false);\n    }\n    // Destroy responsive monitor instance if set\n    if (this.responsiveTabsMonitor) {\n      this.responsiveTabsMonitor.destroy();\n    }\n  }\n}\nexport {TabPanels};\n","/**\n * Data attribute used for query selecting a specific tab.\n */\nvar TabsAttrs;\n(function(TabsAttrs) {\nTabsAttrs['CURRENT'] = 'glueTabsCurrent';\n})(TabsAttrs || (TabsAttrs = {}));\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-tabs';\nCssClasses['TABLIST'] = 'glue-tabs__tablist';\nCssClasses['TAB'] = 'glue-tab';\nCssClasses['PANEL'] = 'glue-tabs__panel';\nCssClasses['PANELGROUP'] = 'glue-tabs__panelgroup';\nCssClasses['IS_SHOWN'] = 'glue-is-shown';\n})(CssClasses || (CssClasses = {}));\nvar Strings;\n(function(Strings) {\nStrings['TRIGGER'] = 'trigger';\nStrings['PLACEMENT'] = 'placement';\nStrings['FOCUS'] = 'takeFocus';\nStrings['ROOT'] = 'root';\nStrings['MISSING_TABLIST'] = 'Tablist element is missing.';\nStrings['MISSING_TABS'] = 'Tabs element is missing.';\nStrings['MISSING_TABPANELS'] = 'Tab panels element is missing.';\nStrings['DATA_CURRENT'] = 'currentTab';\n})(Strings || (Strings = {}));\nexport {CssClasses, Strings, TabsAttrs};\n","import {Component} from '../base';\nimport {Attribute, Role, TabIndex} from '../constants/attribute';\nimport {CssClasses as GlueCssClasses} from '../constants/classes';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\nimport {Observer} from '../observer';\n\nimport {CssClasses, Strings, TabsAttrs} from './constants';\n\n/**\n * Static Tabs creates tabs of content in a progressive, enhanced way and\n * is accessible through keyboard and screen reader.\n */\nclass Tabs extends Component {\n  /**\n   * @see {Compoment.constructor}\n   */\n  constructor(root, options = {currentTab: 1}) {\n    super(root);\n    /**\n     * Handles a click.\n     * @param e The event from the click.\n     */\n    this.handleClick = (e) => {\n      // Ignore clicks on elements that aren't tabs.\n      if (e.target instanceof Element) {\n        const tabEl = e.target.closest(`.${CssClasses.TAB}`);\n        if (tabEl === null) {\n          return;\n        }\n        this.setActiveTab([...this.tabs].indexOf(tabEl) + 1);\n      }\n    };\n    /**\n     * Handles key press events to trigger changing the selected page. When the\n     * user uses arrow left/right, it changes the active tab in the component.\n     */\n    this.handleKeydown = (e) => {\n      if (e.code === Key.RIGHT || e.code === Key.LEFT) {\n        if (e.code === Key.RIGHT) {\n          this.setActiveTab(this.getActiveTab() + 1);\n        } else if (e.code === Key.LEFT) {\n          this.setActiveTab(this.getActiveTab() - 1);\n        }\n        if (this.getActiveTab() === 0) {\n          this.setActiveTab(this.totalTabs);\n        } else if (this.getActiveTab() === this.totalTabs + 1) {\n          this.setActiveTab(1);\n        }\n      }\n      if (e.code === Key.HOME) {\n        this.setActiveTab(1);\n      }\n      if (e.code === Key.END) {\n        this.setActiveTab(this.totalTabs);\n      }\n      if (e.code === Key.RIGHT || e.code === Key.LEFT || e.code === Key.HOME ||\n          e.code === Key.END) {\n        this.tabs[this.getActiveTab() - 1].focus();\n      }\n    };\n    /** Tablist element */\n    this.tablist = this.root.querySelector(`.${CssClasses.TABLIST}`);\n    /** A list of tabs elements. */\n    this.tabs = Array.from(this.tablist.querySelectorAll(`.${CssClasses.TAB}`));\n    /** A list of tab panels elements. */\n    this.tabPanels =\n        Array.from(this.root.querySelectorAll(`.${CssClasses.PANEL}`));\n    /** Total number of tabs. */\n    this.totalTabs = this.tabs.length;\n    this.currentTabChangeHandler = () => {\n      this.render();\n    };\n    this.validateElements();\n    this.setAriaRoles();\n    // Add observer instance and attach listener to the currentTab data\n    const val = this.getDataAttribute();\n    let currentTab = 1;\n    if (this.isValidTab(val)) {\n      currentTab = val;\n    } else if (this.isValidTab(options.currentTab)) {\n      currentTab = options.currentTab;\n    }\n    this.observer = new Observer({\n      'currentTab': currentTab,\n    });\n    this.observer.listen('currentTab', this.currentTabChangeHandler);\n    this.tablist.addEventListener(EventType.CLICK, this.handleClick);\n    this.tablist.addEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.render();\n  }\n  validateElements() {\n    if (!this.tablist) throw new Error(`${Strings.MISSING_TABLIST}`);\n    if (this.tabs.length === 0) {\n      throw new Error(`${Strings.MISSING_TABS}`);\n    }\n    if (this.tabPanels.length === 0) {\n      throw new Error(`${Strings.MISSING_TABPANELS}`);\n    }\n  }\n  /** Get the current Tab value from data attributes. */\n  getDataAttribute() {\n    return Number(this.root.dataset[TabsAttrs.CURRENT]);\n  }\n  /** Render the Tabs component. */\n  render() {\n    const currentPage = this.getActiveTab();\n    if (currentPage < 1 || currentPage > this.totalTabs) {\n      return;\n    }\n    for (const [index, el] of this.tabs.entries()) {\n      const isSelected = index === currentPage - 1;\n      el.tabIndex = isSelected ? TabIndex.TABBABLE : TabIndex.NOT_TABBABLE;\n      el.setAttribute(Attribute.ARIA_SELECTED, isSelected.toString());\n    }\n    for (const el of this.tabPanels) {\n      el.classList.remove(GlueCssClasses.SHOW);\n    }\n    this.tabPanels[currentPage - 1].classList.add(GlueCssClasses.SHOW);\n  }\n  /**\n   * Provide spoken feedback to describe this component as tabs. If you've\n   * added new dom, you'll want to call this method.\n   */\n  setAriaRoles() {\n    this.tablist.setAttribute(Attribute.ROLE, Role.TABLIST);\n    this.tabs.forEach((el, index) => {\n      el.setAttribute(Attribute.ROLE, Role.TAB);\n      el.setAttribute(Attribute.ARIA_CONTROLS, this.tabPanels[index].id);\n    });\n    this.tabPanels.forEach((el, index) => {\n      el.setAttribute(Attribute.ARIA_LABELLEDBY, this.tabs[index].id);\n      el.setAttribute(Attribute.ROLE, Role.TABPANEL);\n    });\n  }\n  /** Remove all aria roles. */\n  removeAriaRoles() {\n    this.tablist.removeAttribute(Attribute.ROLE);\n    for (const el of this.tabs) {\n      el.removeAttribute(Attribute.ROLE);\n      el.removeAttribute(Attribute.ARIA_CONTROLS);\n      el.removeAttribute(Attribute.TAB_INDEX);\n      el.removeAttribute(Attribute.ARIA_SELECTED);\n    }\n    for (const el of this.tabPanels) {\n      el.removeAttribute(Attribute.ARIA_LABELLEDBY);\n      el.removeAttribute(Attribute.ROLE);\n    }\n  }\n  setActiveTab(idx) {\n    this.observer.data.currentTab = idx;\n  }\n  getActiveTab() {\n    return this.observer.data.currentTab;\n  }\n  /**\n   * Return true if the tab index value is between 1 and the total tabs count.\n   */\n  isValidTab(val) {\n    return Number.isInteger(val) && val >= 1 && val <= this.totalTabs;\n  }\n  /** Restores DOM back to previous state and removes event listeners. */\n  destroy() {\n    this.observer.unlisten('currentTab', this.currentTabChangeHandler);\n    this.tablist.removeEventListener(EventType.CLICK, this.handleClick);\n    this.tablist.removeEventListener(EventType.KEYDOWN, this.handleKeydown);\n    this.removeAriaRoles();\n    this.observer = new Observer({\n      'currentTab': 1,\n    });\n  }\n}\nexport {Tabs};\n","var CssClasses;\n(function(CssClasses) {\nCssClasses['ROOT'] = 'glue-tooltip';\nCssClasses['ANIMATION'] = 'glue-tooltip__content--animation';\nCssClasses['BODY'] = 'glue-tooltip__body';\nCssClasses['CONTENT'] = 'glue-tooltip__content';\nCssClasses['HEADER'] = 'glue-tooltip__header';\nCssClasses['LINK'] = 'glue-tooltip__link';\nCssClasses['RICH'] = 'glue-tooltip--rich';\nCssClasses['SHOW_TOOLTIP'] = 'glue-tooltip__content--shown';\nCssClasses['TRIGGER'] = 'glue-tooltip__trigger';\nCssClasses['TRIGGER_LINK'] = 'glue-tooltip__trigger--link';\nCssClasses['TRIGGER_ICON'] = 'glue-tooltip__trigger--icon';\nCssClasses['TRIGGER_ICONAFTER'] = 'glue-tooltip__trigger--icon-after';\nCssClasses['TONAL_LINK'] = 'glue-inline-tonal-link';\n})(CssClasses || (CssClasses = {}));\n/**\n * Custom tooltip events\n */\nvar CustomEvent;\n(function(CustomEvent) {\nCustomEvent['CLOSE_EVENT'] = 'gluetooltipclose';\nCustomEvent['SHOW_EVENT'] = 'gluetooltipshow';\n})(CustomEvent || (CustomEvent = {}));\nvar ErrorMessage;\n(function(ErrorMessage) {\nErrorMessage['MISSING_CONTENT'] = 'The tooltip content element is missing';\nErrorMessage['MISSING_TRIGGER'] = 'The tooltip trigger element is missing';\nErrorMessage['INCORRECT_POSITION'] =\n    'data-glue-tooltip-auto-position attribute only accepts true or false value.';\n})(ErrorMessage || (ErrorMessage = {}));\nvar DataAttrs;\n(function(DataAttrs) {\nDataAttrs['AUTO_POSITION'] = 'glueTooltipAutoPosition';\n})(DataAttrs || (DataAttrs = {}));\nexport {CssClasses, CustomEvent, DataAttrs, ErrorMessage};\n","import {Component} from '../base';\nimport {getOverlayAutoPosition} from '../base/utils';\nimport {Attribute, Role, TabIndex} from '../constants/attribute';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\n\nimport {CssClasses, CustomEvent, DataAttrs, ErrorMessage} from './constants';\n\n/**\n * A component that pops up when you hover over an interactive object.\n *\n * Responsibilities:\n *  - Provide public methods for open, close and destroy\n *  - Add ARIA labels for a11y\n *  - Reposition tooltip when it is on the edge of the page\n *  - Customize Tooltip by turning on/off auto position\n *  - Expose Tooltip show and hide events\n */\nclass Tooltip extends Component {\n  constructor(root, options) {\n    super(root);\n    /**\n     * Checks target element and calls method for tooltip display.\n     */\n    this.handleOpen = (event) => {\n      const targetEl = event.target;\n      if (targetEl instanceof HTMLElement && this.isTooltipChild(targetEl)) {\n        this.open();\n      }\n    };\n    /**\n     * Checks target element and calls method for tooltip hide.\n     */\n    this.handleClose = (event) => {\n      const targetEl = event.target;\n      if (targetEl instanceof HTMLElement && this.isTooltipChild(targetEl)) {\n        this.close();\n      }\n    };\n    /**\n     * Event handler for Escape key.\n     */\n    this.handleKeyup = (event) => {\n      const targetEl = event.target;\n      if (event.key === Key.ESC) {\n        if (targetEl instanceof HTMLElement &&\n            this.content.contains(targetEl)) {\n          this.trigger.focus();\n        }\n        this.close();\n      }\n    };\n    /**\n     * Checks click on document and calls method for tooltip display.\n     */\n    this.handleClick = (event) => {\n      const targetEl = event.target;\n      if (targetEl instanceof HTMLElement && !this.isTooltipChild(targetEl)) {\n        this.close();\n      }\n    };\n    /**\n     * Adds animation class on tooltip transition start.\n     */\n    this.handleTransitionStart = () => {\n      if (this.content.classList.contains(CssClasses.SHOW_TOOLTIP)) {\n        this.content.classList.add(CssClasses.ANIMATION);\n      }\n    };\n    /**\n     * Removes animation class on tooltip transition end.\n     */\n    this.handleTransitionEnd = () => {\n      if (this.content.classList.contains(CssClasses.SHOW_TOOLTIP)) return;\n      this.content.classList.remove(CssClasses.ANIMATION);\n    };\n    /**\n     * Recalculates the tooltip position and displays it properly as per updated\n     * screen size.\n     */\n    this.handleResize = () => {\n      this.setTooltipPosition();\n    };\n    let element = this.root.querySelector(`.${CssClasses.TRIGGER}`);\n    if (!element) {\n      throw new Error(ErrorMessage.MISSING_TRIGGER);\n    } else {\n      this.trigger = element;\n    }\n    element = this.root.querySelector(`.${CssClasses.CONTENT}`);\n    if (!element) {\n      throw new Error(ErrorMessage.MISSING_CONTENT);\n    } else {\n      this.content = element;\n      this.content.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n      // Set aria-controls (extend value if it already exists)\n      const ariaControlsElements = [\n        this.content.id,\n        this.trigger.getAttribute(Attribute.ARIA_CONTROLS),\n      ];\n      this.trigger.setAttribute(\n          Attribute.ARIA_CONTROLS, ariaControlsElements.join(' ').trim());\n      if (this.content.getAttribute(Attribute.ROLE) === Role.DIALOG) {\n        this.content.tabIndex = TabIndex.TABBABLE;\n      }\n    }\n    // Compile the final set of options.\n    this.options = this.getAttributeOptions(options);\n    this.registerEvents();\n  }\n  /**\n   * Checks if the element is present inside the tooltip.\n   * @param targetEl DOM node which is to be checked\n   * @return true if DOM node is present in tooltip\n   */\n  isTooltipChild(targetEl) {\n    return this.trigger.contains(targetEl) || this.content.contains(targetEl) ?\n        true :\n        false;\n  }\n  /**\n   * Get attributes from target element and construct an options object.\n   */\n  getAttributeOptions(passedOptions) {\n    const attrOptions = {};\n    const attrData = this.root.dataset;\n    if (DataAttrs.AUTO_POSITION in attrData) {\n      let setPosition;\n      if (attrData[DataAttrs.AUTO_POSITION] === 'false') {\n        setPosition = false;\n      } else if (attrData[DataAttrs.AUTO_POSITION] === 'true') {\n        setPosition = true;\n      } else {\n        throw new Error(ErrorMessage.INCORRECT_POSITION);\n      }\n      attrOptions.autoPosition = setPosition;\n    }\n    const fullOptions =\n        Object.assign({}, Tooltip.defaultOptions, passedOptions, attrOptions);\n    return fullOptions;\n  }\n  /**\n   * Default Tooltip options\n   */\n  static get defaultOptions() {\n    return {\n      autoPosition: true,\n    };\n  }\n  /**\n   * Adds events for the tooltip.\n   */\n  registerEvents() {\n    this.root.addEventListener(EventType.MOUSEENTER, this.handleOpen, true);\n    this.root.addEventListener(EventType.FOCUS, this.handleOpen, true);\n    this.root.addEventListener(EventType.MOUSELEAVE, this.handleClose, true);\n    this.root.addEventListener(EventType.BLUR, this.handleClose, true);\n    document.addEventListener(EventType.KEYUP, this.handleKeyup);\n    document.addEventListener(EventType.CLICK, this.handleClick);\n    window.addEventListener(EventType.RESIZE, this.handleResize);\n    this.content.addEventListener(\n        EventType.TRANSITIONSTART, this.handleTransitionStart);\n    this.content.addEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n  }\n  /**\n   * Calculates the position of the Tooltip.\n   */\n  setTooltipPosition() {\n    if (this.options.autoPosition === true) {\n      const pos = getOverlayAutoPosition(\n          this.root, this.content, this.trigger, this.options.placement);\n      if (pos) {\n        const [left, top] = pos;\n        this.content.style.left = `${left}px`;\n        this.content.style.top = `${top}px`;\n      }\n    }\n  }\n  /**\n   * Displays the tooltip.\n   */\n  open() {\n    if (this.content.classList.contains(CssClasses.SHOW_TOOLTIP)) return;\n    this.setTooltipPosition();\n    this.content.classList.add(CssClasses.SHOW_TOOLTIP);\n    this.content.setAttribute(Attribute.ARIA_HIDDEN, 'false');\n    this.emit(CustomEvent.SHOW_EVENT, {}, true);\n  }\n  /**\n   * Hides the tooltip.\n   */\n  close() {\n    if (!this.content.classList.contains(CssClasses.SHOW_TOOLTIP)) return;\n    this.content.classList.remove(CssClasses.SHOW_TOOLTIP);\n    this.content.setAttribute(Attribute.ARIA_HIDDEN, 'true');\n    this.emit(CustomEvent.CLOSE_EVENT, {}, true);\n  }\n  /** Resets component and removes event listeners. */\n  destroy() {\n    this.close();\n    this.content.removeAttribute(Attribute.ARIA_HIDDEN);\n    this.trigger.removeAttribute(Attribute.ARIA_CONTROLS);\n    this.root.removeEventListener(EventType.MOUSEENTER, this.handleOpen, true);\n    this.root.removeEventListener(EventType.FOCUS, this.handleOpen, true);\n    this.root.removeEventListener(EventType.MOUSELEAVE, this.handleClose, true);\n    this.root.removeEventListener(EventType.BLUR, this.handleClose, true);\n    document.removeEventListener(EventType.KEYUP, this.handleKeyup);\n    document.removeEventListener(EventType.CLICK, this.handleClick);\n    window.removeEventListener(EventType.RESIZE, this.handleResize);\n    this.content.removeEventListener(\n        EventType.TRANSITIONSTART, this.handleTransitionStart);\n    this.content.removeEventListener(\n        EventType.TRANSITIONEND, this.handleTransitionEnd);\n  }\n}\n/**\n * Initializes multiple tooltips with single call.\n */\nfunction initMultiTooltip(tooltipElems) {\n  [...tooltipElems].forEach((tooltipElem) => {\n    // tslint:disable-next-line:no-unused-expression\n    new Tooltip(tooltipElem);\n  });\n}\nexport {Tooltip, initMultiTooltip};\n","/**\n * Component element data attribute names used as player options.\n */\nvar DataAttrs;\n(function(DataAttrs) {\nDataAttrs['VIDEO_ID'] = 'glueYtVideoVid';\nDataAttrs['PLAYER_ID'] = 'glueYtPlayerId';\nDataAttrs['HEIGHT'] = 'glueYtVideoHeight';\nDataAttrs['WIDTH'] = 'glueYtVideoWidth';\nDataAttrs['PLAYER_VARS'] = 'glueYtVideoPlayerVars';\n})(DataAttrs || (DataAttrs = {}));\nvar CssClasses;\n(function(CssClasses) {\nCssClasses['BASE'] = 'glue-video';\nCssClasses['PREVIEW_CONTAINER'] = 'glue-video__preview-container';\nCssClasses['DURATION'] = 'glue-video__timestamp-duration';\nCssClasses['HIDE_ELEMENT'] = 'glue-video--hidden';\nCssClasses['IMAGE_CONTAINER'] = 'glue-video__preview-image';\nCssClasses['TIMESTAMP'] = 'glue-video__timestamp';\nCssClasses['TIMESTAMP_SHOW'] = 'glue-video__timestamp--visible';\nCssClasses['VIDEO_CONTAINER'] = 'glue-video__container';\nCssClasses['INLINE_VIDEO'] = 'glue-video__preview-container--inline';\nCssClasses['LABEL'] = 'glue-video__label';\n})(CssClasses || (CssClasses = {}));\nvar ErrorMessages;\n(function(ErrorMessages) {\nErrorMessages['MISSING_VIDEO'] = 'The video element is missing';\n})(ErrorMessages || (ErrorMessages = {}));\nexport {CssClasses, DataAttrs, ErrorMessages};\n","// taze: youtube from //third_party/javascript/typings/youtube\nimport {Component} from '../base/index';\nimport {Attribute, Role} from '../constants/attribute';\nimport {EventType} from '../events/eventtype';\nimport {Key} from '../events/key';\nimport {isElementFocusable} from '../focus';\nimport {CssClasses as ModalCssClasses, Strings as ModalStrings,} from '../modal/constants';\nimport {Modal} from '../modal/index';\n\nimport {CssClasses, DataAttrs, ErrorMessages} from './constants';\nimport {YoutubeVideoManager as VideoManager} from './videomanager';\n\n/**\n * Creates a YouTube Video component with access to the controls API.\n */\nclass YoutubeVideo extends Component {\n  constructor(root, options) {\n    var _a, _b;\n    super(root);\n    // Unique element id for the player.\n    this.id = '';\n    /**\n     * Hides image overlay and plays video.\n     */\n    this.hidePosterAndPlay = (e) => {\n      var _a, _b;\n      if (this.videoElement.contains(e.target)) return;\n      // Return if it is a keyboard event, but not Enter key or Space key.\n      if (e instanceof KeyboardEvent && e.key !== Key.ENTER &&\n          e.key !== Key.SPACE) {\n        return;\n      }\n      if (this.modal) {\n        e.preventDefault();\n        this.modal.open();\n      } else {\n        (_a = this.previewElement) === null || _a === void 0 ?\n            void 0 :\n            _a.classList.add(CssClasses.HIDE_ELEMENT);\n        this.videoElement.classList.remove(CssClasses.HIDE_ELEMENT);\n        this.root.blur();  // Allows iframe to be clicked\n      }\n      (_b = this.getPlayer()) === null || _b === void 0 ? void 0 :\n                                                          _b.playVideo();\n    };\n    this.previewElement =\n        this.root.querySelector(`.${CssClasses.PREVIEW_CONTAINER}`);\n    this.root.addEventListener(EventType.CLICK, this.hidePosterAndPlay);\n    this.root.addEventListener(EventType.KEYDOWN, this.hidePosterAndPlay);\n    if (!isElementFocusable(root)) {\n      this.root.tabIndex = 0;\n    }\n    if (this.root.tagName !== 'A') {\n      this.root.setAttribute(Attribute.ROLE, Role.BUTTON);\n    }\n    const video =\n        (options === null || options === void 0 ? void 0 :\n                                                  options.modalElement) ?\n        options === null || options === void 0 ?\n        void 0 :\n        options.modalElement.querySelector(`.${CssClasses.VIDEO_CONTAINER}`) :\n        this.root.querySelector(`.${CssClasses.VIDEO_CONTAINER}`);\n    if (!video) {\n      throw new Error(ErrorMessages.MISSING_VIDEO);\n    }\n    this.videoElement = video;\n    if ((_a = this.previewElement) === null || _a === void 0 ?\n            void 0 :\n            _a.classList.contains(CssClasses.INLINE_VIDEO)) {\n      this.videoElement.classList.add(CssClasses.HIDE_ELEMENT);\n    }\n    // Create a modal component if there is modal markup.\n    this.modalCloseHandler = () => {\n      var _a;\n      (_a = this.getPlayer()) === null || _a === void 0 ? void 0 :\n                                                          _a.pauseVideo();\n    };\n    this.options = this.setPlayerOptions(options);\n    this.modalElement =\n        (options === null || options === void 0 ? void 0 :\n                                                  options.modalElement) ?\n        options === null || options === void 0 ? void 0 : options.modalElement :\n        this.root.querySelector(`.${ModalCssClasses.ROOT}`);\n    if (this.modalElement) {\n      this.modal = new Modal(this.modalElement, this.root);\n      // Needs to listen for the modal closing so the video can be paused.\n      this.modalElement.addEventListener(\n          ModalStrings.CLOSED_EVENT, this.modalCloseHandler);\n    }\n    // The manager of YT API and videos.\n    this.manager = VideoManager.getManager();\n    YT.ready(() => {\n      this.initializeVideo();\n    });\n    this.posterImageElement =\n        this.root.querySelector(`.${CssClasses.IMAGE_CONTAINER}`);\n    const posterSrc = (_b = this.posterImageElement) === null || _b === void 0 ?\n        void 0 :\n        _b.getAttribute('src');\n    if (this.posterImageElement &&\n        (posterSrc === null || posterSrc === void 0 ? void 0 :\n                                                      posterSrc.length) === 0) {\n      this.posterImageElement.src = `https://i.ytimg.com/vi_webp/${\n          this.options.videoId}/maxresdefault.webp`;\n    }\n  }\n  destroy() {\n    var _a, _b, _c, _d, _e;\n    super.destroy();\n    (_a = this.modal) === null || _a === void 0 ? void 0 : _a.close();\n    (_b = this.modal) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this.modalElement) === null || _c === void 0 ?\n        void 0 :\n        _c.removeEventListener(\n            ModalStrings.CLOSED_EVENT, this.modalCloseHandler);\n    (_d = this.root) === null || _d === void 0 ?\n        void 0 :\n        _d.removeEventListener(EventType.CLICK, this.hidePosterAndPlay);\n    (_e = this.root) === null || _e === void 0 ?\n        void 0 :\n        _e.removeEventListener(EventType.KEYDOWN, this.hidePosterAndPlay);\n    this.destroyPlayer();\n  }\n  /**\n   * Default YtVideo options\n   */\n  static get defaultOptions() {\n    return {\n      playerId: '',\n      width: '',\n      height: '',\n      videoId: '',\n      playerVars: {},\n      events: {},\n    };\n  }\n  /**\n   * Sets or creates the unique identifier for the player element to be\n   * used as the unique key.\n   */\n  initId() {\n    var _a;\n    // Get IDs in order of precedence.\n    //   1. element id attribute\n    //   2. playerId from options passed-in\n    //   3. a random unique id\n    let id = (_a = this.videoElement.id) !== null && _a !== void 0 ? _a : '';\n    // Make ID unique and random if unprovided.\n    if (this.isValidPlayerId(id)) {\n      id = this.options.playerId ||\n          `youtube-player-${Math.round(Math.random() * Math.pow(10, 6))}`;\n      // There must be an element id.\n      this.videoElement.id = id;\n    }\n    this.id = id;\n  }\n  /**\n   * Re-initialize the video player with new options.\n   * @param passedOptions The new options package.\n   */\n  refreshPlayerOptions(passedOptions) {\n    this.destroyPlayer();\n    this.options =\n        Object.assign({}, YoutubeVideo.defaultOptions, passedOptions);\n    if (this.options.playerId) this.id = this.options.playerId;\n    this.initializeVideo();\n  }\n  /**\n   * Sets the options and id of the video.\n   * Uses data-attributes, if present, otherwise use passed-in option\n   * If neither exist, use the default\n   * @param passedOptions Options passed in by the user.\n   */\n  setPlayerOptions(passedOptions) {\n    const attrOptions = {};\n    const attrData = this.videoElement.dataset;\n    if (DataAttrs.VIDEO_ID in attrData) {\n      attrOptions.videoId = attrData[DataAttrs.VIDEO_ID];\n    }\n    if (DataAttrs.PLAYER_ID in attrData) {\n      attrOptions.playerId = attrData[DataAttrs.PLAYER_ID];\n    }\n    if (DataAttrs.HEIGHT in attrData) {\n      attrOptions.height = attrData[DataAttrs.HEIGHT];\n    }\n    if (DataAttrs.WIDTH in attrData) {\n      attrOptions.width = attrData[DataAttrs.WIDTH];\n    }\n    if (DataAttrs.PLAYER_VARS in attrData) {\n      attrOptions.playerVars = attrData[DataAttrs.PLAYER_VARS];\n    }\n    const fullOptions = Object.assign(\n        {}, YoutubeVideo.defaultOptions, passedOptions, attrOptions);\n    if (fullOptions.playerId) {\n      this.id = fullOptions.playerId;\n    }\n    return fullOptions;\n  }\n  /**\n   * Initialize the video player.\n   */\n  initializeVideo() {\n    // The video can't be stored without an ID.\n    if (this.isValidPlayerId(this.id)) {\n      this.initId();\n    }\n    // Make sure the playerId is set.\n    this.options.playerId = this.id;\n    // makeVideoContainerElem will make a new sub-element that the\n    // YT Player will replace with an iframe. This step prevents\n    // replacing the root element with the iframe.\n    const el = this.videoElement.appendChild(document.createElement('div'));\n    if (this.options.events) {\n      if (this.options.events.onReady === undefined) {\n        this.options.events.onReady = () => {\n          this.setVideoTimestamp();\n        };\n      } else {\n        const userFunction = this.options.events.onReady;\n        this.options.events.onReady = (event) => {\n          this.setVideoTimestamp();\n          userFunction(event);\n        };\n      }\n    }\n    const player = new window.YT.Player(el, this.options);\n    this.manager.registerYtPlayer(this.id, player);\n  }\n  /**\n   * Gets the video duration and sets timestamp.\n   */\n  setVideoTimestamp() {\n    var _a, _b, _c, _d;\n    const timestamp = this.root.querySelector(`.${CssClasses.DURATION}`);\n    if (timestamp) {\n      const duration = (_b = (_a = this.getPlayer()) === null || _a === void 0 ?\n                            void 0 :\n                            _a.getDuration()) !== null &&\n              _b !== void 0 ?\n          _b :\n          0;\n      const mills = new Date(duration * 1000).toISOString();\n      const time = mills.substring(11, 13) === '00' ? mills.substring(14, 19) :\n                                                      mills.substring(11, 19);\n      timestamp.textContent = time;\n      (_d = (_c = this.root) === null || _c === void 0 ?\n           void 0 :\n           _c.querySelector(`.${CssClasses.TIMESTAMP}`)) === null ||\n              _d === void 0 ?\n          void 0 :\n          _d.classList.add(`${CssClasses.TIMESTAMP_SHOW}`);\n    }\n  }\n  /**\n   * Gets video player object.\n   */\n  getPlayer() {\n    return this.manager.getYtPlayer(this.id);\n  }\n  /**\n   * Destroys the video player and iframe.\n   */\n  destroyPlayer() {\n    this.manager.unregisterYtPlayer(this.id);\n  }\n  /**\n   * Gets video player ID.\n   */\n  getPlayerId() {\n    if (this.isValidPlayerId(this.id)) {\n      this.initId();\n    }\n    return this.id;\n  }\n  /**\n   * If the player ID is a valid one.\n   * This is lifted from closure goog.string.isEmptyOrWhitespace function.\n   */\n  isValidPlayerId(id) {\n    return /^[\\s\\xa0]*$/.test(id);\n  }\n}\nexport {YoutubeVideo};\n","/**\n * Manages a collection of YouTube videos. Also manages the YouTibe Video API.\n */\nclass YoutubeVideoManager {\n  constructor() {\n    this.videoObjects = new Map();\n  }\n  static getManager() {\n    if (!YoutubeVideoManager.instance) {\n      YoutubeVideoManager.instance = new YoutubeVideoManager();\n    }\n    return YoutubeVideoManager.instance;\n  }\n  static destroyManager() {\n    YoutubeVideoManager.instance = undefined;\n  }\n  /**\n   * Stores the YouTube player object\n   * @param id The id of a player.\n   * @param player The player instance.\n   */\n  registerYtPlayer(id, player) {\n    this.videoObjects.set(id, player);\n  }\n  /**\n   * Destroy a player.\n   * @param id The id of a player.\n   */\n  unregisterYtPlayer(id) {\n    const player = this.videoObjects.get(id);\n    player === null || player === void 0 ? void 0 : player.destroy();\n    this.videoObjects.delete(id);\n    // If we just destroyed the last video, then the manager\n    // should destroy iteself since it now manages nothing.\n    if (this.videoObjects.size === 0) {\n      YoutubeVideoManager.destroyManager();\n    }\n  }\n  /**\n   * Get YouTube player object.\n   * @param id The id of a player.\n   */\n  getYtPlayer(id) {\n    return this.videoObjects.get(id);\n  }\n}\nYoutubeVideoManager.instance = undefined;\nexport {YoutubeVideoManager};\n","import * as elements from \"typed-html\";\n\nexport default function (isDesktop?: boolean) {\n  const classCalculated =\n    \"glue-header__container\" + isDesktop ? \"glue-header__container--cta\" : \"\";\n\n  return (\n    <div class={classCalculated}>\n      <div class=\"glue-header__cta\">\n        <button class=\"glue-button glue-button--medium-emphasis\">\n          Secondary\n        </button>\n        <button class=\"glue-button glue-button--high-emphasis\">Primary</button>\n      </div>\n    </div>\n  );\n}\n","import * as elements from \"typed-html\";\n\nexport default function () {\n  const links = [\n    {\n      label: \"Homepage\",\n      href: \"/\",\n    },\n    {\n      label: \"About Us\",\n      href: \"/about-us\",\n    },\n  ];\n  return (\n    <div class=\"glue-header__container glue-header__container--linkbar\">\n      <nav class=\"glue-header__link-bar\">\n        <ul class=\"glue-header__list\">\n          {links.map((i) => (\n            // glue-header__item--active\n            <li class=\"glue-header__item\">\n              <a\n                class=\"glue-header__link\"\n                href={i.href}\n                onclick=\"navigate(event)\"\n                aria-current=\"page\"\n              >\n                {i.label}\n              </a>\n            </li>\n          ))}\n        </ul>\n      </nav>\n    </div>\n  );\n}\n","import * as elements from \"typed-html\";\n\nexport default function (includeHamburger?: boolean) {\n  return (\n    <div class=\"glue-header__container\">\n      <div class=\"glue-header__lock-up\">\n        {/* <!-- Hamburger button component --> */}\n        {includeHamburger ? (\n          <div class=\"glue-header__hamburger\">\n            <button\n              class=\"glue-header__drawer-toggle-btn\"\n              aria-label=\"Open the navigation drawer\"\n            >\n              <svg\n                class=\"glue-icon glue-icon--24px\"\n                role=\"presentation\"\n                aria-hidden=\"true\"\n              >\n                <use href=\"./assets/img/glue-icons.svg#menu\"></use>\n              </svg>\n            </button>\n          </div> \n        ): ''}\n        <div class=\"glue-header__logo\">\n          <a class=\"glue-header__logo-link\" href=\"#\" title=\"Google\">\n            {/* <!-- Logo component --> */}\n            <div class=\"glue-header__logo-container\">\n              <svg\n                class=\"glue-header__logo-svg\"\n                role=\"presentation\"\n                aria-hidden=\"true\"\n              >\n                <use href=\"/assets/img/glue-icons.svg#google-color-logo\"></use>\n              </svg>\n            </div>\n            <span class=\"glue-header__logo--product\">Product</span>\n          </a>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import * as elements from \"typed-html\";\n\nexport default function() {\n  return (\n    <a href=\"#content\" class=\"glue-header__link glue-header__skip-content\">\n      Jump to Content\n    </a>\n  );\n}\n","import * as elements from \"typed-html\";\n\n// Components\nimport skipToContent from \"./components/skipToContent\";\nimport lockup from \"./components/lockup\";\nimport callToActions from \"./components/callToActions\";\nimport linkbar from \"./components/linkbar\";\n\n// UI Components\nimport { Header } from \"@google/glue\";\n\nexport default function () {\n  setTimeout(() => {\n    const headerEl = document.querySelector<HTMLElement>(\".glue-header\");\n    if (headerEl) new Header(headerEl);\n  }, 200);\n\n  return (\n    <header>\n      <header class=\"glue-header glue-header--single\">\n        {/* <!-- skip to content component --> */}\n        {skipToContent()}\n        <div class=\"glue-header__bar glue-header__bar--mobile\">\n          <div class=\"glue-header__tier\">\n            {/* <!-- mobile lockup component --> */}\n            {lockup(true)}\n            {/* <!-- mobile CTA component --> */}\n            {callToActions(false)}\n          </div>\n        </div>\n        <div class=\"glue-header__bar glue-header__bar--desktop glue-header__drawer\">\n          <div class=\"glue-header__tier\">\n            {/* <!-- desktop lockup component --> */}\n            {lockup(false)}\n            {/* <!-- linkbar component --> */}\n            {linkbar()}\n            {/* <!-- desktop CTA component --> */}\n            {callToActions(true)}\n          </div>\n        </div>\n        <div\n          class=\"glue-header__drawer-backdrop\"\n          role=\"button\"\n          aria-label=\"Close menu\"\n        ></div>\n      </header>\n    </header>\n  );\n}\n"],"names":[],"sourceRoot":""}